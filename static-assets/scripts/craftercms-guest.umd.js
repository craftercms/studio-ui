(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@prettier/plugin-xml'), require('prettier/standalone')) :
  typeof define === 'function' && define.amd ? define('craftercms.guest', ['exports', '@prettier/plugin-xml', 'prettier/standalone'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.craftercms = global.craftercms || {}, global.craftercms.guest = {})));
})(this, (function (exports) { 'use strict';

  function _extends$6() {
    _extends$6 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$6.apply(this, arguments);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getAugmentedNamespace(n) {
  	if (n.__esModule) return n;
  	var a = Object.defineProperty({}, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var react = {exports: {}};

  var react_production_min = {};

  /*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  */
  /* eslint-disable no-unused-vars */

  var getOwnPropertySymbols = Object.getOwnPropertySymbols;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var propIsEnumerable = Object.prototype.propertyIsEnumerable;

  function toObject(val) {
    if (val === null || val === undefined) {
      throw new TypeError('Object.assign cannot be called with null or undefined');
    }

    return Object(val);
  }

  function shouldUseNative() {
    try {
      if (!Object.assign) {
        return false;
      } // Detect buggy property enumeration order in older V8 versions.
      // https://bugs.chromium.org/p/v8/issues/detail?id=4118


      var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

      test1[5] = 'de';

      if (Object.getOwnPropertyNames(test1)[0] === '5') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test2 = {};

      for (var i = 0; i < 10; i++) {
        test2['_' + String.fromCharCode(i)] = i;
      }

      var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
        return test2[n];
      });

      if (order2.join('') !== '0123456789') {
        return false;
      } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


      var test3 = {};
      'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
        test3[letter] = letter;
      });

      if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
        return false;
      }

      return true;
    } catch (err) {
      // We don't expect any of the above to throw, but better to be safe.
      return false;
    }
  }

  var objectAssign = shouldUseNative() ? Object.assign : function (target, source) {
    var from;
    var to = toObject(target);
    var symbols;

    for (var s = 1; s < arguments.length; s++) {
      from = Object(arguments[s]);

      for (var key in from) {
        if (hasOwnProperty.call(from, key)) {
          to[key] = from[key];
        }
      }

      if (getOwnPropertySymbols) {
        symbols = getOwnPropertySymbols(from);

        for (var i = 0; i < symbols.length; i++) {
          if (propIsEnumerable.call(from, symbols[i])) {
            to[symbols[i]] = from[symbols[i]];
          }
        }
      }
    }

    return to;
  };

  /** @license React v17.0.2
   * react.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var l$2 = objectAssign,
      n$3 = 60103,
      p$3 = 60106;

  react_production_min.Fragment = 60107;
  react_production_min.StrictMode = 60108;
  react_production_min.Profiler = 60114;
  var q$3 = 60109,
      r$3 = 60110,
      t$1 = 60112;
  react_production_min.Suspense = 60113;
  var u$2 = 60115,
      v$2 = 60116;

  if ("function" === typeof Symbol && Symbol.for) {
    var w$2 = Symbol.for;
    n$3 = w$2("react.element");
    p$3 = w$2("react.portal");
    react_production_min.Fragment = w$2("react.fragment");
    react_production_min.StrictMode = w$2("react.strict_mode");
    react_production_min.Profiler = w$2("react.profiler");
    q$3 = w$2("react.provider");
    r$3 = w$2("react.context");
    t$1 = w$2("react.forward_ref");
    react_production_min.Suspense = w$2("react.suspense");
    u$2 = w$2("react.memo");
    v$2 = w$2("react.lazy");
  }

  var x$2 = "function" === typeof Symbol && Symbol.iterator;

  function y$3(a) {
    if (null === a || "object" !== typeof a) return null;
    a = x$2 && a[x$2] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }

  function z$2(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);

    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }

  var A$2 = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {}
  },
      B$3 = {};

  function C$1(a, b, c) {
    this.props = a;
    this.context = b;
    this.refs = B$3;
    this.updater = c || A$2;
  }

  C$1.prototype.isReactComponent = {};

  C$1.prototype.setState = function (a, b) {
    if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(z$2(85));
    this.updater.enqueueSetState(this, a, b, "setState");
  };

  C$1.prototype.forceUpdate = function (a) {
    this.updater.enqueueForceUpdate(this, a, "forceUpdate");
  };

  function D$3() {}

  D$3.prototype = C$1.prototype;

  function E$3(a, b, c) {
    this.props = a;
    this.context = b;
    this.refs = B$3;
    this.updater = c || A$2;
  }

  var F$3 = E$3.prototype = new D$3();
  F$3.constructor = E$3;
  l$2(F$3, C$1.prototype);
  F$3.isPureReactComponent = !0;
  var G$3 = {
    current: null
  },
      H$3 = Object.prototype.hasOwnProperty,
      I$3 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

  function J(a, b, c) {
    var e,
        d = {},
        k = null,
        h = null;
    if (null != b) for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) H$3.call(b, e) && !I$3.hasOwnProperty(e) && (d[e] = b[e]);
    var g = arguments.length - 2;
    if (1 === g) d.children = c;else if (1 < g) {
      for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];

      d.children = f;
    }
    if (a && a.defaultProps) for (e in g = a.defaultProps, g) void 0 === d[e] && (d[e] = g[e]);
    return {
      $$typeof: n$3,
      type: a,
      key: k,
      ref: h,
      props: d,
      _owner: G$3.current
    };
  }

  function K(a, b) {
    return {
      $$typeof: n$3,
      type: a.type,
      key: b,
      ref: a.ref,
      props: a.props,
      _owner: a._owner
    };
  }

  function L$1(a) {
    return "object" === typeof a && null !== a && a.$$typeof === n$3;
  }

  function escape$1(a) {
    var b = {
      "=": "=0",
      ":": "=2"
    };
    return "$" + a.replace(/[=:]/g, function (a) {
      return b[a];
    });
  }

  var M$2 = /\/+/g;

  function N$2(a, b) {
    return "object" === typeof a && null !== a && null != a.key ? escape$1("" + a.key) : b.toString(36);
  }

  function O$2(a, b, c, e, d) {
    var k = typeof a;
    if ("undefined" === k || "boolean" === k) a = null;
    var h = !1;
    if (null === a) h = !0;else switch (k) {
      case "string":
      case "number":
        h = !0;
        break;

      case "object":
        switch (a.$$typeof) {
          case n$3:
          case p$3:
            h = !0;
        }

    }
    if (h) return h = a, d = d(h), a = "" === e ? "." + N$2(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M$2, "$&/") + "/"), O$2(d, b, c, "", function (a) {
      return a;
    })) : null != d && (L$1(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M$2, "$&/") + "/") + a)), b.push(d)), 1;
    h = 0;
    e = "" === e ? "." : e + ":";
    if (Array.isArray(a)) for (var g = 0; g < a.length; g++) {
      k = a[g];
      var f = e + N$2(k, g);
      h += O$2(k, b, c, f, d);
    } else if (f = y$3(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = e + N$2(k, g++), h += O$2(k, b, c, f, d);else if ("object" === k) throw b = "" + a, Error(z$2(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
    return h;
  }

  function P$2(a, b, c) {
    if (null == a) return a;
    var e = [],
        d = 0;
    O$2(a, e, "", "", function (a) {
      return b.call(c, a, d++);
    });
    return e;
  }

  function Q$1(a) {
    if (-1 === a._status) {
      var b = a._result;
      b = b();
      a._status = 0;
      a._result = b;
      b.then(function (b) {
        0 === a._status && (b = b.default, a._status = 1, a._result = b);
      }, function (b) {
        0 === a._status && (a._status = 2, a._result = b);
      });
    }

    if (1 === a._status) return a._result;
    throw a._result;
  }

  var R$2 = {
    current: null
  };

  function S$2() {
    var a = R$2.current;
    if (null === a) throw Error(z$2(321));
    return a;
  }

  var T$1 = {
    ReactCurrentDispatcher: R$2,
    ReactCurrentBatchConfig: {
      transition: 0
    },
    ReactCurrentOwner: G$3,
    IsSomeRendererActing: {
      current: !1
    },
    assign: l$2
  };
  react_production_min.Children = {
    map: P$2,
    forEach: function (a, b, c) {
      P$2(a, function () {
        b.apply(this, arguments);
      }, c);
    },
    count: function (a) {
      var b = 0;
      P$2(a, function () {
        b++;
      });
      return b;
    },
    toArray: function (a) {
      return P$2(a, function (a) {
        return a;
      }) || [];
    },
    only: function (a) {
      if (!L$1(a)) throw Error(z$2(143));
      return a;
    }
  };
  react_production_min.Component = C$1;
  react_production_min.PureComponent = E$3;
  react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T$1;

  react_production_min.cloneElement = function (a, b, c) {
    if (null === a || void 0 === a) throw Error(z$2(267, a));
    var e = l$2({}, a.props),
        d = a.key,
        k = a.ref,
        h = a._owner;

    if (null != b) {
      void 0 !== b.ref && (k = b.ref, h = G$3.current);
      void 0 !== b.key && (d = "" + b.key);
      if (a.type && a.type.defaultProps) var g = a.type.defaultProps;

      for (f in b) H$3.call(b, f) && !I$3.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }

    var f = arguments.length - 2;
    if (1 === f) e.children = c;else if (1 < f) {
      g = Array(f);

      for (var m = 0; m < f; m++) g[m] = arguments[m + 2];

      e.children = g;
    }
    return {
      $$typeof: n$3,
      type: a.type,
      key: d,
      ref: k,
      props: e,
      _owner: h
    };
  };

  react_production_min.createContext = function (a, b) {
    void 0 === b && (b = null);
    a = {
      $$typeof: r$3,
      _calculateChangedBits: b,
      _currentValue: a,
      _currentValue2: a,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    a.Provider = {
      $$typeof: q$3,
      _context: a
    };
    return a.Consumer = a;
  };

  react_production_min.createElement = J;

  react_production_min.createFactory = function (a) {
    var b = J.bind(null, a);
    b.type = a;
    return b;
  };

  react_production_min.createRef = function () {
    return {
      current: null
    };
  };

  react_production_min.forwardRef = function (a) {
    return {
      $$typeof: t$1,
      render: a
    };
  };

  react_production_min.isValidElement = L$1;

  react_production_min.lazy = function (a) {
    return {
      $$typeof: v$2,
      _payload: {
        _status: -1,
        _result: a
      },
      _init: Q$1
    };
  };

  react_production_min.memo = function (a, b) {
    return {
      $$typeof: u$2,
      type: a,
      compare: void 0 === b ? null : b
    };
  };

  react_production_min.useCallback = function (a, b) {
    return S$2().useCallback(a, b);
  };

  react_production_min.useContext = function (a, b) {
    return S$2().useContext(a, b);
  };

  react_production_min.useDebugValue = function () {};

  react_production_min.useEffect = function (a, b) {
    return S$2().useEffect(a, b);
  };

  react_production_min.useImperativeHandle = function (a, b, c) {
    return S$2().useImperativeHandle(a, b, c);
  };

  react_production_min.useLayoutEffect = function (a, b) {
    return S$2().useLayoutEffect(a, b);
  };

  react_production_min.useMemo = function (a, b) {
    return S$2().useMemo(a, b);
  };

  react_production_min.useReducer = function (a, b, c) {
    return S$2().useReducer(a, b, c);
  };

  react_production_min.useRef = function (a) {
    return S$2().useRef(a);
  };

  react_production_min.useState = function (a) {
    return S$2().useState(a);
  };

  react_production_min.version = "17.0.2";

  {
    react.exports = react_production_min;
  }

  var React = react.exports;

  var reactDom = {exports: {}};

  var reactDom_production_min = {};

  var scheduler = {exports: {}};

  var scheduler_production_min = {};

  /** @license React v0.20.2
   * scheduler.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  (function (exports) {

  var f, g, h, k;

  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l = performance;

    exports.unstable_now = function () {
      return l.now();
    };
  } else {
    var p = Date,
        q = p.now();

    exports.unstable_now = function () {
      return p.now() - q;
    };
  }

  if ("undefined" === typeof window || "function" !== typeof MessageChannel) {
    var t = null,
        u = null,
        w = function () {
      if (null !== t) try {
        var a = exports.unstable_now();
        t(!0, a);
        t = null;
      } catch (b) {
        throw setTimeout(w, 0), b;
      }
    };

    f = function (a) {
      null !== t ? setTimeout(f, 0, a) : (t = a, setTimeout(w, 0));
    };

    g = function (a, b) {
      u = setTimeout(a, b);
    };

    h = function () {
      clearTimeout(u);
    };

    exports.unstable_shouldYield = function () {
      return !1;
    };

    k = exports.unstable_forceFrameRate = function () {};
  } else {
    var x = window.setTimeout,
        y = window.clearTimeout;

    if ("undefined" !== typeof console) {
      var z = window.cancelAnimationFrame;
      "function" !== typeof window.requestAnimationFrame && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
      "function" !== typeof z && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
    }

    var A = !1,
        B = null,
        C = -1,
        D = 5,
        E = 0;

    exports.unstable_shouldYield = function () {
      return exports.unstable_now() >= E;
    };

    k = function () {};

    exports.unstable_forceFrameRate = function (a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : D = 0 < a ? Math.floor(1E3 / a) : 5;
    };

    var F = new MessageChannel(),
        G = F.port2;

    F.port1.onmessage = function () {
      if (null !== B) {
        var a = exports.unstable_now();
        E = a + D;

        try {
          B(!0, a) ? G.postMessage(null) : (A = !1, B = null);
        } catch (b) {
          throw G.postMessage(null), b;
        }
      } else A = !1;
    };

    f = function (a) {
      B = a;
      A || (A = !0, G.postMessage(null));
    };

    g = function (a, b) {
      C = x(function () {
        a(exports.unstable_now());
      }, b);
    };

    h = function () {
      y(C);
      C = -1;
    };
  }

  function H(a, b) {
    var c = a.length;
    a.push(b);

    a: for (;;) {
      var d = c - 1 >>> 1,
          e = a[d];
      if (void 0 !== e && 0 < I(e, b)) a[d] = b, a[c] = e, c = d;else break a;
    }
  }

  function J(a) {
    a = a[0];
    return void 0 === a ? null : a;
  }

  function K(a) {
    var b = a[0];

    if (void 0 !== b) {
      var c = a.pop();

      if (c !== b) {
        a[0] = c;

        a: for (var d = 0, e = a.length; d < e;) {
          var m = 2 * (d + 1) - 1,
              n = a[m],
              v = m + 1,
              r = a[v];
          if (void 0 !== n && 0 > I(n, c)) void 0 !== r && 0 > I(r, n) ? (a[d] = r, a[v] = c, d = v) : (a[d] = n, a[m] = c, d = m);else if (void 0 !== r && 0 > I(r, c)) a[d] = r, a[v] = c, d = v;else break a;
        }
      }

      return b;
    }

    return null;
  }

  function I(a, b) {
    var c = a.sortIndex - b.sortIndex;
    return 0 !== c ? c : a.id - b.id;
  }

  var L = [],
      M = [],
      N = 1,
      O = null,
      P = 3,
      Q = !1,
      R = !1,
      S = !1;

  function T(a) {
    for (var b = J(M); null !== b;) {
      if (null === b.callback) K(M);else if (b.startTime <= a) K(M), b.sortIndex = b.expirationTime, H(L, b);else break;
      b = J(M);
    }
  }

  function U(a) {
    S = !1;
    T(a);
    if (!R) if (null !== J(L)) R = !0, f(V);else {
      var b = J(M);
      null !== b && g(U, b.startTime - a);
    }
  }

  function V(a, b) {
    R = !1;
    S && (S = !1, h());
    Q = !0;
    var c = P;

    try {
      T(b);

      for (O = J(L); null !== O && (!(O.expirationTime > b) || a && !exports.unstable_shouldYield());) {
        var d = O.callback;

        if ("function" === typeof d) {
          O.callback = null;
          P = O.priorityLevel;
          var e = d(O.expirationTime <= b);
          b = exports.unstable_now();
          "function" === typeof e ? O.callback = e : O === J(L) && K(L);
          T(b);
        } else K(L);

        O = J(L);
      }

      if (null !== O) var m = !0;else {
        var n = J(M);
        null !== n && g(U, n.startTime - b);
        m = !1;
      }
      return m;
    } finally {
      O = null, P = c, Q = !1;
    }
  }

  var W = k;
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;

  exports.unstable_cancelCallback = function (a) {
    a.callback = null;
  };

  exports.unstable_continueExecution = function () {
    R || Q || (R = !0, f(V));
  };

  exports.unstable_getCurrentPriorityLevel = function () {
    return P;
  };

  exports.unstable_getFirstCallbackNode = function () {
    return J(L);
  };

  exports.unstable_next = function (a) {
    switch (P) {
      case 1:
      case 2:
      case 3:
        var b = 3;
        break;

      default:
        b = P;
    }

    var c = P;
    P = b;

    try {
      return a();
    } finally {
      P = c;
    }
  };

  exports.unstable_pauseExecution = function () {};

  exports.unstable_requestPaint = W;

  exports.unstable_runWithPriority = function (a, b) {
    switch (a) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;

      default:
        a = 3;
    }

    var c = P;
    P = a;

    try {
      return b();
    } finally {
      P = c;
    }
  };

  exports.unstable_scheduleCallback = function (a, b, c) {
    var d = exports.unstable_now();
    "object" === typeof c && null !== c ? (c = c.delay, c = "number" === typeof c && 0 < c ? d + c : d) : c = d;

    switch (a) {
      case 1:
        var e = -1;
        break;

      case 2:
        e = 250;
        break;

      case 5:
        e = 1073741823;
        break;

      case 4:
        e = 1E4;
        break;

      default:
        e = 5E3;
    }

    e = c + e;
    a = {
      id: N++,
      callback: b,
      priorityLevel: a,
      startTime: c,
      expirationTime: e,
      sortIndex: -1
    };
    c > d ? (a.sortIndex = c, H(M, a), null === J(L) && a === J(M) && (S ? h() : S = !0, g(U, c - d))) : (a.sortIndex = e, H(L, a), R || Q || (R = !0, f(V)));
    return a;
  };

  exports.unstable_wrapCallback = function (a) {
    var b = P;
    return function () {
      var c = P;
      P = b;

      try {
        return a.apply(this, arguments);
      } finally {
        P = c;
      }
    };
  };
  }(scheduler_production_min));

  {
    scheduler.exports = scheduler_production_min;
  }

  /** @license React v17.0.2
   * react-dom.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var aa = react.exports,
      m$3 = objectAssign,
      r$2 = scheduler.exports;

  function y$2(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);

    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }

  if (!aa) throw Error(y$2(227));
  var ba = new Set(),
      ca = {};

  function da(a, b) {
    ea(a, b);
    ea(a + "Capture", b);
  }

  function ea(a, b) {
    ca[a] = b;

    for (a = 0; a < b.length; a++) ba.add(b[a]);
  }

  var fa = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement),
      ha = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
      ia = Object.prototype.hasOwnProperty,
      ja = {},
      ka = {};

  function la(a) {
    if (ia.call(ka, a)) return !0;
    if (ia.call(ja, a)) return !1;
    if (ha.test(a)) return ka[a] = !0;
    ja[a] = !0;
    return !1;
  }

  function ma(a, b, c, d) {
    if (null !== c && 0 === c.type) return !1;

    switch (typeof b) {
      case "function":
      case "symbol":
        return !0;

      case "boolean":
        if (d) return !1;
        if (null !== c) return !c.acceptsBooleans;
        a = a.toLowerCase().slice(0, 5);
        return "data-" !== a && "aria-" !== a;

      default:
        return !1;
    }
  }

  function na(a, b, c, d) {
    if (null === b || "undefined" === typeof b || ma(a, b, c, d)) return !0;
    if (d) return !1;
    if (null !== c) switch (c.type) {
      case 3:
        return !b;

      case 4:
        return !1 === b;

      case 5:
        return isNaN(b);

      case 6:
        return isNaN(b) || 1 > b;
    }
    return !1;
  }

  function B$2(a, b, c, d, e, f, g) {
    this.acceptsBooleans = 2 === b || 3 === b || 4 === b;
    this.attributeName = d;
    this.attributeNamespace = e;
    this.mustUseProperty = c;
    this.propertyName = a;
    this.type = b;
    this.sanitizeURL = f;
    this.removeEmptyString = g;
  }

  var D$2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (a) {
    D$2[a] = new B$2(a, 0, !1, a, null, !1, !1);
  });
  [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (a) {
    var b = a[0];
    D$2[b] = new B$2(b, 1, !1, a[1], null, !1, !1);
  });
  ["contentEditable", "draggable", "spellCheck", "value"].forEach(function (a) {
    D$2[a] = new B$2(a, 2, !1, a.toLowerCase(), null, !1, !1);
  });
  ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (a) {
    D$2[a] = new B$2(a, 2, !1, a, null, !1, !1);
  });
  "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (a) {
    D$2[a] = new B$2(a, 3, !1, a.toLowerCase(), null, !1, !1);
  });
  ["checked", "multiple", "muted", "selected"].forEach(function (a) {
    D$2[a] = new B$2(a, 3, !0, a, null, !1, !1);
  });
  ["capture", "download"].forEach(function (a) {
    D$2[a] = new B$2(a, 4, !1, a, null, !1, !1);
  });
  ["cols", "rows", "size", "span"].forEach(function (a) {
    D$2[a] = new B$2(a, 6, !1, a, null, !1, !1);
  });
  ["rowSpan", "start"].forEach(function (a) {
    D$2[a] = new B$2(a, 5, !1, a.toLowerCase(), null, !1, !1);
  });
  var oa = /[\-:]([a-z])/g;

  function pa(a) {
    return a[1].toUpperCase();
  }

  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (a) {
    var b = a.replace(oa, pa);
    D$2[b] = new B$2(b, 1, !1, a, null, !1, !1);
  });
  "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (a) {
    var b = a.replace(oa, pa);
    D$2[b] = new B$2(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
  });
  ["xml:base", "xml:lang", "xml:space"].forEach(function (a) {
    var b = a.replace(oa, pa);
    D$2[b] = new B$2(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
  });
  ["tabIndex", "crossOrigin"].forEach(function (a) {
    D$2[a] = new B$2(a, 1, !1, a.toLowerCase(), null, !1, !1);
  });
  D$2.xlinkHref = new B$2("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
  ["src", "href", "action", "formAction"].forEach(function (a) {
    D$2[a] = new B$2(a, 1, !1, a.toLowerCase(), null, !0, !0);
  });

  function qa(a, b, c, d) {
    var e = D$2.hasOwnProperty(b) ? D$2[b] : null;
    var f = null !== e ? 0 === e.type : d ? !1 : !(2 < b.length) || "o" !== b[0] && "O" !== b[0] || "n" !== b[1] && "N" !== b[1] ? !1 : !0;
    f || (na(b, c, e, d) && (c = null), d || null === e ? la(b) && (null === c ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = null === c ? 3 === e.type ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, null === c ? a.removeAttribute(b) : (e = e.type, c = 3 === e || 4 === e && !0 === c ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
  }

  var ra = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
      sa = 60103,
      ta = 60106,
      ua = 60107,
      wa = 60108,
      xa = 60114,
      ya = 60109,
      za = 60110,
      Aa = 60112,
      Ba = 60113,
      Ca = 60120,
      Da = 60115,
      Ea = 60116,
      Fa = 60121,
      Ga = 60128,
      Ha = 60129,
      Ia = 60130,
      Ja = 60131;

  if ("function" === typeof Symbol && Symbol.for) {
    var E$2 = Symbol.for;
    sa = E$2("react.element");
    ta = E$2("react.portal");
    ua = E$2("react.fragment");
    wa = E$2("react.strict_mode");
    xa = E$2("react.profiler");
    ya = E$2("react.provider");
    za = E$2("react.context");
    Aa = E$2("react.forward_ref");
    Ba = E$2("react.suspense");
    Ca = E$2("react.suspense_list");
    Da = E$2("react.memo");
    Ea = E$2("react.lazy");
    Fa = E$2("react.block");
    E$2("react.scope");
    Ga = E$2("react.opaque.id");
    Ha = E$2("react.debug_trace_mode");
    Ia = E$2("react.offscreen");
    Ja = E$2("react.legacy_hidden");
  }

  var Ka = "function" === typeof Symbol && Symbol.iterator;

  function La(a) {
    if (null === a || "object" !== typeof a) return null;
    a = Ka && a[Ka] || a["@@iterator"];
    return "function" === typeof a ? a : null;
  }

  var Ma;

  function Na(a) {
    if (void 0 === Ma) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      Ma = b && b[1] || "";
    }
    return "\n" + Ma + a;
  }

  var Oa = !1;

  function Pa(a, b) {
    if (!a || Oa) return "";
    Oa = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;

    try {
      if (b) {
        if (b = function () {
          throw Error();
        }, Object.defineProperty(b.prototype, "props", {
          set: function () {
            throw Error();
          }
        }), "object" === typeof Reflect && Reflect.construct) {
          try {
            Reflect.construct(b, []);
          } catch (k) {
            var d = k;
          }

          Reflect.construct(a, [], b);
        } else {
          try {
            b.call();
          } catch (k) {
            d = k;
          }

          a.call(b.prototype);
        }
      } else {
        try {
          throw Error();
        } catch (k) {
          d = k;
        }

        a();
      }
    } catch (k) {
      if (k && d && "string" === typeof k.stack) {
        for (var e = k.stack.split("\n"), f = d.stack.split("\n"), g = e.length - 1, h = f.length - 1; 1 <= g && 0 <= h && e[g] !== f[h];) h--;

        for (; 1 <= g && 0 <= h; g--, h--) if (e[g] !== f[h]) {
          if (1 !== g || 1 !== h) {
            do if (g--, h--, 0 > h || e[g] !== f[h]) return "\n" + e[g].replace(" at new ", " at "); while (1 <= g && 0 <= h);
          }

          break;
        }
      }
    } finally {
      Oa = !1, Error.prepareStackTrace = c;
    }

    return (a = a ? a.displayName || a.name : "") ? Na(a) : "";
  }

  function Qa(a) {
    switch (a.tag) {
      case 5:
        return Na(a.type);

      case 16:
        return Na("Lazy");

      case 13:
        return Na("Suspense");

      case 19:
        return Na("SuspenseList");

      case 0:
      case 2:
      case 15:
        return a = Pa(a.type, !1), a;

      case 11:
        return a = Pa(a.type.render, !1), a;

      case 22:
        return a = Pa(a.type._render, !1), a;

      case 1:
        return a = Pa(a.type, !0), a;

      default:
        return "";
    }
  }

  function Ra(a) {
    if (null == a) return null;
    if ("function" === typeof a) return a.displayName || a.name || null;
    if ("string" === typeof a) return a;

    switch (a) {
      case ua:
        return "Fragment";

      case ta:
        return "Portal";

      case xa:
        return "Profiler";

      case wa:
        return "StrictMode";

      case Ba:
        return "Suspense";

      case Ca:
        return "SuspenseList";
    }

    if ("object" === typeof a) switch (a.$$typeof) {
      case za:
        return (a.displayName || "Context") + ".Consumer";

      case ya:
        return (a._context.displayName || "Context") + ".Provider";

      case Aa:
        var b = a.render;
        b = b.displayName || b.name || "";
        return a.displayName || ("" !== b ? "ForwardRef(" + b + ")" : "ForwardRef");

      case Da:
        return Ra(a.type);

      case Fa:
        return Ra(a._render);

      case Ea:
        b = a._payload;
        a = a._init;

        try {
          return Ra(a(b));
        } catch (c) {}

    }
    return null;
  }

  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "object":
      case "string":
      case "undefined":
        return a;

      default:
        return "";
    }
  }

  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
  }

  function Ua(a) {
    var b = Ta(a) ? "checked" : "value",
        c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
        d = "" + a[b];

    if (!a.hasOwnProperty(b) && "undefined" !== typeof c && "function" === typeof c.get && "function" === typeof c.set) {
      var e = c.get,
          f = c.set;
      Object.defineProperty(a, b, {
        configurable: !0,
        get: function () {
          return e.call(this);
        },
        set: function (a) {
          d = "" + a;
          f.call(this, a);
        }
      });
      Object.defineProperty(a, b, {
        enumerable: c.enumerable
      });
      return {
        getValue: function () {
          return d;
        },
        setValue: function (a) {
          d = "" + a;
        },
        stopTracking: function () {
          a._valueTracker = null;
          delete a[b];
        }
      };
    }
  }

  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }

  function Wa(a) {
    if (!a) return !1;
    var b = a._valueTracker;
    if (!b) return !0;
    var c = b.getValue();
    var d = "";
    a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value);
    a = d;
    return a !== c ? (b.setValue(a), !0) : !1;
  }

  function Xa(a) {
    a = a || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof a) return null;

    try {
      return a.activeElement || a.body;
    } catch (b) {
      return a.body;
    }
  }

  function Ya(a, b) {
    var c = b.checked;
    return m$3({}, b, {
      defaultChecked: void 0,
      defaultValue: void 0,
      value: void 0,
      checked: null != c ? c : a._wrapperState.initialChecked
    });
  }

  function Za(a, b) {
    var c = null == b.defaultValue ? "" : b.defaultValue,
        d = null != b.checked ? b.checked : b.defaultChecked;
    c = Sa(null != b.value ? b.value : c);
    a._wrapperState = {
      initialChecked: d,
      initialValue: c,
      controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
    };
  }

  function $a(a, b) {
    b = b.checked;
    null != b && qa(a, "checked", b, !1);
  }

  function ab(a, b) {
    $a(a, b);
    var c = Sa(b.value),
        d = b.type;
    if (null != c) {
      if ("number" === d) {
        if (0 === c && "" === a.value || a.value != c) a.value = "" + c;
      } else a.value !== "" + c && (a.value = "" + c);
    } else if ("submit" === d || "reset" === d) {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? bb(a, b.type, c) : b.hasOwnProperty("defaultValue") && bb(a, b.type, Sa(b.defaultValue));
    null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
  }

  function cb(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!("submit" !== d && "reset" !== d || void 0 !== b.value && null !== b.value)) return;
      b = "" + a._wrapperState.initialValue;
      c || b === a.value || (a.value = b);
      a.defaultValue = b;
    }

    c = a.name;
    "" !== c && (a.name = "");
    a.defaultChecked = !!a._wrapperState.initialChecked;
    "" !== c && (a.name = c);
  }

  function bb(a, b, c) {
    if ("number" !== b || Xa(a.ownerDocument) !== a) null == c ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c);
  }

  function db$1(a) {
    var b = "";
    aa.Children.forEach(a, function (a) {
      null != a && (b += a);
    });
    return b;
  }

  function eb(a, b) {
    a = m$3({
      children: void 0
    }, b);
    if (b = db$1(b.children)) a.children = b;
    return a;
  }

  function fb(a, b, c, d) {
    a = a.options;

    if (b) {
      b = {};

      for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;

      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    } else {
      c = "" + Sa(c);
      b = null;

      for (e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = !0;
          d && (a[e].defaultSelected = !0);
          return;
        }

        null !== b || a[e].disabled || (b = a[e]);
      }

      null !== b && (b.selected = !0);
    }
  }

  function gb(a, b) {
    if (null != b.dangerouslySetInnerHTML) throw Error(y$2(91));
    return m$3({}, b, {
      value: void 0,
      defaultValue: void 0,
      children: "" + a._wrapperState.initialValue
    });
  }

  function hb(a, b) {
    var c = b.value;

    if (null == c) {
      c = b.children;
      b = b.defaultValue;

      if (null != c) {
        if (null != b) throw Error(y$2(92));

        if (Array.isArray(c)) {
          if (!(1 >= c.length)) throw Error(y$2(93));
          c = c[0];
        }

        b = c;
      }

      null == b && (b = "");
      c = b;
    }

    a._wrapperState = {
      initialValue: Sa(c)
    };
  }

  function ib(a, b) {
    var c = Sa(b.value),
        d = Sa(b.defaultValue);
    null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && a.defaultValue !== c && (a.defaultValue = c));
    null != d && (a.defaultValue = "" + d);
  }

  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && "" !== b && null !== b && (a.value = b);
  }

  var kb = {
    html: "http://www.w3.org/1999/xhtml",
    mathml: "http://www.w3.org/1998/Math/MathML",
    svg: "http://www.w3.org/2000/svg"
  };

  function lb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";

      case "math":
        return "http://www.w3.org/1998/Math/MathML";

      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }

  function mb(a, b) {
    return null == a || "http://www.w3.org/1999/xhtml" === a ? lb(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
  }

  var nb,
      ob = function (a) {
    return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function () {
        return a(b, c, d, e);
      });
    } : a;
  }(function (a, b) {
    if (a.namespaceURI !== kb.svg || "innerHTML" in a) a.innerHTML = b;else {
      nb = nb || document.createElement("div");
      nb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>";

      for (b = nb.firstChild; a.firstChild;) a.removeChild(a.firstChild);

      for (; b.firstChild;) a.appendChild(b.firstChild);
    }
  });

  function pb(a, b) {
    if (b) {
      var c = a.firstChild;

      if (c && c === a.lastChild && 3 === c.nodeType) {
        c.nodeValue = b;
        return;
      }
    }

    a.textContent = b;
  }

  var qb = {
    animationIterationCount: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  },
      rb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(qb).forEach(function (a) {
    rb.forEach(function (b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1);
      qb[b] = qb[a];
    });
  });

  function sb(a, b, c) {
    return null == b || "boolean" === typeof b || "" === b ? "" : c || "number" !== typeof b || 0 === b || qb.hasOwnProperty(a) && qb[a] ? ("" + b).trim() : b + "px";
  }

  function tb(a, b) {
    a = a.style;

    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--"),
          e = sb(c, b[c], d);
      "float" === c && (c = "cssFloat");
      d ? a.setProperty(c, e) : a[c] = e;
    }
  }

  var ub = m$3({
    menuitem: !0
  }, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
  });

  function vb(a, b) {
    if (b) {
      if (ub[a] && (null != b.children || null != b.dangerouslySetInnerHTML)) throw Error(y$2(137, a));

      if (null != b.dangerouslySetInnerHTML) {
        if (null != b.children) throw Error(y$2(60));
        if (!("object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML)) throw Error(y$2(61));
      }

      if (null != b.style && "object" !== typeof b.style) throw Error(y$2(62));
    }
  }

  function wb(a, b) {
    if (-1 === a.indexOf("-")) return "string" === typeof b.is;

    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;

      default:
        return !0;
    }
  }

  function xb(a) {
    a = a.target || a.srcElement || window;
    a.correspondingUseElement && (a = a.correspondingUseElement);
    return 3 === a.nodeType ? a.parentNode : a;
  }

  var yb = null,
      zb = null,
      Ab = null;

  function Bb(a) {
    if (a = Cb(a)) {
      if ("function" !== typeof yb) throw Error(y$2(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }

  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }

  function Fb() {
    if (zb) {
      var a = zb,
          b = Ab;
      Ab = zb = null;
      Bb(a);
      if (b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }

  function Gb(a, b) {
    return a(b);
  }

  function Hb(a, b, c, d, e) {
    return a(b, c, d, e);
  }

  function Ib() {}

  var Jb = Gb,
      Kb = !1,
      Lb = !1;

  function Mb() {
    if (null !== zb || null !== Ab) Ib(), Fb();
  }

  function Nb(a, b, c) {
    if (Lb) return a(b, c);
    Lb = !0;

    try {
      return Jb(a, b, c);
    } finally {
      Lb = !1, Mb();
    }
  }

  function Ob(a, b) {
    var c = a.stateNode;
    if (null === c) return null;
    var d = Db(c);
    if (null === d) return null;
    c = d[b];

    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
        a = !d;
        break a;

      default:
        a = !1;
    }

    if (a) return null;
    if (c && "function" !== typeof c) throw Error(y$2(231, b, typeof c));
    return c;
  }

  var Pb = !1;
  if (fa) try {
    var Qb = {};
    Object.defineProperty(Qb, "passive", {
      get: function () {
        Pb = !0;
      }
    });
    window.addEventListener("test", Qb, Qb);
    window.removeEventListener("test", Qb, Qb);
  } catch (a) {
    Pb = !1;
  }

  function Rb(a, b, c, d, e, f, g, h, k) {
    var l = Array.prototype.slice.call(arguments, 3);

    try {
      b.apply(c, l);
    } catch (n) {
      this.onError(n);
    }
  }

  var Sb = !1,
      Tb = null,
      Ub = !1,
      Vb = null,
      Wb = {
    onError: function (a) {
      Sb = !0;
      Tb = a;
    }
  };

  function Xb(a, b, c, d, e, f, g, h, k) {
    Sb = !1;
    Tb = null;
    Rb.apply(Wb, arguments);
  }

  function Yb(a, b, c, d, e, f, g, h, k) {
    Xb.apply(this, arguments);

    if (Sb) {
      if (Sb) {
        var l = Tb;
        Sb = !1;
        Tb = null;
      } else throw Error(y$2(198));

      Ub || (Ub = !0, Vb = l);
    }
  }

  function Zb(a) {
    var b = a,
        c = a;
    if (a.alternate) for (; b.return;) b = b.return;else {
      a = b;

      do b = a, 0 !== (b.flags & 1026) && (c = b.return), a = b.return; while (a);
    }
    return 3 === b.tag ? c : null;
  }

  function $b(a) {
    if (13 === a.tag) {
      var b = a.memoizedState;
      null === b && (a = a.alternate, null !== a && (b = a.memoizedState));
      if (null !== b) return b.dehydrated;
    }

    return null;
  }

  function ac(a) {
    if (Zb(a) !== a) throw Error(y$2(188));
  }

  function bc(a) {
    var b = a.alternate;

    if (!b) {
      b = Zb(a);
      if (null === b) throw Error(y$2(188));
      return b !== a ? null : a;
    }

    for (var c = a, d = b;;) {
      var e = c.return;
      if (null === e) break;
      var f = e.alternate;

      if (null === f) {
        d = e.return;

        if (null !== d) {
          c = d;
          continue;
        }

        break;
      }

      if (e.child === f.child) {
        for (f = e.child; f;) {
          if (f === c) return ac(e), a;
          if (f === d) return ac(e), b;
          f = f.sibling;
        }

        throw Error(y$2(188));
      }

      if (c.return !== d.return) c = e, d = f;else {
        for (var g = !1, h = e.child; h;) {
          if (h === c) {
            g = !0;
            c = e;
            d = f;
            break;
          }

          if (h === d) {
            g = !0;
            d = e;
            c = f;
            break;
          }

          h = h.sibling;
        }

        if (!g) {
          for (h = f.child; h;) {
            if (h === c) {
              g = !0;
              c = f;
              d = e;
              break;
            }

            if (h === d) {
              g = !0;
              d = f;
              c = e;
              break;
            }

            h = h.sibling;
          }

          if (!g) throw Error(y$2(189));
        }
      }
      if (c.alternate !== d) throw Error(y$2(190));
    }

    if (3 !== c.tag) throw Error(y$2(188));
    return c.stateNode.current === c ? a : b;
  }

  function cc(a) {
    a = bc(a);
    if (!a) return null;

    for (var b = a;;) {
      if (5 === b.tag || 6 === b.tag) return b;
      if (b.child) b.child.return = b, b = b.child;else {
        if (b === a) break;

        for (; !b.sibling;) {
          if (!b.return || b.return === a) return null;
          b = b.return;
        }

        b.sibling.return = b.return;
        b = b.sibling;
      }
    }

    return null;
  }

  function dc(a, b) {
    for (var c = a.alternate; null !== b;) {
      if (b === a || b === c) return !0;
      b = b.return;
    }

    return !1;
  }

  var ec,
      fc,
      gc,
      hc,
      ic = !1,
      jc = [],
      kc = null,
      lc = null,
      mc = null,
      nc = new Map(),
      oc = new Map(),
      pc = [],
      qc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");

  function rc(a, b, c, d, e) {
    return {
      blockedOn: a,
      domEventName: b,
      eventSystemFlags: c | 16,
      nativeEvent: e,
      targetContainers: [d]
    };
  }

  function sc(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        kc = null;
        break;

      case "dragenter":
      case "dragleave":
        lc = null;
        break;

      case "mouseover":
      case "mouseout":
        mc = null;
        break;

      case "pointerover":
      case "pointerout":
        nc.delete(b.pointerId);
        break;

      case "gotpointercapture":
      case "lostpointercapture":
        oc.delete(b.pointerId);
    }
  }

  function tc(a, b, c, d, e, f) {
    if (null === a || a.nativeEvent !== f) return a = rc(b, c, d, e, f), null !== b && (b = Cb(b), null !== b && fc(b)), a;
    a.eventSystemFlags |= d;
    b = a.targetContainers;
    null !== e && -1 === b.indexOf(e) && b.push(e);
    return a;
  }

  function uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return kc = tc(kc, a, b, c, d, e), !0;

      case "dragenter":
        return lc = tc(lc, a, b, c, d, e), !0;

      case "mouseover":
        return mc = tc(mc, a, b, c, d, e), !0;

      case "pointerover":
        var f = e.pointerId;
        nc.set(f, tc(nc.get(f) || null, a, b, c, d, e));
        return !0;

      case "gotpointercapture":
        return f = e.pointerId, oc.set(f, tc(oc.get(f) || null, a, b, c, d, e)), !0;
    }

    return !1;
  }

  function vc(a) {
    var b = wc(a.target);

    if (null !== b) {
      var c = Zb(b);
      if (null !== c) if (b = c.tag, 13 === b) {
        if (b = $b(c), null !== b) {
          a.blockedOn = b;
          hc(a.lanePriority, function () {
            r$2.unstable_runWithPriority(a.priority, function () {
              gc(c);
            });
          });
          return;
        }
      } else if (3 === b && c.stateNode.hydrate) {
        a.blockedOn = 3 === c.tag ? c.stateNode.containerInfo : null;
        return;
      }
    }

    a.blockedOn = null;
  }

  function xc(a) {
    if (null !== a.blockedOn) return !1;

    for (var b = a.targetContainers; 0 < b.length;) {
      var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (null !== c) return b = Cb(c), null !== b && fc(b), a.blockedOn = c, !1;
      b.shift();
    }

    return !0;
  }

  function zc(a, b, c) {
    xc(a) && c.delete(b);
  }

  function Ac() {
    for (ic = !1; 0 < jc.length;) {
      var a = jc[0];

      if (null !== a.blockedOn) {
        a = Cb(a.blockedOn);
        null !== a && ec(a);
        break;
      }

      for (var b = a.targetContainers; 0 < b.length;) {
        var c = yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);

        if (null !== c) {
          a.blockedOn = c;
          break;
        }

        b.shift();
      }

      null === a.blockedOn && jc.shift();
    }

    null !== kc && xc(kc) && (kc = null);
    null !== lc && xc(lc) && (lc = null);
    null !== mc && xc(mc) && (mc = null);
    nc.forEach(zc);
    oc.forEach(zc);
  }

  function Bc(a, b) {
    a.blockedOn === b && (a.blockedOn = null, ic || (ic = !0, r$2.unstable_scheduleCallback(r$2.unstable_NormalPriority, Ac)));
  }

  function Cc(a) {
    function b(b) {
      return Bc(b, a);
    }

    if (0 < jc.length) {
      Bc(jc[0], a);

      for (var c = 1; c < jc.length; c++) {
        var d = jc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }

    null !== kc && Bc(kc, a);
    null !== lc && Bc(lc, a);
    null !== mc && Bc(mc, a);
    nc.forEach(b);
    oc.forEach(b);

    for (c = 0; c < pc.length; c++) d = pc[c], d.blockedOn === a && (d.blockedOn = null);

    for (; 0 < pc.length && (c = pc[0], null === c.blockedOn);) vc(c), null === c.blockedOn && pc.shift();
  }

  function Dc(a, b) {
    var c = {};
    c[a.toLowerCase()] = b.toLowerCase();
    c["Webkit" + a] = "webkit" + b;
    c["Moz" + a] = "moz" + b;
    return c;
  }

  var Ec = {
    animationend: Dc("Animation", "AnimationEnd"),
    animationiteration: Dc("Animation", "AnimationIteration"),
    animationstart: Dc("Animation", "AnimationStart"),
    transitionend: Dc("Transition", "TransitionEnd")
  },
      Fc = {},
      Gc = {};
  fa && (Gc = document.createElement("div").style, "AnimationEvent" in window || (delete Ec.animationend.animation, delete Ec.animationiteration.animation, delete Ec.animationstart.animation), "TransitionEvent" in window || delete Ec.transitionend.transition);

  function Hc(a) {
    if (Fc[a]) return Fc[a];
    if (!Ec[a]) return a;
    var b = Ec[a],
        c;

    for (c in b) if (b.hasOwnProperty(c) && c in Gc) return Fc[a] = b[c];

    return a;
  }

  var Ic = Hc("animationend"),
      Jc = Hc("animationiteration"),
      Kc = Hc("animationstart"),
      Lc = Hc("transitionend"),
      Mc = new Map(),
      Nc = new Map(),
      Oc = ["abort", "abort", Ic, "animationEnd", Jc, "animationIteration", Kc, "animationStart", "canplay", "canPlay", "canplaythrough", "canPlayThrough", "durationchange", "durationChange", "emptied", "emptied", "encrypted", "encrypted", "ended", "ended", "error", "error", "gotpointercapture", "gotPointerCapture", "load", "load", "loadeddata", "loadedData", "loadedmetadata", "loadedMetadata", "loadstart", "loadStart", "lostpointercapture", "lostPointerCapture", "playing", "playing", "progress", "progress", "seeking", "seeking", "stalled", "stalled", "suspend", "suspend", "timeupdate", "timeUpdate", Lc, "transitionEnd", "waiting", "waiting"];

  function Pc(a, b) {
    for (var c = 0; c < a.length; c += 2) {
      var d = a[c],
          e = a[c + 1];
      e = "on" + (e[0].toUpperCase() + e.slice(1));
      Nc.set(d, b);
      Mc.set(d, e);
      da(e, [d]);
    }
  }

  var Qc = r$2.unstable_now;
  Qc();
  var F$2 = 8;

  function Rc(a) {
    if (0 !== (1 & a)) return F$2 = 15, 1;
    if (0 !== (2 & a)) return F$2 = 14, 2;
    if (0 !== (4 & a)) return F$2 = 13, 4;
    var b = 24 & a;
    if (0 !== b) return F$2 = 12, b;
    if (0 !== (a & 32)) return F$2 = 11, 32;
    b = 192 & a;
    if (0 !== b) return F$2 = 10, b;
    if (0 !== (a & 256)) return F$2 = 9, 256;
    b = 3584 & a;
    if (0 !== b) return F$2 = 8, b;
    if (0 !== (a & 4096)) return F$2 = 7, 4096;
    b = 4186112 & a;
    if (0 !== b) return F$2 = 6, b;
    b = 62914560 & a;
    if (0 !== b) return F$2 = 5, b;
    if (a & 67108864) return F$2 = 4, 67108864;
    if (0 !== (a & 134217728)) return F$2 = 3, 134217728;
    b = 805306368 & a;
    if (0 !== b) return F$2 = 2, b;
    if (0 !== (1073741824 & a)) return F$2 = 1, 1073741824;
    F$2 = 8;
    return a;
  }

  function Sc(a) {
    switch (a) {
      case 99:
        return 15;

      case 98:
        return 10;

      case 97:
      case 96:
        return 8;

      case 95:
        return 2;

      default:
        return 0;
    }
  }

  function Tc(a) {
    switch (a) {
      case 15:
      case 14:
        return 99;

      case 13:
      case 12:
      case 11:
      case 10:
        return 98;

      case 9:
      case 8:
      case 7:
      case 6:
      case 4:
      case 5:
        return 97;

      case 3:
      case 2:
      case 1:
        return 95;

      case 0:
        return 90;

      default:
        throw Error(y$2(358, a));
    }
  }

  function Uc(a, b) {
    var c = a.pendingLanes;
    if (0 === c) return F$2 = 0;
    var d = 0,
        e = 0,
        f = a.expiredLanes,
        g = a.suspendedLanes,
        h = a.pingedLanes;
    if (0 !== f) d = f, e = F$2 = 15;else if (f = c & 134217727, 0 !== f) {
      var k = f & ~g;
      0 !== k ? (d = Rc(k), e = F$2) : (h &= f, 0 !== h && (d = Rc(h), e = F$2));
    } else f = c & ~g, 0 !== f ? (d = Rc(f), e = F$2) : 0 !== h && (d = Rc(h), e = F$2);
    if (0 === d) return 0;
    d = 31 - Vc(d);
    d = c & ((0 > d ? 0 : 1 << d) << 1) - 1;

    if (0 !== b && b !== d && 0 === (b & g)) {
      Rc(b);
      if (e <= F$2) return b;
      F$2 = e;
    }

    b = a.entangledLanes;
    if (0 !== b) for (a = a.entanglements, b &= d; 0 < b;) c = 31 - Vc(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }

  function Wc(a) {
    a = a.pendingLanes & -1073741825;
    return 0 !== a ? a : a & 1073741824 ? 1073741824 : 0;
  }

  function Xc(a, b) {
    switch (a) {
      case 15:
        return 1;

      case 14:
        return 2;

      case 12:
        return a = Yc(24 & ~b), 0 === a ? Xc(10, b) : a;

      case 10:
        return a = Yc(192 & ~b), 0 === a ? Xc(8, b) : a;

      case 8:
        return a = Yc(3584 & ~b), 0 === a && (a = Yc(4186112 & ~b), 0 === a && (a = 512)), a;

      case 2:
        return b = Yc(805306368 & ~b), 0 === b && (b = 268435456), b;
    }

    throw Error(y$2(358, a));
  }

  function Yc(a) {
    return a & -a;
  }

  function Zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);

    return b;
  }

  function $c(a, b, c) {
    a.pendingLanes |= b;
    var d = b - 1;
    a.suspendedLanes &= d;
    a.pingedLanes &= d;
    a = a.eventTimes;
    b = 31 - Vc(b);
    a[b] = c;
  }

  var Vc = Math.clz32 ? Math.clz32 : ad,
      bd = Math.log,
      cd = Math.LN2;

  function ad(a) {
    return 0 === a ? 32 : 31 - (bd(a) / cd | 0) | 0;
  }

  var dd = r$2.unstable_UserBlockingPriority,
      ed = r$2.unstable_runWithPriority,
      fd = !0;

  function gd(a, b, c, d) {
    Kb || Ib();
    var e = hd,
        f = Kb;
    Kb = !0;

    try {
      Hb(e, a, b, c, d);
    } finally {
      (Kb = f) || Mb();
    }
  }

  function id(a, b, c, d) {
    ed(dd, hd.bind(null, a, b, c, d));
  }

  function hd(a, b, c, d) {
    if (fd) {
      var e;
      if ((e = 0 === (b & 4)) && 0 < jc.length && -1 < qc.indexOf(a)) a = rc(null, a, b, c, d), jc.push(a);else {
        var f = yc(a, b, c, d);
        if (null === f) e && sc(a, d);else {
          if (e) {
            if (-1 < qc.indexOf(a)) {
              a = rc(f, a, b, c, d);
              jc.push(a);
              return;
            }

            if (uc(f, a, b, c, d)) return;
            sc(a, d);
          }

          jd(a, b, d, null, c);
        }
      }
    }
  }

  function yc(a, b, c, d) {
    var e = xb(d);
    e = wc(e);

    if (null !== e) {
      var f = Zb(e);
      if (null === f) e = null;else {
        var g = f.tag;

        if (13 === g) {
          e = $b(f);
          if (null !== e) return e;
          e = null;
        } else if (3 === g) {
          if (f.stateNode.hydrate) return 3 === f.tag ? f.stateNode.containerInfo : null;
          e = null;
        } else f !== e && (e = null);
      }
    }

    jd(a, b, d, e, c);
    return null;
  }

  var kd = null,
      ld = null,
      md = null;

  function nd() {
    if (md) return md;
    var a,
        b = ld,
        c = b.length,
        d,
        e = "value" in kd ? kd.value : kd.textContent,
        f = e.length;

    for (a = 0; a < c && b[a] === e[a]; a++);

    var g = c - a;

    for (d = 1; d <= g && b[c - d] === e[f - d]; d++);

    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }

  function od(a) {
    var b = a.keyCode;
    "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
    10 === a && (a = 13);
    return 32 <= a || 13 === a ? a : 0;
  }

  function pd() {
    return !0;
  }

  function qd() {
    return !1;
  }

  function rd(a) {
    function b(b, d, e, f, g) {
      this._reactName = b;
      this._targetInst = e;
      this.type = d;
      this.nativeEvent = f;
      this.target = g;
      this.currentTarget = null;

      for (var c in a) a.hasOwnProperty(c) && (b = a[c], this[c] = b ? b(f) : f[c]);

      this.isDefaultPrevented = (null != f.defaultPrevented ? f.defaultPrevented : !1 === f.returnValue) ? pd : qd;
      this.isPropagationStopped = qd;
      return this;
    }

    m$3(b.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var a = this.nativeEvent;
        a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = pd);
      },
      stopPropagation: function () {
        var a = this.nativeEvent;
        a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = pd);
      },
      persist: function () {},
      isPersistent: pd
    });
    return b;
  }

  var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (a) {
      return a.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  },
      td = rd(sd),
      ud = m$3({}, sd, {
    view: 0,
    detail: 0
  }),
      vd = rd(ud),
      wd,
      xd,
      yd,
      Ad = m$3({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function (a) {
      return void 0 === a.relatedTarget ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
    },
    movementX: function (a) {
      if ("movementX" in a) return a.movementX;
      a !== yd && (yd && "mousemove" === a.type ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a);
      return wd;
    },
    movementY: function (a) {
      return "movementY" in a ? a.movementY : xd;
    }
  }),
      Bd = rd(Ad),
      Cd = m$3({}, Ad, {
    dataTransfer: 0
  }),
      Dd = rd(Cd),
      Ed = m$3({}, ud, {
    relatedTarget: 0
  }),
      Fd = rd(Ed),
      Gd = m$3({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
      Hd = rd(Gd),
      Id = m$3({}, sd, {
    clipboardData: function (a) {
      return "clipboardData" in a ? a.clipboardData : window.clipboardData;
    }
  }),
      Jd = rd(Id),
      Kd = m$3({}, sd, {
    data: 0
  }),
      Ld = rd(Kd),
      Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  },
      Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  },
      Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };

  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
  }

  function zd() {
    return Pd;
  }

  var Qd = m$3({}, ud, {
    key: function (a) {
      if (a.key) {
        var b = Md[a.key] || a.key;
        if ("Unidentified" !== b) return b;
      }

      return "keypress" === a.type ? (a = od(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Nd[a.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function (a) {
      return "keypress" === a.type ? od(a) : 0;
    },
    keyCode: function (a) {
      return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    },
    which: function (a) {
      return "keypress" === a.type ? od(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
    }
  }),
      Rd = rd(Qd),
      Sd = m$3({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }),
      Td = rd(Sd),
      Ud = m$3({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
  }),
      Vd = rd(Ud),
      Wd = m$3({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }),
      Xd = rd(Wd),
      Yd = m$3({}, Ad, {
    deltaX: function (a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function (a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }),
      Zd = rd(Yd),
      $d = [9, 13, 27, 32],
      ae = fa && "CompositionEvent" in window,
      be = null;
  fa && "documentMode" in document && (be = document.documentMode);
  var ce = fa && "TextEvent" in window && !be,
      de = fa && (!ae || be && 8 < be && 11 >= be),
      ee = String.fromCharCode(32),
      fe = !1;

  function ge(a, b) {
    switch (a) {
      case "keyup":
        return -1 !== $d.indexOf(b.keyCode);

      case "keydown":
        return 229 !== b.keyCode;

      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;

      default:
        return !1;
    }
  }

  function he(a) {
    a = a.detail;
    return "object" === typeof a && "data" in a ? a.data : null;
  }

  var ie = !1;

  function je(a, b) {
    switch (a) {
      case "compositionend":
        return he(b);

      case "keypress":
        if (32 !== b.which) return null;
        fe = !0;
        return ee;

      case "textInput":
        return a = b.data, a === ee && fe ? null : a;

      default:
        return null;
    }
  }

  function ke(a, b) {
    if (ie) return "compositionend" === a || !ae && ge(a, b) ? (a = nd(), md = ld = kd = null, ie = !1, a) : null;

    switch (a) {
      case "paste":
        return null;

      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }

        return null;

      case "compositionend":
        return de && "ko" !== b.locale ? null : b.data;

      default:
        return null;
    }
  }

  var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
  };

  function me(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return "input" === b ? !!le[a.type] : "textarea" === b ? !0 : !1;
  }

  function ne(a, b, c, d) {
    Eb(d);
    b = oe(b, "onChange");
    0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({
      event: c,
      listeners: b
    }));
  }

  var pe = null,
      qe = null;

  function re(a) {
    se(a, 0);
  }

  function te(a) {
    var b = ue(a);
    if (Wa(b)) return a;
  }

  function ve(a, b) {
    if ("change" === a) return b;
  }

  var we = !1;

  if (fa) {
    var xe;

    if (fa) {
      var ye = ("oninput" in document);

      if (!ye) {
        var ze = document.createElement("div");
        ze.setAttribute("oninput", "return;");
        ye = "function" === typeof ze.oninput;
      }

      xe = ye;
    } else xe = !1;

    we = xe && (!document.documentMode || 9 < document.documentMode);
  }

  function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
  }

  function Be(a) {
    if ("value" === a.propertyName && te(qe)) {
      var b = [];
      ne(b, qe, a, xb(a));
      a = re;
      if (Kb) a(b);else {
        Kb = !0;

        try {
          Gb(a, b);
        } finally {
          Kb = !1, Mb();
        }
      }
    }
  }

  function Ce(a, b, c) {
    "focusin" === a ? (Ae(), pe = b, qe = c, pe.attachEvent("onpropertychange", Be)) : "focusout" === a && Ae();
  }

  function De(a) {
    if ("selectionchange" === a || "keyup" === a || "keydown" === a) return te(qe);
  }

  function Ee(a, b) {
    if ("click" === a) return te(b);
  }

  function Fe(a, b) {
    if ("input" === a || "change" === a) return te(b);
  }

  function Ge(a, b) {
    return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;
  }

  var He = "function" === typeof Object.is ? Object.is : Ge,
      Ie = Object.prototype.hasOwnProperty;

  function Je(a, b) {
    if (He(a, b)) return !0;
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b) return !1;
    var c = Object.keys(a),
        d = Object.keys(b);
    if (c.length !== d.length) return !1;

    for (d = 0; d < c.length; d++) if (!Ie.call(b, c[d]) || !He(a[c[d]], b[c[d]])) return !1;

    return !0;
  }

  function Ke(a) {
    for (; a && a.firstChild;) a = a.firstChild;

    return a;
  }

  function Le(a, b) {
    var c = Ke(a);
    a = 0;

    for (var d; c;) {
      if (3 === c.nodeType) {
        d = a + c.textContent.length;
        if (a <= b && d >= b) return {
          node: c,
          offset: b - a
        };
        a = d;
      }

      a: {
        for (; c;) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }

          c = c.parentNode;
        }

        c = void 0;
      }

      c = Ke(c);
    }
  }

  function Me(a, b) {
    return a && b ? a === b ? !0 : a && 3 === a.nodeType ? !1 : b && 3 === b.nodeType ? Me(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
  }

  function Ne() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement;) {
      try {
        var c = "string" === typeof b.contentWindow.location.href;
      } catch (d) {
        c = !1;
      }

      if (c) a = b.contentWindow;else break;
      b = Xa(a.document);
    }

    return b;
  }

  function Oe(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && ("input" === b && ("text" === a.type || "search" === a.type || "tel" === a.type || "url" === a.type || "password" === a.type) || "textarea" === b || "true" === a.contentEditable);
  }

  var Pe = fa && "documentMode" in document && 11 >= document.documentMode,
      Qe = null,
      Re = null,
      Se = null,
      Te = !1;

  function Ue(a, b, c) {
    var d = c.window === c ? c.document : 9 === c.nodeType ? c : c.ownerDocument;
    Te || null == Qe || Qe !== Xa(d) || (d = Qe, "selectionStart" in d && Oe(d) ? d = {
      start: d.selectionStart,
      end: d.selectionEnd
    } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = {
      anchorNode: d.anchorNode,
      anchorOffset: d.anchorOffset,
      focusNode: d.focusNode,
      focusOffset: d.focusOffset
    }), Se && Je(Se, d) || (Se = d, d = oe(Re, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({
      event: b,
      listeners: d
    }), b.target = Qe)));
  }

  Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "), 0);
  Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "), 1);
  Pc(Oc, 2);

  for (var Ve = "change selectionchange textInput compositionstart compositionend compositionupdate".split(" "), We = 0; We < Ve.length; We++) Nc.set(Ve[We], 0);

  ea("onMouseEnter", ["mouseout", "mouseover"]);
  ea("onMouseLeave", ["mouseout", "mouseover"]);
  ea("onPointerEnter", ["pointerout", "pointerover"]);
  ea("onPointerLeave", ["pointerout", "pointerover"]);
  da("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
  da("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
  da("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
  da("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
  da("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
  da("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var Xe = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
      Ye = new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));

  function Ze(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c;
    Yb(d, b, void 0, a);
    a.currentTarget = null;
  }

  function se(a, b) {
    b = 0 !== (b & 4);

    for (var c = 0; c < a.length; c++) {
      var d = a[c],
          e = d.event;
      d = d.listeners;

      a: {
        var f = void 0;
        if (b) for (var g = d.length - 1; 0 <= g; g--) {
          var h = d[g],
              k = h.instance,
              l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          Ze(e, h, l);
          f = k;
        } else for (g = 0; g < d.length; g++) {
          h = d[g];
          k = h.instance;
          l = h.currentTarget;
          h = h.listener;
          if (k !== f && e.isPropagationStopped()) break a;
          Ze(e, h, l);
          f = k;
        }
      }
    }

    if (Ub) throw a = Vb, Ub = !1, Vb = null, a;
  }

  function G$2(a, b) {
    var c = $e(b),
        d = a + "__bubble";
    c.has(d) || (af(b, a, 2, !1), c.add(d));
  }

  var bf = "_reactListening" + Math.random().toString(36).slice(2);

  function cf(a) {
    a[bf] || (a[bf] = !0, ba.forEach(function (b) {
      Ye.has(b) || df(b, !1, a, null);
      df(b, !0, a, null);
    }));
  }

  function df(a, b, c, d) {
    var e = 4 < arguments.length && void 0 !== arguments[4] ? arguments[4] : 0,
        f = c;
    "selectionchange" === a && 9 !== c.nodeType && (f = c.ownerDocument);

    if (null !== d && !b && Ye.has(a)) {
      if ("scroll" !== a) return;
      e |= 2;
      f = d;
    }

    var g = $e(f),
        h = a + "__" + (b ? "capture" : "bubble");
    g.has(h) || (b && (e |= 4), af(f, a, e, b), g.add(h));
  }

  function af(a, b, c, d) {
    var e = Nc.get(b);

    switch (void 0 === e ? 2 : e) {
      case 0:
        e = gd;
        break;

      case 1:
        e = id;
        break;

      default:
        e = hd;
    }

    c = e.bind(null, b, c, a);
    e = void 0;
    !Pb || "touchstart" !== b && "touchmove" !== b && "wheel" !== b || (e = !0);
    d ? void 0 !== e ? a.addEventListener(b, c, {
      capture: !0,
      passive: e
    }) : a.addEventListener(b, c, !0) : void 0 !== e ? a.addEventListener(b, c, {
      passive: e
    }) : a.addEventListener(b, c, !1);
  }

  function jd(a, b, c, d, e) {
    var f = d;
    if (0 === (b & 1) && 0 === (b & 2) && null !== d) a: for (;;) {
      if (null === d) return;
      var g = d.tag;

      if (3 === g || 4 === g) {
        var h = d.stateNode.containerInfo;
        if (h === e || 8 === h.nodeType && h.parentNode === e) break;
        if (4 === g) for (g = d.return; null !== g;) {
          var k = g.tag;
          if (3 === k || 4 === k) if (k = g.stateNode.containerInfo, k === e || 8 === k.nodeType && k.parentNode === e) return;
          g = g.return;
        }

        for (; null !== h;) {
          g = wc(h);
          if (null === g) return;
          k = g.tag;

          if (5 === k || 6 === k) {
            d = f = g;
            continue a;
          }

          h = h.parentNode;
        }
      }

      d = d.return;
    }
    Nb(function () {
      var d = f,
          e = xb(c),
          g = [];

      a: {
        var h = Mc.get(a);

        if (void 0 !== h) {
          var k = td,
              x = a;

          switch (a) {
            case "keypress":
              if (0 === od(c)) break a;

            case "keydown":
            case "keyup":
              k = Rd;
              break;

            case "focusin":
              x = "focus";
              k = Fd;
              break;

            case "focusout":
              x = "blur";
              k = Fd;
              break;

            case "beforeblur":
            case "afterblur":
              k = Fd;
              break;

            case "click":
              if (2 === c.button) break a;

            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k = Bd;
              break;

            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k = Dd;
              break;

            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k = Vd;
              break;

            case Ic:
            case Jc:
            case Kc:
              k = Hd;
              break;

            case Lc:
              k = Xd;
              break;

            case "scroll":
              k = vd;
              break;

            case "wheel":
              k = Zd;
              break;

            case "copy":
            case "cut":
            case "paste":
              k = Jd;
              break;

            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k = Td;
          }

          var w = 0 !== (b & 4),
              z = !w && "scroll" === a,
              u = w ? null !== h ? h + "Capture" : null : h;
          w = [];

          for (var t = d, q; null !== t;) {
            q = t;
            var v = q.stateNode;
            5 === q.tag && null !== v && (q = v, null !== u && (v = Ob(t, u), null != v && w.push(ef(t, v, q))));
            if (z) break;
            t = t.return;
          }

          0 < w.length && (h = new k(h, x, null, c, e), g.push({
            event: h,
            listeners: w
          }));
        }
      }

      if (0 === (b & 7)) {
        a: {
          h = "mouseover" === a || "pointerover" === a;
          k = "mouseout" === a || "pointerout" === a;
          if (h && 0 === (b & 16) && (x = c.relatedTarget || c.fromElement) && (wc(x) || x[ff])) break a;

          if (k || h) {
            h = e.window === e ? e : (h = e.ownerDocument) ? h.defaultView || h.parentWindow : window;

            if (k) {
              if (x = c.relatedTarget || c.toElement, k = d, x = x ? wc(x) : null, null !== x && (z = Zb(x), x !== z || 5 !== x.tag && 6 !== x.tag)) x = null;
            } else k = null, x = d;

            if (k !== x) {
              w = Bd;
              v = "onMouseLeave";
              u = "onMouseEnter";
              t = "mouse";
              if ("pointerout" === a || "pointerover" === a) w = Td, v = "onPointerLeave", u = "onPointerEnter", t = "pointer";
              z = null == k ? h : ue(k);
              q = null == x ? h : ue(x);
              h = new w(v, t + "leave", k, c, e);
              h.target = z;
              h.relatedTarget = q;
              v = null;
              wc(e) === d && (w = new w(u, t + "enter", x, c, e), w.target = q, w.relatedTarget = z, v = w);
              z = v;
              if (k && x) b: {
                w = k;
                u = x;
                t = 0;

                for (q = w; q; q = gf(q)) t++;

                q = 0;

                for (v = u; v; v = gf(v)) q++;

                for (; 0 < t - q;) w = gf(w), t--;

                for (; 0 < q - t;) u = gf(u), q--;

                for (; t--;) {
                  if (w === u || null !== u && w === u.alternate) break b;
                  w = gf(w);
                  u = gf(u);
                }

                w = null;
              } else w = null;
              null !== k && hf(g, h, k, w, !1);
              null !== x && null !== z && hf(g, z, x, w, !0);
            }
          }
        }

        a: {
          h = d ? ue(d) : window;
          k = h.nodeName && h.nodeName.toLowerCase();
          if ("select" === k || "input" === k && "file" === h.type) var J = ve;else if (me(h)) {
            if (we) J = Fe;else {
              J = De;
              var K = Ce;
            }
          } else (k = h.nodeName) && "input" === k.toLowerCase() && ("checkbox" === h.type || "radio" === h.type) && (J = Ee);

          if (J && (J = J(a, d))) {
            ne(g, J, c, e);
            break a;
          }

          K && K(a, h, d);
          "focusout" === a && (K = h._wrapperState) && K.controlled && "number" === h.type && bb(h, "number", h.value);
        }

        K = d ? ue(d) : window;

        switch (a) {
          case "focusin":
            if (me(K) || "true" === K.contentEditable) Qe = K, Re = d, Se = null;
            break;

          case "focusout":
            Se = Re = Qe = null;
            break;

          case "mousedown":
            Te = !0;
            break;

          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te = !1;
            Ue(g, c, e);
            break;

          case "selectionchange":
            if (Pe) break;

          case "keydown":
          case "keyup":
            Ue(g, c, e);
        }

        var Q;
        if (ae) b: {
          switch (a) {
            case "compositionstart":
              var L = "onCompositionStart";
              break b;

            case "compositionend":
              L = "onCompositionEnd";
              break b;

            case "compositionupdate":
              L = "onCompositionUpdate";
              break b;
          }

          L = void 0;
        } else ie ? ge(a, c) && (L = "onCompositionEnd") : "keydown" === a && 229 === c.keyCode && (L = "onCompositionStart");
        L && (de && "ko" !== c.locale && (ie || "onCompositionStart" !== L ? "onCompositionEnd" === L && ie && (Q = nd()) : (kd = e, ld = "value" in kd ? kd.value : kd.textContent, ie = !0)), K = oe(d, L), 0 < K.length && (L = new Ld(L, a, null, c, e), g.push({
          event: L,
          listeners: K
        }), Q ? L.data = Q : (Q = he(c), null !== Q && (L.data = Q))));
        if (Q = ce ? je(a, c) : ke(a, c)) d = oe(d, "onBeforeInput"), 0 < d.length && (e = new Ld("onBeforeInput", "beforeinput", null, c, e), g.push({
          event: e,
          listeners: d
        }), e.data = Q);
      }

      se(g, b);
    });
  }

  function ef(a, b, c) {
    return {
      instance: a,
      listener: b,
      currentTarget: c
    };
  }

  function oe(a, b) {
    for (var c = b + "Capture", d = []; null !== a;) {
      var e = a,
          f = e.stateNode;
      5 === e.tag && null !== f && (e = f, f = Ob(a, c), null != f && d.unshift(ef(a, f, e)), f = Ob(a, b), null != f && d.push(ef(a, f, e)));
      a = a.return;
    }

    return d;
  }

  function gf(a) {
    if (null === a) return null;

    do a = a.return; while (a && 5 !== a.tag);

    return a ? a : null;
  }

  function hf(a, b, c, d, e) {
    for (var f = b._reactName, g = []; null !== c && c !== d;) {
      var h = c,
          k = h.alternate,
          l = h.stateNode;
      if (null !== k && k === d) break;
      5 === h.tag && null !== l && (h = l, e ? (k = Ob(c, f), null != k && g.unshift(ef(c, k, h))) : e || (k = Ob(c, f), null != k && g.push(ef(c, k, h))));
      c = c.return;
    }

    0 !== g.length && a.push({
      event: b,
      listeners: g
    });
  }

  function jf() {}

  var kf = null,
      lf = null;

  function mf(a, b) {
    switch (a) {
      case "button":
      case "input":
      case "select":
      case "textarea":
        return !!b.autoFocus;
    }

    return !1;
  }

  function nf(a, b) {
    return "textarea" === a || "option" === a || "noscript" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && null != b.dangerouslySetInnerHTML.__html;
  }

  var of$1 = "function" === typeof setTimeout ? setTimeout : void 0,
      pf = "function" === typeof clearTimeout ? clearTimeout : void 0;

  function qf(a) {
    1 === a.nodeType ? a.textContent = "" : 9 === a.nodeType && (a = a.body, null != a && (a.textContent = ""));
  }

  function rf(a) {
    for (; null != a; a = a.nextSibling) {
      var b = a.nodeType;
      if (1 === b || 3 === b) break;
    }

    return a;
  }

  function sf(a) {
    a = a.previousSibling;

    for (var b = 0; a;) {
      if (8 === a.nodeType) {
        var c = a.data;

        if ("$" === c || "$!" === c || "$?" === c) {
          if (0 === b) return a;
          b--;
        } else "/$" === c && b++;
      }

      a = a.previousSibling;
    }

    return null;
  }

  var tf = 0;

  function uf(a) {
    return {
      $$typeof: Ga,
      toString: a,
      valueOf: a
    };
  }

  var vf = Math.random().toString(36).slice(2),
      wf = "__reactFiber$" + vf,
      xf = "__reactProps$" + vf,
      ff = "__reactContainer$" + vf,
      yf = "__reactEvents$" + vf;

  function wc(a) {
    var b = a[wf];
    if (b) return b;

    for (var c = a.parentNode; c;) {
      if (b = c[ff] || c[wf]) {
        c = b.alternate;
        if (null !== b.child || null !== c && null !== c.child) for (a = sf(a); null !== a;) {
          if (c = a[wf]) return c;
          a = sf(a);
        }
        return b;
      }

      a = c;
      c = a.parentNode;
    }

    return null;
  }

  function Cb(a) {
    a = a[wf] || a[ff];
    return !a || 5 !== a.tag && 6 !== a.tag && 13 !== a.tag && 3 !== a.tag ? null : a;
  }

  function ue(a) {
    if (5 === a.tag || 6 === a.tag) return a.stateNode;
    throw Error(y$2(33));
  }

  function Db(a) {
    return a[xf] || null;
  }

  function $e(a) {
    var b = a[yf];
    void 0 === b && (b = a[yf] = new Set());
    return b;
  }

  var zf = [],
      Af = -1;

  function Bf(a) {
    return {
      current: a
    };
  }

  function H$2(a) {
    0 > Af || (a.current = zf[Af], zf[Af] = null, Af--);
  }

  function I$2(a, b) {
    Af++;
    zf[Af] = a.current;
    a.current = b;
  }

  var Cf = {},
      M$1 = Bf(Cf),
      N$1 = Bf(!1),
      Df = Cf;

  function Ef(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Cf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {},
        f;

    for (f in c) e[f] = b[f];

    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
    return e;
  }

  function Ff(a) {
    a = a.childContextTypes;
    return null !== a && void 0 !== a;
  }

  function Gf() {
    H$2(N$1);
    H$2(M$1);
  }

  function Hf(a, b, c) {
    if (M$1.current !== Cf) throw Error(y$2(168));
    I$2(M$1, b);
    I$2(N$1, c);
  }

  function If(a, b, c) {
    var d = a.stateNode;
    a = b.childContextTypes;
    if ("function" !== typeof d.getChildContext) return c;
    d = d.getChildContext();

    for (var e in d) if (!(e in a)) throw Error(y$2(108, Ra(b) || "Unknown", e));

    return m$3({}, c, d);
  }

  function Jf(a) {
    a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Cf;
    Df = M$1.current;
    I$2(M$1, a);
    I$2(N$1, N$1.current);
    return !0;
  }

  function Kf(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(y$2(169));
    c ? (a = If(a, b, Df), d.__reactInternalMemoizedMergedChildContext = a, H$2(N$1), H$2(M$1), I$2(M$1, a)) : H$2(N$1);
    I$2(N$1, c);
  }

  var Lf = null,
      Mf = null,
      Nf = r$2.unstable_runWithPriority,
      Of = r$2.unstable_scheduleCallback,
      Pf = r$2.unstable_cancelCallback,
      Qf = r$2.unstable_shouldYield,
      Rf = r$2.unstable_requestPaint,
      Sf = r$2.unstable_now,
      Tf = r$2.unstable_getCurrentPriorityLevel,
      Uf = r$2.unstable_ImmediatePriority,
      Vf = r$2.unstable_UserBlockingPriority,
      Wf = r$2.unstable_NormalPriority,
      Xf = r$2.unstable_LowPriority,
      Yf = r$2.unstable_IdlePriority,
      Zf = {},
      $f = void 0 !== Rf ? Rf : function () {},
      ag = null,
      bg = null,
      cg = !1,
      dg = Sf(),
      O$1 = 1E4 > dg ? Sf : function () {
    return Sf() - dg;
  };

  function eg() {
    switch (Tf()) {
      case Uf:
        return 99;

      case Vf:
        return 98;

      case Wf:
        return 97;

      case Xf:
        return 96;

      case Yf:
        return 95;

      default:
        throw Error(y$2(332));
    }
  }

  function fg(a) {
    switch (a) {
      case 99:
        return Uf;

      case 98:
        return Vf;

      case 97:
        return Wf;

      case 96:
        return Xf;

      case 95:
        return Yf;

      default:
        throw Error(y$2(332));
    }
  }

  function gg(a, b) {
    a = fg(a);
    return Nf(a, b);
  }

  function hg(a, b, c) {
    a = fg(a);
    return Of(a, b, c);
  }

  function ig() {
    if (null !== bg) {
      var a = bg;
      bg = null;
      Pf(a);
    }

    jg();
  }

  function jg() {
    if (!cg && null !== ag) {
      cg = !0;
      var a = 0;

      try {
        var b = ag;
        gg(99, function () {
          for (; a < b.length; a++) {
            var c = b[a];

            do c = c(!0); while (null !== c);
          }
        });
        ag = null;
      } catch (c) {
        throw null !== ag && (ag = ag.slice(a + 1)), Of(Uf, ig), c;
      } finally {
        cg = !1;
      }
    }
  }

  var kg = ra.ReactCurrentBatchConfig;

  function lg(a, b) {
    if (a && a.defaultProps) {
      b = m$3({}, b);
      a = a.defaultProps;

      for (var c in a) void 0 === b[c] && (b[c] = a[c]);

      return b;
    }

    return b;
  }

  var mg = Bf(null),
      ng = null,
      og = null,
      pg = null;

  function qg() {
    pg = og = ng = null;
  }

  function rg(a) {
    var b = mg.current;
    H$2(mg);
    a.type._context._currentValue = b;
  }

  function sg(a, b) {
    for (; null !== a;) {
      var c = a.alternate;
      if ((a.childLanes & b) === b) {
        if (null === c || (c.childLanes & b) === b) break;else c.childLanes |= b;
      } else a.childLanes |= b, null !== c && (c.childLanes |= b);
      a = a.return;
    }
  }

  function tg(a, b) {
    ng = a;
    pg = og = null;
    a = a.dependencies;
    null !== a && null !== a.firstContext && (0 !== (a.lanes & b) && (ug = !0), a.firstContext = null);
  }

  function vg(a, b) {
    if (pg !== a && !1 !== b && 0 !== b) {
      if ("number" !== typeof b || 1073741823 === b) pg = a, b = 1073741823;
      b = {
        context: a,
        observedBits: b,
        next: null
      };

      if (null === og) {
        if (null === ng) throw Error(y$2(308));
        og = b;
        ng.dependencies = {
          lanes: 0,
          firstContext: b,
          responders: null
        };
      } else og = og.next = b;
    }

    return a._currentValue;
  }

  var wg = !1;

  function xg(a) {
    a.updateQueue = {
      baseState: a.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: {
        pending: null
      },
      effects: null
    };
  }

  function yg(a, b) {
    a = a.updateQueue;
    b.updateQueue === a && (b.updateQueue = {
      baseState: a.baseState,
      firstBaseUpdate: a.firstBaseUpdate,
      lastBaseUpdate: a.lastBaseUpdate,
      shared: a.shared,
      effects: a.effects
    });
  }

  function zg(a, b) {
    return {
      eventTime: a,
      lane: b,
      tag: 0,
      payload: null,
      callback: null,
      next: null
    };
  }

  function Ag(a, b) {
    a = a.updateQueue;

    if (null !== a) {
      a = a.shared;
      var c = a.pending;
      null === c ? b.next = b : (b.next = c.next, c.next = b);
      a.pending = b;
    }
  }

  function Bg(a, b) {
    var c = a.updateQueue,
        d = a.alternate;

    if (null !== d && (d = d.updateQueue, c === d)) {
      var e = null,
          f = null;
      c = c.firstBaseUpdate;

      if (null !== c) {
        do {
          var g = {
            eventTime: c.eventTime,
            lane: c.lane,
            tag: c.tag,
            payload: c.payload,
            callback: c.callback,
            next: null
          };
          null === f ? e = f = g : f = f.next = g;
          c = c.next;
        } while (null !== c);

        null === f ? e = f = b : f = f.next = b;
      } else e = f = b;

      c = {
        baseState: d.baseState,
        firstBaseUpdate: e,
        lastBaseUpdate: f,
        shared: d.shared,
        effects: d.effects
      };
      a.updateQueue = c;
      return;
    }

    a = c.lastBaseUpdate;
    null === a ? c.firstBaseUpdate = b : a.next = b;
    c.lastBaseUpdate = b;
  }

  function Cg(a, b, c, d) {
    var e = a.updateQueue;
    wg = !1;
    var f = e.firstBaseUpdate,
        g = e.lastBaseUpdate,
        h = e.shared.pending;

    if (null !== h) {
      e.shared.pending = null;
      var k = h,
          l = k.next;
      k.next = null;
      null === g ? f = l : g.next = l;
      g = k;
      var n = a.alternate;

      if (null !== n) {
        n = n.updateQueue;
        var A = n.lastBaseUpdate;
        A !== g && (null === A ? n.firstBaseUpdate = l : A.next = l, n.lastBaseUpdate = k);
      }
    }

    if (null !== f) {
      A = e.baseState;
      g = 0;
      n = l = k = null;

      do {
        h = f.lane;
        var p = f.eventTime;

        if ((d & h) === h) {
          null !== n && (n = n.next = {
            eventTime: p,
            lane: 0,
            tag: f.tag,
            payload: f.payload,
            callback: f.callback,
            next: null
          });

          a: {
            var C = a,
                x = f;
            h = b;
            p = c;

            switch (x.tag) {
              case 1:
                C = x.payload;

                if ("function" === typeof C) {
                  A = C.call(p, A, h);
                  break a;
                }

                A = C;
                break a;

              case 3:
                C.flags = C.flags & -4097 | 64;

              case 0:
                C = x.payload;
                h = "function" === typeof C ? C.call(p, A, h) : C;
                if (null === h || void 0 === h) break a;
                A = m$3({}, A, h);
                break a;

              case 2:
                wg = !0;
            }
          }

          null !== f.callback && (a.flags |= 32, h = e.effects, null === h ? e.effects = [f] : h.push(f));
        } else p = {
          eventTime: p,
          lane: h,
          tag: f.tag,
          payload: f.payload,
          callback: f.callback,
          next: null
        }, null === n ? (l = n = p, k = A) : n = n.next = p, g |= h;

        f = f.next;
        if (null === f) if (h = e.shared.pending, null === h) break;else f = h.next, h.next = null, e.lastBaseUpdate = h, e.shared.pending = null;
      } while (1);

      null === n && (k = A);
      e.baseState = k;
      e.firstBaseUpdate = l;
      e.lastBaseUpdate = n;
      Dg |= g;
      a.lanes = g;
      a.memoizedState = A;
    }
  }

  function Eg(a, b, c) {
    a = b.effects;
    b.effects = null;
    if (null !== a) for (b = 0; b < a.length; b++) {
      var d = a[b],
          e = d.callback;

      if (null !== e) {
        d.callback = null;
        d = c;
        if ("function" !== typeof e) throw Error(y$2(191, e));
        e.call(d);
      }
    }
  }

  var Fg = new aa.Component().refs;

  function Gg(a, b, c, d) {
    b = a.memoizedState;
    c = c(d, b);
    c = null === c || void 0 === c ? b : m$3({}, b, c);
    a.memoizedState = c;
    0 === a.lanes && (a.updateQueue.baseState = c);
  }

  var Kg = {
    isMounted: function (a) {
      return (a = a._reactInternals) ? Zb(a) === a : !1;
    },
    enqueueSetState: function (a, b, c) {
      a = a._reactInternals;
      var d = Hg(),
          e = Ig(a),
          f = zg(d, e);
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      Ag(a, f);
      Jg(a, e, d);
    },
    enqueueReplaceState: function (a, b, c) {
      a = a._reactInternals;
      var d = Hg(),
          e = Ig(a),
          f = zg(d, e);
      f.tag = 1;
      f.payload = b;
      void 0 !== c && null !== c && (f.callback = c);
      Ag(a, f);
      Jg(a, e, d);
    },
    enqueueForceUpdate: function (a, b) {
      a = a._reactInternals;
      var c = Hg(),
          d = Ig(a),
          e = zg(c, d);
      e.tag = 2;
      void 0 !== b && null !== b && (e.callback = b);
      Ag(a, e);
      Jg(a, d, c);
    }
  };

  function Lg(a, b, c, d, e, f, g) {
    a = a.stateNode;
    return "function" === typeof a.shouldComponentUpdate ? a.shouldComponentUpdate(d, f, g) : b.prototype && b.prototype.isPureReactComponent ? !Je(c, d) || !Je(e, f) : !0;
  }

  function Mg(a, b, c) {
    var d = !1,
        e = Cf;
    var f = b.contextType;
    "object" === typeof f && null !== f ? f = vg(f) : (e = Ff(b) ? Df : M$1.current, d = b.contextTypes, f = (d = null !== d && void 0 !== d) ? Ef(a, e) : Cf);
    b = new b(c, f);
    a.memoizedState = null !== b.state && void 0 !== b.state ? b.state : null;
    b.updater = Kg;
    a.stateNode = b;
    b._reactInternals = a;
    d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f);
    return b;
  }

  function Ng(a, b, c, d) {
    a = b.state;
    "function" === typeof b.componentWillReceiveProps && b.componentWillReceiveProps(c, d);
    "function" === typeof b.UNSAFE_componentWillReceiveProps && b.UNSAFE_componentWillReceiveProps(c, d);
    b.state !== a && Kg.enqueueReplaceState(b, b.state, null);
  }

  function Og(a, b, c, d) {
    var e = a.stateNode;
    e.props = c;
    e.state = a.memoizedState;
    e.refs = Fg;
    xg(a);
    var f = b.contextType;
    "object" === typeof f && null !== f ? e.context = vg(f) : (f = Ff(b) ? Df : M$1.current, e.context = Ef(a, f));
    Cg(a, c, e, d);
    e.state = a.memoizedState;
    f = b.getDerivedStateFromProps;
    "function" === typeof f && (Gg(a, b, f, c), e.state = a.memoizedState);
    "function" === typeof b.getDerivedStateFromProps || "function" === typeof e.getSnapshotBeforeUpdate || "function" !== typeof e.UNSAFE_componentWillMount && "function" !== typeof e.componentWillMount || (b = e.state, "function" === typeof e.componentWillMount && e.componentWillMount(), "function" === typeof e.UNSAFE_componentWillMount && e.UNSAFE_componentWillMount(), b !== e.state && Kg.enqueueReplaceState(e, e.state, null), Cg(a, c, e, d), e.state = a.memoizedState);
    "function" === typeof e.componentDidMount && (a.flags |= 4);
  }

  var Pg = Array.isArray;

  function Qg(a, b, c) {
    a = c.ref;

    if (null !== a && "function" !== typeof a && "object" !== typeof a) {
      if (c._owner) {
        c = c._owner;

        if (c) {
          if (1 !== c.tag) throw Error(y$2(309));
          var d = c.stateNode;
        }

        if (!d) throw Error(y$2(147, a));
        var e = "" + a;
        if (null !== b && null !== b.ref && "function" === typeof b.ref && b.ref._stringRef === e) return b.ref;

        b = function (a) {
          var b = d.refs;
          b === Fg && (b = d.refs = {});
          null === a ? delete b[e] : b[e] = a;
        };

        b._stringRef = e;
        return b;
      }

      if ("string" !== typeof a) throw Error(y$2(284));
      if (!c._owner) throw Error(y$2(290, a));
    }

    return a;
  }

  function Rg(a, b) {
    if ("textarea" !== a.type) throw Error(y$2(31, "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b));
  }

  function Sg(a) {
    function b(b, c) {
      if (a) {
        var d = b.lastEffect;
        null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
        c.nextEffect = null;
        c.flags = 8;
      }
    }

    function c(c, d) {
      if (!a) return null;

      for (; null !== d;) b(c, d), d = d.sibling;

      return null;
    }

    function d(a, b) {
      for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;

      return a;
    }

    function e(a, b) {
      a = Tg(a, b);
      a.index = 0;
      a.sibling = null;
      return a;
    }

    function f(b, c, d) {
      b.index = d;
      if (!a) return c;
      d = b.alternate;
      if (null !== d) return d = d.index, d < c ? (b.flags = 2, c) : d;
      b.flags = 2;
      return c;
    }

    function g(b) {
      a && null === b.alternate && (b.flags = 2);
      return b;
    }

    function h(a, b, c, d) {
      if (null === b || 6 !== b.tag) return b = Ug(c, a.mode, d), b.return = a, b;
      b = e(b, c);
      b.return = a;
      return b;
    }

    function k(a, b, c, d) {
      if (null !== b && b.elementType === c.type) return d = e(b, c.props), d.ref = Qg(a, b, c), d.return = a, d;
      d = Vg(c.type, c.key, c.props, null, a.mode, d);
      d.ref = Qg(a, b, c);
      d.return = a;
      return d;
    }

    function l(a, b, c, d) {
      if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = Wg(c, a.mode, d), b.return = a, b;
      b = e(b, c.children || []);
      b.return = a;
      return b;
    }

    function n(a, b, c, d, f) {
      if (null === b || 7 !== b.tag) return b = Xg(c, a.mode, d, f), b.return = a, b;
      b = e(b, c);
      b.return = a;
      return b;
    }

    function A(a, b, c) {
      if ("string" === typeof b || "number" === typeof b) return b = Ug("" + b, a.mode, c), b.return = a, b;

      if ("object" === typeof b && null !== b) {
        switch (b.$$typeof) {
          case sa:
            return c = Vg(b.type, b.key, b.props, null, a.mode, c), c.ref = Qg(a, null, b), c.return = a, c;

          case ta:
            return b = Wg(b, a.mode, c), b.return = a, b;
        }

        if (Pg(b) || La(b)) return b = Xg(b, a.mode, c, null), b.return = a, b;
        Rg(a, b);
      }

      return null;
    }

    function p(a, b, c, d) {
      var e = null !== b ? b.key : null;
      if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);

      if ("object" === typeof c && null !== c) {
        switch (c.$$typeof) {
          case sa:
            return c.key === e ? c.type === ua ? n(a, b, c.props.children, d, e) : k(a, b, c, d) : null;

          case ta:
            return c.key === e ? l(a, b, c, d) : null;
        }

        if (Pg(c) || La(c)) return null !== e ? null : n(a, b, c, d, null);
        Rg(a, c);
      }

      return null;
    }

    function C(a, b, c, d, e) {
      if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);

      if ("object" === typeof d && null !== d) {
        switch (d.$$typeof) {
          case sa:
            return a = a.get(null === d.key ? c : d.key) || null, d.type === ua ? n(b, a, d.props.children, e, d.key) : k(b, a, d, e);

          case ta:
            return a = a.get(null === d.key ? c : d.key) || null, l(b, a, d, e);
        }

        if (Pg(d) || La(d)) return a = a.get(c) || null, n(b, a, d, e, null);
        Rg(b, d);
      }

      return null;
    }

    function x(e, g, h, k) {
      for (var l = null, t = null, u = g, z = g = 0, q = null; null !== u && z < h.length; z++) {
        u.index > z ? (q = u, u = null) : q = u.sibling;
        var n = p(e, u, h[z], k);

        if (null === n) {
          null === u && (u = q);
          break;
        }

        a && u && null === n.alternate && b(e, u);
        g = f(n, g, z);
        null === t ? l = n : t.sibling = n;
        t = n;
        u = q;
      }

      if (z === h.length) return c(e, u), l;

      if (null === u) {
        for (; z < h.length; z++) u = A(e, h[z], k), null !== u && (g = f(u, g, z), null === t ? l = u : t.sibling = u, t = u);

        return l;
      }

      for (u = d(e, u); z < h.length; z++) q = C(u, e, z, h[z], k), null !== q && (a && null !== q.alternate && u.delete(null === q.key ? z : q.key), g = f(q, g, z), null === t ? l = q : t.sibling = q, t = q);

      a && u.forEach(function (a) {
        return b(e, a);
      });
      return l;
    }

    function w(e, g, h, k) {
      var l = La(h);
      if ("function" !== typeof l) throw Error(y$2(150));
      h = l.call(h);
      if (null == h) throw Error(y$2(151));

      for (var t = l = null, u = g, z = g = 0, q = null, n = h.next(); null !== u && !n.done; z++, n = h.next()) {
        u.index > z ? (q = u, u = null) : q = u.sibling;
        var w = p(e, u, n.value, k);

        if (null === w) {
          null === u && (u = q);
          break;
        }

        a && u && null === w.alternate && b(e, u);
        g = f(w, g, z);
        null === t ? l = w : t.sibling = w;
        t = w;
        u = q;
      }

      if (n.done) return c(e, u), l;

      if (null === u) {
        for (; !n.done; z++, n = h.next()) n = A(e, n.value, k), null !== n && (g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);

        return l;
      }

      for (u = d(e, u); !n.done; z++, n = h.next()) n = C(u, e, z, n.value, k), null !== n && (a && null !== n.alternate && u.delete(null === n.key ? z : n.key), g = f(n, g, z), null === t ? l = n : t.sibling = n, t = n);

      a && u.forEach(function (a) {
        return b(e, a);
      });
      return l;
    }

    return function (a, d, f, h) {
      var k = "object" === typeof f && null !== f && f.type === ua && null === f.key;
      k && (f = f.props.children);
      var l = "object" === typeof f && null !== f;
      if (l) switch (f.$$typeof) {
        case sa:
          a: {
            l = f.key;

            for (k = d; null !== k;) {
              if (k.key === l) {
                switch (k.tag) {
                  case 7:
                    if (f.type === ua) {
                      c(a, k.sibling);
                      d = e(k, f.props.children);
                      d.return = a;
                      a = d;
                      break a;
                    }

                    break;

                  default:
                    if (k.elementType === f.type) {
                      c(a, k.sibling);
                      d = e(k, f.props);
                      d.ref = Qg(a, k, f);
                      d.return = a;
                      a = d;
                      break a;
                    }

                }

                c(a, k);
                break;
              } else b(a, k);

              k = k.sibling;
            }

            f.type === ua ? (d = Xg(f.props.children, a.mode, h, f.key), d.return = a, a = d) : (h = Vg(f.type, f.key, f.props, null, a.mode, h), h.ref = Qg(a, d, f), h.return = a, a = h);
          }

          return g(a);

        case ta:
          a: {
            for (k = f.key; null !== d;) {
              if (d.key === k) {
                if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                  c(a, d.sibling);
                  d = e(d, f.children || []);
                  d.return = a;
                  a = d;
                  break a;
                } else {
                  c(a, d);
                  break;
                }
              } else b(a, d);
              d = d.sibling;
            }

            d = Wg(f, a.mode, h);
            d.return = a;
            a = d;
          }

          return g(a);
      }
      if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f), d.return = a, a = d) : (c(a, d), d = Ug(f, a.mode, h), d.return = a, a = d), g(a);
      if (Pg(f)) return x(a, d, f, h);
      if (La(f)) return w(a, d, f, h);
      l && Rg(a, f);
      if ("undefined" === typeof f && !k) switch (a.tag) {
        case 1:
        case 22:
        case 0:
        case 11:
        case 15:
          throw Error(y$2(152, Ra(a.type) || "Component"));
      }
      return c(a, d);
    };
  }

  var Yg = Sg(!0),
      Zg = Sg(!1),
      $g = {},
      ah = Bf($g),
      bh = Bf($g),
      ch = Bf($g);

  function dh(a) {
    if (a === $g) throw Error(y$2(174));
    return a;
  }

  function eh(a, b) {
    I$2(ch, b);
    I$2(bh, a);
    I$2(ah, $g);
    a = b.nodeType;

    switch (a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : mb(null, "");
        break;

      default:
        a = 8 === a ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = mb(b, a);
    }

    H$2(ah);
    I$2(ah, b);
  }

  function fh() {
    H$2(ah);
    H$2(bh);
    H$2(ch);
  }

  function gh(a) {
    dh(ch.current);
    var b = dh(ah.current);
    var c = mb(b, a.type);
    b !== c && (I$2(bh, a), I$2(ah, c));
  }

  function hh(a) {
    bh.current === a && (H$2(ah), H$2(bh));
  }

  var P$1 = Bf(0);

  function ih(a) {
    for (var b = a; null !== b;) {
      if (13 === b.tag) {
        var c = b.memoizedState;
        if (null !== c && (c = c.dehydrated, null === c || "$?" === c.data || "$!" === c.data)) return b;
      } else if (19 === b.tag && void 0 !== b.memoizedProps.revealOrder) {
        if (0 !== (b.flags & 64)) return b;
      } else if (null !== b.child) {
        b.child.return = b;
        b = b.child;
        continue;
      }

      if (b === a) break;

      for (; null === b.sibling;) {
        if (null === b.return || b.return === a) return null;
        b = b.return;
      }

      b.sibling.return = b.return;
      b = b.sibling;
    }

    return null;
  }

  var jh = null,
      kh = null,
      lh = !1;

  function mh(a, b) {
    var c = nh(5, null, null, 0);
    c.elementType = "DELETED";
    c.type = "DELETED";
    c.stateNode = b;
    c.return = a;
    c.flags = 8;
    null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }

  function oh(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        b = 1 !== b.nodeType || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b;
        return null !== b ? (a.stateNode = b, !0) : !1;

      case 6:
        return b = "" === a.pendingProps || 3 !== b.nodeType ? null : b, null !== b ? (a.stateNode = b, !0) : !1;

      case 13:
        return !1;

      default:
        return !1;
    }
  }

  function ph(a) {
    if (lh) {
      var b = kh;

      if (b) {
        var c = b;

        if (!oh(a, b)) {
          b = rf(c.nextSibling);

          if (!b || !oh(a, b)) {
            a.flags = a.flags & -1025 | 2;
            lh = !1;
            jh = a;
            return;
          }

          mh(jh, c);
        }

        jh = a;
        kh = rf(b.firstChild);
      } else a.flags = a.flags & -1025 | 2, lh = !1, jh = a;
    }
  }

  function qh(a) {
    for (a = a.return; null !== a && 5 !== a.tag && 3 !== a.tag && 13 !== a.tag;) a = a.return;

    jh = a;
  }

  function rh(a) {
    if (a !== jh) return !1;
    if (!lh) return qh(a), lh = !0, !1;
    var b = a.type;
    if (5 !== a.tag || "head" !== b && "body" !== b && !nf(b, a.memoizedProps)) for (b = kh; b;) mh(a, b), b = rf(b.nextSibling);
    qh(a);

    if (13 === a.tag) {
      a = a.memoizedState;
      a = null !== a ? a.dehydrated : null;
      if (!a) throw Error(y$2(317));

      a: {
        a = a.nextSibling;

        for (b = 0; a;) {
          if (8 === a.nodeType) {
            var c = a.data;

            if ("/$" === c) {
              if (0 === b) {
                kh = rf(a.nextSibling);
                break a;
              }

              b--;
            } else "$" !== c && "$!" !== c && "$?" !== c || b++;
          }

          a = a.nextSibling;
        }

        kh = null;
      }
    } else kh = jh ? rf(a.stateNode.nextSibling) : null;

    return !0;
  }

  function sh() {
    kh = jh = null;
    lh = !1;
  }

  var th = [];

  function uh() {
    for (var a = 0; a < th.length; a++) th[a]._workInProgressVersionPrimary = null;

    th.length = 0;
  }

  var vh = ra.ReactCurrentDispatcher,
      wh = ra.ReactCurrentBatchConfig,
      xh = 0,
      R$1 = null,
      S$1 = null,
      T = null,
      yh = !1,
      zh = !1;

  function Ah() {
    throw Error(y$2(321));
  }

  function Bh(a, b) {
    if (null === b) return !1;

    for (var c = 0; c < b.length && c < a.length; c++) if (!He(a[c], b[c])) return !1;

    return !0;
  }

  function Ch(a, b, c, d, e, f) {
    xh = f;
    R$1 = b;
    b.memoizedState = null;
    b.updateQueue = null;
    b.lanes = 0;
    vh.current = null === a || null === a.memoizedState ? Dh : Eh;
    a = c(d, e);

    if (zh) {
      f = 0;

      do {
        zh = !1;
        if (!(25 > f)) throw Error(y$2(301));
        f += 1;
        T = S$1 = null;
        b.updateQueue = null;
        vh.current = Fh;
        a = c(d, e);
      } while (zh);
    }

    vh.current = Gh;
    b = null !== S$1 && null !== S$1.next;
    xh = 0;
    T = S$1 = R$1 = null;
    yh = !1;
    if (b) throw Error(y$2(300));
    return a;
  }

  function Hh() {
    var a = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === T ? R$1.memoizedState = T = a : T = T.next = a;
    return T;
  }

  function Ih() {
    if (null === S$1) {
      var a = R$1.alternate;
      a = null !== a ? a.memoizedState : null;
    } else a = S$1.next;

    var b = null === T ? R$1.memoizedState : T.next;
    if (null !== b) T = b, S$1 = a;else {
      if (null === a) throw Error(y$2(310));
      S$1 = a;
      a = {
        memoizedState: S$1.memoizedState,
        baseState: S$1.baseState,
        baseQueue: S$1.baseQueue,
        queue: S$1.queue,
        next: null
      };
      null === T ? R$1.memoizedState = T = a : T = T.next = a;
    }
    return T;
  }

  function Jh(a, b) {
    return "function" === typeof b ? b(a) : b;
  }

  function Kh(a) {
    var b = Ih(),
        c = b.queue;
    if (null === c) throw Error(y$2(311));
    c.lastRenderedReducer = a;
    var d = S$1,
        e = d.baseQueue,
        f = c.pending;

    if (null !== f) {
      if (null !== e) {
        var g = e.next;
        e.next = f.next;
        f.next = g;
      }

      d.baseQueue = e = f;
      c.pending = null;
    }

    if (null !== e) {
      e = e.next;
      d = d.baseState;
      var h = g = f = null,
          k = e;

      do {
        var l = k.lane;
        if ((xh & l) === l) null !== h && (h = h.next = {
          lane: 0,
          action: k.action,
          eagerReducer: k.eagerReducer,
          eagerState: k.eagerState,
          next: null
        }), d = k.eagerReducer === a ? k.eagerState : a(d, k.action);else {
          var n = {
            lane: l,
            action: k.action,
            eagerReducer: k.eagerReducer,
            eagerState: k.eagerState,
            next: null
          };
          null === h ? (g = h = n, f = d) : h = h.next = n;
          R$1.lanes |= l;
          Dg |= l;
        }
        k = k.next;
      } while (null !== k && k !== e);

      null === h ? f = d : h.next = g;
      He(d, b.memoizedState) || (ug = !0);
      b.memoizedState = d;
      b.baseState = f;
      b.baseQueue = h;
      c.lastRenderedState = d;
    }

    return [b.memoizedState, c.dispatch];
  }

  function Lh(a) {
    var b = Ih(),
        c = b.queue;
    if (null === c) throw Error(y$2(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch,
        e = c.pending,
        f = b.memoizedState;

    if (null !== e) {
      c.pending = null;
      var g = e = e.next;

      do f = a(f, g.action), g = g.next; while (g !== e);

      He(f, b.memoizedState) || (ug = !0);
      b.memoizedState = f;
      null === b.baseQueue && (b.baseState = f);
      c.lastRenderedState = f;
    }

    return [f, d];
  }

  function Mh(a, b, c) {
    var d = b._getVersion;
    d = d(b._source);
    var e = b._workInProgressVersionPrimary;
    if (null !== e) a = e === d;else if (a = a.mutableReadLanes, a = (xh & a) === a) b._workInProgressVersionPrimary = d, th.push(b);
    if (a) return c(b._source);
    th.push(b);
    throw Error(y$2(350));
  }

  function Nh(a, b, c, d) {
    var e = U$1;
    if (null === e) throw Error(y$2(349));
    var f = b._getVersion,
        g = f(b._source),
        h = vh.current,
        k = h.useState(function () {
      return Mh(e, b, c);
    }),
        l = k[1],
        n = k[0];
    k = T;
    var A = a.memoizedState,
        p = A.refs,
        C = p.getSnapshot,
        x = A.source;
    A = A.subscribe;
    var w = R$1;
    a.memoizedState = {
      refs: p,
      source: b,
      subscribe: d
    };
    h.useEffect(function () {
      p.getSnapshot = c;
      p.setSnapshot = l;
      var a = f(b._source);

      if (!He(g, a)) {
        a = c(b._source);
        He(n, a) || (l(a), a = Ig(w), e.mutableReadLanes |= a & e.pendingLanes);
        a = e.mutableReadLanes;
        e.entangledLanes |= a;

        for (var d = e.entanglements, h = a; 0 < h;) {
          var k = 31 - Vc(h),
              v = 1 << k;
          d[k] |= a;
          h &= ~v;
        }
      }
    }, [c, b, d]);
    h.useEffect(function () {
      return d(b._source, function () {
        var a = p.getSnapshot,
            c = p.setSnapshot;

        try {
          c(a(b._source));
          var d = Ig(w);
          e.mutableReadLanes |= d & e.pendingLanes;
        } catch (q) {
          c(function () {
            throw q;
          });
        }
      });
    }, [b, d]);
    He(C, c) && He(x, b) && He(A, d) || (a = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: Jh,
      lastRenderedState: n
    }, a.dispatch = l = Oh.bind(null, R$1, a), k.queue = a, k.baseQueue = null, n = Mh(e, b, c), k.memoizedState = k.baseState = n);
    return n;
  }

  function Ph(a, b, c) {
    var d = Ih();
    return Nh(d, a, b, c);
  }

  function Qh(a) {
    var b = Hh();
    "function" === typeof a && (a = a());
    b.memoizedState = b.baseState = a;
    a = b.queue = {
      pending: null,
      dispatch: null,
      lastRenderedReducer: Jh,
      lastRenderedState: a
    };
    a = a.dispatch = Oh.bind(null, R$1, a);
    return [b.memoizedState, a];
  }

  function Rh(a, b, c, d) {
    a = {
      tag: a,
      create: b,
      destroy: c,
      deps: d,
      next: null
    };
    b = R$1.updateQueue;
    null === b ? (b = {
      lastEffect: null
    }, R$1.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, null === c ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a));
    return a;
  }

  function Sh(a) {
    var b = Hh();
    a = {
      current: a
    };
    return b.memoizedState = a;
  }

  function Th() {
    return Ih().memoizedState;
  }

  function Uh(a, b, c, d) {
    var e = Hh();
    R$1.flags |= a;
    e.memoizedState = Rh(1 | b, c, void 0, void 0 === d ? null : d);
  }

  function Vh(a, b, c, d) {
    var e = Ih();
    d = void 0 === d ? null : d;
    var f = void 0;

    if (null !== S$1) {
      var g = S$1.memoizedState;
      f = g.destroy;

      if (null !== d && Bh(d, g.deps)) {
        Rh(b, c, f, d);
        return;
      }
    }

    R$1.flags |= a;
    e.memoizedState = Rh(1 | b, c, f, d);
  }

  function Wh(a, b) {
    return Uh(516, 4, a, b);
  }

  function Xh(a, b) {
    return Vh(516, 4, a, b);
  }

  function Yh(a, b) {
    return Vh(4, 2, a, b);
  }

  function Zh(a, b) {
    if ("function" === typeof b) return a = a(), b(a), function () {
      b(null);
    };
    if (null !== b && void 0 !== b) return a = a(), b.current = a, function () {
      b.current = null;
    };
  }

  function $h(a, b, c) {
    c = null !== c && void 0 !== c ? c.concat([a]) : null;
    return Vh(4, 2, Zh.bind(null, b, a), c);
  }

  function ai() {}

  function bi(a, b) {
    var c = Ih();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Bh(b, d[1])) return d[0];
    c.memoizedState = [a, b];
    return a;
  }

  function ci(a, b) {
    var c = Ih();
    b = void 0 === b ? null : b;
    var d = c.memoizedState;
    if (null !== d && null !== b && Bh(b, d[1])) return d[0];
    a = a();
    c.memoizedState = [a, b];
    return a;
  }

  function di(a, b) {
    var c = eg();
    gg(98 > c ? 98 : c, function () {
      a(!0);
    });
    gg(97 < c ? 97 : c, function () {
      var c = wh.transition;
      wh.transition = 1;

      try {
        a(!1), b();
      } finally {
        wh.transition = c;
      }
    });
  }

  function Oh(a, b, c) {
    var d = Hg(),
        e = Ig(a),
        f = {
      lane: e,
      action: c,
      eagerReducer: null,
      eagerState: null,
      next: null
    },
        g = b.pending;
    null === g ? f.next = f : (f.next = g.next, g.next = f);
    b.pending = f;
    g = a.alternate;
    if (a === R$1 || null !== g && g === R$1) zh = yh = !0;else {
      if (0 === a.lanes && (null === g || 0 === g.lanes) && (g = b.lastRenderedReducer, null !== g)) try {
        var h = b.lastRenderedState,
            k = g(h, c);
        f.eagerReducer = g;
        f.eagerState = k;
        if (He(k, h)) return;
      } catch (l) {} finally {}
      Jg(a, e, d);
    }
  }

  var Gh = {
    readContext: vg,
    useCallback: Ah,
    useContext: Ah,
    useEffect: Ah,
    useImperativeHandle: Ah,
    useLayoutEffect: Ah,
    useMemo: Ah,
    useReducer: Ah,
    useRef: Ah,
    useState: Ah,
    useDebugValue: Ah,
    useDeferredValue: Ah,
    useTransition: Ah,
    useMutableSource: Ah,
    useOpaqueIdentifier: Ah,
    unstable_isNewReconciler: !1
  },
      Dh = {
    readContext: vg,
    useCallback: function (a, b) {
      Hh().memoizedState = [a, void 0 === b ? null : b];
      return a;
    },
    useContext: vg,
    useEffect: Wh,
    useImperativeHandle: function (a, b, c) {
      c = null !== c && void 0 !== c ? c.concat([a]) : null;
      return Uh(4, 2, Zh.bind(null, b, a), c);
    },
    useLayoutEffect: function (a, b) {
      return Uh(4, 2, a, b);
    },
    useMemo: function (a, b) {
      var c = Hh();
      b = void 0 === b ? null : b;
      a = a();
      c.memoizedState = [a, b];
      return a;
    },
    useReducer: function (a, b, c) {
      var d = Hh();
      b = void 0 !== c ? c(b) : b;
      d.memoizedState = d.baseState = b;
      a = d.queue = {
        pending: null,
        dispatch: null,
        lastRenderedReducer: a,
        lastRenderedState: b
      };
      a = a.dispatch = Oh.bind(null, R$1, a);
      return [d.memoizedState, a];
    },
    useRef: Sh,
    useState: Qh,
    useDebugValue: ai,
    useDeferredValue: function (a) {
      var b = Qh(a),
          c = b[0],
          d = b[1];
      Wh(function () {
        var b = wh.transition;
        wh.transition = 1;

        try {
          d(a);
        } finally {
          wh.transition = b;
        }
      }, [a]);
      return c;
    },
    useTransition: function () {
      var a = Qh(!1),
          b = a[0];
      a = di.bind(null, a[1]);
      Sh(a);
      return [a, b];
    },
    useMutableSource: function (a, b, c) {
      var d = Hh();
      d.memoizedState = {
        refs: {
          getSnapshot: b,
          setSnapshot: null
        },
        source: a,
        subscribe: c
      };
      return Nh(d, a, b, c);
    },
    useOpaqueIdentifier: function () {
      if (lh) {
        var a = !1,
            b = uf(function () {
          a || (a = !0, c("r:" + (tf++).toString(36)));
          throw Error(y$2(355));
        }),
            c = Qh(b)[1];
        0 === (R$1.mode & 2) && (R$1.flags |= 516, Rh(5, function () {
          c("r:" + (tf++).toString(36));
        }, void 0, null));
        return b;
      }

      b = "r:" + (tf++).toString(36);
      Qh(b);
      return b;
    },
    unstable_isNewReconciler: !1
  },
      Eh = {
    readContext: vg,
    useCallback: bi,
    useContext: vg,
    useEffect: Xh,
    useImperativeHandle: $h,
    useLayoutEffect: Yh,
    useMemo: ci,
    useReducer: Kh,
    useRef: Th,
    useState: function () {
      return Kh(Jh);
    },
    useDebugValue: ai,
    useDeferredValue: function (a) {
      var b = Kh(Jh),
          c = b[0],
          d = b[1];
      Xh(function () {
        var b = wh.transition;
        wh.transition = 1;

        try {
          d(a);
        } finally {
          wh.transition = b;
        }
      }, [a]);
      return c;
    },
    useTransition: function () {
      var a = Kh(Jh)[0];
      return [Th().current, a];
    },
    useMutableSource: Ph,
    useOpaqueIdentifier: function () {
      return Kh(Jh)[0];
    },
    unstable_isNewReconciler: !1
  },
      Fh = {
    readContext: vg,
    useCallback: bi,
    useContext: vg,
    useEffect: Xh,
    useImperativeHandle: $h,
    useLayoutEffect: Yh,
    useMemo: ci,
    useReducer: Lh,
    useRef: Th,
    useState: function () {
      return Lh(Jh);
    },
    useDebugValue: ai,
    useDeferredValue: function (a) {
      var b = Lh(Jh),
          c = b[0],
          d = b[1];
      Xh(function () {
        var b = wh.transition;
        wh.transition = 1;

        try {
          d(a);
        } finally {
          wh.transition = b;
        }
      }, [a]);
      return c;
    },
    useTransition: function () {
      var a = Lh(Jh)[0];
      return [Th().current, a];
    },
    useMutableSource: Ph,
    useOpaqueIdentifier: function () {
      return Lh(Jh)[0];
    },
    unstable_isNewReconciler: !1
  },
      ei = ra.ReactCurrentOwner,
      ug = !1;

  function fi(a, b, c, d) {
    b.child = null === a ? Zg(b, null, c, d) : Yg(b, a.child, c, d);
  }

  function gi(a, b, c, d, e) {
    c = c.render;
    var f = b.ref;
    tg(b, e);
    d = Ch(a, b, c, d, f, e);
    if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
    b.flags |= 1;
    fi(a, b, d, e);
    return b.child;
  }

  function ii(a, b, c, d, e, f) {
    if (null === a) {
      var g = c.type;
      if ("function" === typeof g && !ji(g) && void 0 === g.defaultProps && null === c.compare && void 0 === c.defaultProps) return b.tag = 15, b.type = g, ki(a, b, g, d, e, f);
      a = Vg(c.type, null, d, b, b.mode, f);
      a.ref = b.ref;
      a.return = b;
      return b.child = a;
    }

    g = a.child;
    if (0 === (e & f) && (e = g.memoizedProps, c = c.compare, c = null !== c ? c : Je, c(e, d) && a.ref === b.ref)) return hi(a, b, f);
    b.flags |= 1;
    a = Tg(g, d);
    a.ref = b.ref;
    a.return = b;
    return b.child = a;
  }

  function ki(a, b, c, d, e, f) {
    if (null !== a && Je(a.memoizedProps, d) && a.ref === b.ref) if (ug = !1, 0 !== (f & e)) 0 !== (a.flags & 16384) && (ug = !0);else return b.lanes = a.lanes, hi(a, b, f);
    return li(a, b, c, d, f);
  }

  function mi(a, b, c) {
    var d = b.pendingProps,
        e = d.children,
        f = null !== a ? a.memoizedState : null;
    if ("hidden" === d.mode || "unstable-defer-without-hiding" === d.mode) {
      if (0 === (b.mode & 4)) b.memoizedState = {
        baseLanes: 0
      }, ni(b, c);else if (0 !== (c & 1073741824)) b.memoizedState = {
        baseLanes: 0
      }, ni(b, null !== f ? f.baseLanes : c);else return a = null !== f ? f.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = {
        baseLanes: a
      }, ni(b, a), null;
    } else null !== f ? (d = f.baseLanes | c, b.memoizedState = null) : d = c, ni(b, d);
    fi(a, b, e, c);
    return b.child;
  }

  function oi(a, b) {
    var c = b.ref;
    if (null === a && null !== c || null !== a && a.ref !== c) b.flags |= 128;
  }

  function li(a, b, c, d, e) {
    var f = Ff(c) ? Df : M$1.current;
    f = Ef(b, f);
    tg(b, e);
    c = Ch(a, b, c, d, f, e);
    if (null !== a && !ug) return b.updateQueue = a.updateQueue, b.flags &= -517, a.lanes &= ~e, hi(a, b, e);
    b.flags |= 1;
    fi(a, b, c, e);
    return b.child;
  }

  function pi(a, b, c, d, e) {
    if (Ff(c)) {
      var f = !0;
      Jf(b);
    } else f = !1;

    tg(b, e);
    if (null === b.stateNode) null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), Mg(b, c, d), Og(b, c, d, e), d = !0;else if (null === a) {
      var g = b.stateNode,
          h = b.memoizedProps;
      g.props = h;
      var k = g.context,
          l = c.contextType;
      "object" === typeof l && null !== l ? l = vg(l) : (l = Ff(c) ? Df : M$1.current, l = Ef(b, l));
      var n = c.getDerivedStateFromProps,
          A = "function" === typeof n || "function" === typeof g.getSnapshotBeforeUpdate;
      A || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== d || k !== l) && Ng(b, g, d, l);
      wg = !1;
      var p = b.memoizedState;
      g.state = p;
      Cg(b, d, g, e);
      k = b.memoizedState;
      h !== d || p !== k || N$1.current || wg ? ("function" === typeof n && (Gg(b, c, n, d), k = b.memoizedState), (h = wg || Lg(b, c, h, d, p, k, l)) ? (A || "function" !== typeof g.UNSAFE_componentWillMount && "function" !== typeof g.componentWillMount || ("function" === typeof g.componentWillMount && g.componentWillMount(), "function" === typeof g.UNSAFE_componentWillMount && g.UNSAFE_componentWillMount()), "function" === typeof g.componentDidMount && (b.flags |= 4)) : ("function" === typeof g.componentDidMount && (b.flags |= 4), b.memoizedProps = d, b.memoizedState = k), g.props = d, g.state = k, g.context = l, d = h) : ("function" === typeof g.componentDidMount && (b.flags |= 4), d = !1);
    } else {
      g = b.stateNode;
      yg(a, b);
      h = b.memoizedProps;
      l = b.type === b.elementType ? h : lg(b.type, h);
      g.props = l;
      A = b.pendingProps;
      p = g.context;
      k = c.contextType;
      "object" === typeof k && null !== k ? k = vg(k) : (k = Ff(c) ? Df : M$1.current, k = Ef(b, k));
      var C = c.getDerivedStateFromProps;
      (n = "function" === typeof C || "function" === typeof g.getSnapshotBeforeUpdate) || "function" !== typeof g.UNSAFE_componentWillReceiveProps && "function" !== typeof g.componentWillReceiveProps || (h !== A || p !== k) && Ng(b, g, d, k);
      wg = !1;
      p = b.memoizedState;
      g.state = p;
      Cg(b, d, g, e);
      var x = b.memoizedState;
      h !== A || p !== x || N$1.current || wg ? ("function" === typeof C && (Gg(b, c, C, d), x = b.memoizedState), (l = wg || Lg(b, c, l, d, p, x, k)) ? (n || "function" !== typeof g.UNSAFE_componentWillUpdate && "function" !== typeof g.componentWillUpdate || ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(d, x, k), "function" === typeof g.UNSAFE_componentWillUpdate && g.UNSAFE_componentWillUpdate(d, x, k)), "function" === typeof g.componentDidUpdate && (b.flags |= 4), "function" === typeof g.getSnapshotBeforeUpdate && (b.flags |= 256)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), b.memoizedProps = d, b.memoizedState = x), g.props = d, g.state = x, g.context = k, d = l) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 4), "function" !== typeof g.getSnapshotBeforeUpdate || h === a.memoizedProps && p === a.memoizedState || (b.flags |= 256), d = !1);
    }
    return qi(a, b, c, d, f, e);
  }

  function qi(a, b, c, d, e, f) {
    oi(a, b);
    var g = 0 !== (b.flags & 64);
    if (!d && !g) return e && Kf(b, c, !1), hi(a, b, f);
    d = b.stateNode;
    ei.current = b;
    var h = g && "function" !== typeof c.getDerivedStateFromError ? null : d.render();
    b.flags |= 1;
    null !== a && g ? (b.child = Yg(b, a.child, null, f), b.child = Yg(b, null, h, f)) : fi(a, b, h, f);
    b.memoizedState = d.state;
    e && Kf(b, c, !0);
    return b.child;
  }

  function ri(a) {
    var b = a.stateNode;
    b.pendingContext ? Hf(a, b.pendingContext, b.pendingContext !== b.context) : b.context && Hf(a, b.context, !1);
    eh(a, b.containerInfo);
  }

  var si = {
    dehydrated: null,
    retryLane: 0
  };

  function ti(a, b, c) {
    var d = b.pendingProps,
        e = P$1.current,
        f = !1,
        g;
    (g = 0 !== (b.flags & 64)) || (g = null !== a && null === a.memoizedState ? !1 : 0 !== (e & 2));
    g ? (f = !0, b.flags &= -65) : null !== a && null === a.memoizedState || void 0 === d.fallback || !0 === d.unstable_avoidThisFallback || (e |= 1);
    I$2(P$1, e & 1);

    if (null === a) {
      void 0 !== d.fallback && ph(b);
      a = d.children;
      e = d.fallback;
      if (f) return a = ui(b, a, e, c), b.child.memoizedState = {
        baseLanes: c
      }, b.memoizedState = si, a;
      if ("number" === typeof d.unstable_expectedLoadTime) return a = ui(b, a, e, c), b.child.memoizedState = {
        baseLanes: c
      }, b.memoizedState = si, b.lanes = 33554432, a;
      c = vi({
        mode: "visible",
        children: a
      }, b.mode, c, null);
      c.return = b;
      return b.child = c;
    }

    if (null !== a.memoizedState) {
      if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? {
        baseLanes: c
      } : {
        baseLanes: e.baseLanes | c
      }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
      c = xi(a, b, d.children, c);
      b.memoizedState = null;
      return c;
    }

    if (f) return d = wi(a, b, d.children, d.fallback, c), f = b.child, e = a.child.memoizedState, f.memoizedState = null === e ? {
      baseLanes: c
    } : {
      baseLanes: e.baseLanes | c
    }, f.childLanes = a.childLanes & ~c, b.memoizedState = si, d;
    c = xi(a, b, d.children, c);
    b.memoizedState = null;
    return c;
  }

  function ui(a, b, c, d) {
    var e = a.mode,
        f = a.child;
    b = {
      mode: "hidden",
      children: b
    };
    0 === (e & 2) && null !== f ? (f.childLanes = 0, f.pendingProps = b) : f = vi(b, e, 0, null);
    c = Xg(c, e, d, null);
    f.return = a;
    c.return = a;
    f.sibling = c;
    a.child = f;
    return c;
  }

  function xi(a, b, c, d) {
    var e = a.child;
    a = e.sibling;
    c = Tg(e, {
      mode: "visible",
      children: c
    });
    0 === (b.mode & 2) && (c.lanes = d);
    c.return = b;
    c.sibling = null;
    null !== a && (a.nextEffect = null, a.flags = 8, b.firstEffect = b.lastEffect = a);
    return b.child = c;
  }

  function wi(a, b, c, d, e) {
    var f = b.mode,
        g = a.child;
    a = g.sibling;
    var h = {
      mode: "hidden",
      children: c
    };
    0 === (f & 2) && b.child !== g ? (c = b.child, c.childLanes = 0, c.pendingProps = h, g = c.lastEffect, null !== g ? (b.firstEffect = c.firstEffect, b.lastEffect = g, g.nextEffect = null) : b.firstEffect = b.lastEffect = null) : c = Tg(g, h);
    null !== a ? d = Tg(a, d) : (d = Xg(d, f, e, null), d.flags |= 2);
    d.return = b;
    c.return = b;
    c.sibling = d;
    b.child = c;
    return d;
  }

  function yi(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    sg(a.return, b);
  }

  function zi(a, b, c, d, e, f) {
    var g = a.memoizedState;
    null === g ? a.memoizedState = {
      isBackwards: b,
      rendering: null,
      renderingStartTime: 0,
      last: d,
      tail: c,
      tailMode: e,
      lastEffect: f
    } : (g.isBackwards = b, g.rendering = null, g.renderingStartTime = 0, g.last = d, g.tail = c, g.tailMode = e, g.lastEffect = f);
  }

  function Ai(a, b, c) {
    var d = b.pendingProps,
        e = d.revealOrder,
        f = d.tail;
    fi(a, b, d.children, c);
    d = P$1.current;
    if (0 !== (d & 2)) d = d & 1 | 2, b.flags |= 64;else {
      if (null !== a && 0 !== (a.flags & 64)) a: for (a = b.child; null !== a;) {
        if (13 === a.tag) null !== a.memoizedState && yi(a, c);else if (19 === a.tag) yi(a, c);else if (null !== a.child) {
          a.child.return = a;
          a = a.child;
          continue;
        }
        if (a === b) break a;

        for (; null === a.sibling;) {
          if (null === a.return || a.return === b) break a;
          a = a.return;
        }

        a.sibling.return = a.return;
        a = a.sibling;
      }
      d &= 1;
    }
    I$2(P$1, d);
    if (0 === (b.mode & 2)) b.memoizedState = null;else switch (e) {
      case "forwards":
        c = b.child;

        for (e = null; null !== c;) a = c.alternate, null !== a && null === ih(a) && (e = c), c = c.sibling;

        c = e;
        null === c ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null);
        zi(b, !1, e, c, f, b.lastEffect);
        break;

      case "backwards":
        c = null;
        e = b.child;

        for (b.child = null; null !== e;) {
          a = e.alternate;

          if (null !== a && null === ih(a)) {
            b.child = e;
            break;
          }

          a = e.sibling;
          e.sibling = c;
          c = e;
          e = a;
        }

        zi(b, !0, c, null, f, b.lastEffect);
        break;

      case "together":
        zi(b, !1, null, null, void 0, b.lastEffect);
        break;

      default:
        b.memoizedState = null;
    }
    return b.child;
  }

  function hi(a, b, c) {
    null !== a && (b.dependencies = a.dependencies);
    Dg |= b.lanes;

    if (0 !== (c & b.childLanes)) {
      if (null !== a && b.child !== a.child) throw Error(y$2(153));

      if (null !== b.child) {
        a = b.child;
        c = Tg(a, a.pendingProps);
        b.child = c;

        for (c.return = b; null !== a.sibling;) a = a.sibling, c = c.sibling = Tg(a, a.pendingProps), c.return = b;

        c.sibling = null;
      }

      return b.child;
    }

    return null;
  }

  var Bi, Ci, Di, Ei;

  Bi = function (a, b) {
    for (var c = b.child; null !== c;) {
      if (5 === c.tag || 6 === c.tag) a.appendChild(c.stateNode);else if (4 !== c.tag && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }
      if (c === b) break;

      for (; null === c.sibling;) {
        if (null === c.return || c.return === b) return;
        c = c.return;
      }

      c.sibling.return = c.return;
      c = c.sibling;
    }
  };

  Ci = function () {};

  Di = function (a, b, c, d) {
    var e = a.memoizedProps;

    if (e !== d) {
      a = b.stateNode;
      dh(ah.current);
      var f = null;

      switch (c) {
        case "input":
          e = Ya(a, e);
          d = Ya(a, d);
          f = [];
          break;

        case "option":
          e = eb(a, e);
          d = eb(a, d);
          f = [];
          break;

        case "select":
          e = m$3({}, e, {
            value: void 0
          });
          d = m$3({}, d, {
            value: void 0
          });
          f = [];
          break;

        case "textarea":
          e = gb(a, e);
          d = gb(a, d);
          f = [];
          break;

        default:
          "function" !== typeof e.onClick && "function" === typeof d.onClick && (a.onclick = jf);
      }

      vb(c, d);
      var g;
      c = null;

      for (l in e) if (!d.hasOwnProperty(l) && e.hasOwnProperty(l) && null != e[l]) if ("style" === l) {
        var h = e[l];

        for (g in h) h.hasOwnProperty(g) && (c || (c = {}), c[g] = "");
      } else "dangerouslySetInnerHTML" !== l && "children" !== l && "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && "autoFocus" !== l && (ca.hasOwnProperty(l) ? f || (f = []) : (f = f || []).push(l, null));

      for (l in d) {
        var k = d[l];
        h = null != e ? e[l] : void 0;
        if (d.hasOwnProperty(l) && k !== h && (null != k || null != h)) if ("style" === l) {
          if (h) {
            for (g in h) !h.hasOwnProperty(g) || k && k.hasOwnProperty(g) || (c || (c = {}), c[g] = "");

            for (g in k) k.hasOwnProperty(g) && h[g] !== k[g] && (c || (c = {}), c[g] = k[g]);
          } else c || (f || (f = []), f.push(l, c)), c = k;
        } else "dangerouslySetInnerHTML" === l ? (k = k ? k.__html : void 0, h = h ? h.__html : void 0, null != k && h !== k && (f = f || []).push(l, k)) : "children" === l ? "string" !== typeof k && "number" !== typeof k || (f = f || []).push(l, "" + k) : "suppressContentEditableWarning" !== l && "suppressHydrationWarning" !== l && (ca.hasOwnProperty(l) ? (null != k && "onScroll" === l && G$2("scroll", a), f || h === k || (f = [])) : "object" === typeof k && null !== k && k.$$typeof === Ga ? k.toString() : (f = f || []).push(l, k));
      }

      c && (f = f || []).push("style", c);
      var l = f;
      if (b.updateQueue = l) b.flags |= 4;
    }
  };

  Ei = function (a, b, c, d) {
    c !== d && (b.flags |= 4);
  };

  function Fi(a, b) {
    if (!lh) switch (a.tailMode) {
      case "hidden":
        b = a.tail;

        for (var c = null; null !== b;) null !== b.alternate && (c = b), b = b.sibling;

        null === c ? a.tail = null : c.sibling = null;
        break;

      case "collapsed":
        c = a.tail;

        for (var d = null; null !== c;) null !== c.alternate && (d = c), c = c.sibling;

        null === d ? b || null === a.tail ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }

  function Gi(a, b, c) {
    var d = b.pendingProps;

    switch (b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return null;

      case 1:
        return Ff(b.type) && Gf(), null;

      case 3:
        fh();
        H$2(N$1);
        H$2(M$1);
        uh();
        d = b.stateNode;
        d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null);
        if (null === a || null === a.child) rh(b) ? b.flags |= 4 : d.hydrate || (b.flags |= 256);
        Ci(b);
        return null;

      case 5:
        hh(b);
        var e = dh(ch.current);
        c = b.type;
        if (null !== a && null != b.stateNode) Di(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 128);else {
          if (!d) {
            if (null === b.stateNode) throw Error(y$2(166));
            return null;
          }

          a = dh(ah.current);

          if (rh(b)) {
            d = b.stateNode;
            c = b.type;
            var f = b.memoizedProps;
            d[wf] = b;
            d[xf] = f;

            switch (c) {
              case "dialog":
                G$2("cancel", d);
                G$2("close", d);
                break;

              case "iframe":
              case "object":
              case "embed":
                G$2("load", d);
                break;

              case "video":
              case "audio":
                for (a = 0; a < Xe.length; a++) G$2(Xe[a], d);

                break;

              case "source":
                G$2("error", d);
                break;

              case "img":
              case "image":
              case "link":
                G$2("error", d);
                G$2("load", d);
                break;

              case "details":
                G$2("toggle", d);
                break;

              case "input":
                Za(d, f);
                G$2("invalid", d);
                break;

              case "select":
                d._wrapperState = {
                  wasMultiple: !!f.multiple
                };
                G$2("invalid", d);
                break;

              case "textarea":
                hb(d, f), G$2("invalid", d);
            }

            vb(c, f);
            a = null;

            for (var g in f) f.hasOwnProperty(g) && (e = f[g], "children" === g ? "string" === typeof e ? d.textContent !== e && (a = ["children", e]) : "number" === typeof e && d.textContent !== "" + e && (a = ["children", "" + e]) : ca.hasOwnProperty(g) && null != e && "onScroll" === g && G$2("scroll", d));

            switch (c) {
              case "input":
                Va(d);
                cb(d, f, !0);
                break;

              case "textarea":
                Va(d);
                jb(d);
                break;

              case "select":
              case "option":
                break;

              default:
                "function" === typeof f.onClick && (d.onclick = jf);
            }

            d = a;
            b.updateQueue = d;
            null !== d && (b.flags |= 4);
          } else {
            g = 9 === e.nodeType ? e : e.ownerDocument;
            a === kb.html && (a = lb(c));
            a === kb.html ? "script" === c ? (a = g.createElement("div"), a.innerHTML = "<script>\x3c/script>", a = a.removeChild(a.firstChild)) : "string" === typeof d.is ? a = g.createElement(c, {
              is: d.is
            }) : (a = g.createElement(c), "select" === c && (g = a, d.multiple ? g.multiple = !0 : d.size && (g.size = d.size))) : a = g.createElementNS(a, c);
            a[wf] = b;
            a[xf] = d;
            Bi(a, b, !1, !1);
            b.stateNode = a;
            g = wb(c, d);

            switch (c) {
              case "dialog":
                G$2("cancel", a);
                G$2("close", a);
                e = d;
                break;

              case "iframe":
              case "object":
              case "embed":
                G$2("load", a);
                e = d;
                break;

              case "video":
              case "audio":
                for (e = 0; e < Xe.length; e++) G$2(Xe[e], a);

                e = d;
                break;

              case "source":
                G$2("error", a);
                e = d;
                break;

              case "img":
              case "image":
              case "link":
                G$2("error", a);
                G$2("load", a);
                e = d;
                break;

              case "details":
                G$2("toggle", a);
                e = d;
                break;

              case "input":
                Za(a, d);
                e = Ya(a, d);
                G$2("invalid", a);
                break;

              case "option":
                e = eb(a, d);
                break;

              case "select":
                a._wrapperState = {
                  wasMultiple: !!d.multiple
                };
                e = m$3({}, d, {
                  value: void 0
                });
                G$2("invalid", a);
                break;

              case "textarea":
                hb(a, d);
                e = gb(a, d);
                G$2("invalid", a);
                break;

              default:
                e = d;
            }

            vb(c, e);
            var h = e;

            for (f in h) if (h.hasOwnProperty(f)) {
              var k = h[f];
              "style" === f ? tb(a, k) : "dangerouslySetInnerHTML" === f ? (k = k ? k.__html : void 0, null != k && ob(a, k)) : "children" === f ? "string" === typeof k ? ("textarea" !== c || "" !== k) && pb(a, k) : "number" === typeof k && pb(a, "" + k) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ca.hasOwnProperty(f) ? null != k && "onScroll" === f && G$2("scroll", a) : null != k && qa(a, f, k, g));
            }

            switch (c) {
              case "input":
                Va(a);
                cb(a, d, !1);
                break;

              case "textarea":
                Va(a);
                jb(a);
                break;

              case "option":
                null != d.value && a.setAttribute("value", "" + Sa(d.value));
                break;

              case "select":
                a.multiple = !!d.multiple;
                f = d.value;
                null != f ? fb(a, !!d.multiple, f, !1) : null != d.defaultValue && fb(a, !!d.multiple, d.defaultValue, !0);
                break;

              default:
                "function" === typeof e.onClick && (a.onclick = jf);
            }

            mf(c, d) && (b.flags |= 4);
          }

          null !== b.ref && (b.flags |= 128);
        }
        return null;

      case 6:
        if (a && null != b.stateNode) Ei(a, b, a.memoizedProps, d);else {
          if ("string" !== typeof d && null === b.stateNode) throw Error(y$2(166));
          c = dh(ch.current);
          dh(ah.current);
          rh(b) ? (d = b.stateNode, c = b.memoizedProps, d[wf] = b, d.nodeValue !== c && (b.flags |= 4)) : (d = (9 === c.nodeType ? c : c.ownerDocument).createTextNode(d), d[wf] = b, b.stateNode = d);
        }
        return null;

      case 13:
        H$2(P$1);
        d = b.memoizedState;
        if (0 !== (b.flags & 64)) return b.lanes = c, b;
        d = null !== d;
        c = !1;
        null === a ? void 0 !== b.memoizedProps.fallback && rh(b) : c = null !== a.memoizedState;
        if (d && !c && 0 !== (b.mode & 2)) if (null === a && !0 !== b.memoizedProps.unstable_avoidThisFallback || 0 !== (P$1.current & 1)) 0 === V && (V = 3);else {
          if (0 === V || 3 === V) V = 4;
          null === U$1 || 0 === (Dg & 134217727) && 0 === (Hi & 134217727) || Ii(U$1, W$1);
        }
        if (d || c) b.flags |= 4;
        return null;

      case 4:
        return fh(), Ci(b), null === a && cf(b.stateNode.containerInfo), null;

      case 10:
        return rg(b), null;

      case 17:
        return Ff(b.type) && Gf(), null;

      case 19:
        H$2(P$1);
        d = b.memoizedState;
        if (null === d) return null;
        f = 0 !== (b.flags & 64);
        g = d.rendering;
        if (null === g) {
          if (f) Fi(d, !1);else {
            if (0 !== V || null !== a && 0 !== (a.flags & 64)) for (a = b.child; null !== a;) {
              g = ih(a);

              if (null !== g) {
                b.flags |= 64;
                Fi(d, !1);
                f = g.updateQueue;
                null !== f && (b.updateQueue = f, b.flags |= 4);
                null === d.lastEffect && (b.firstEffect = null);
                b.lastEffect = d.lastEffect;
                d = c;

                for (c = b.child; null !== c;) f = c, a = d, f.flags &= 2, f.nextEffect = null, f.firstEffect = null, f.lastEffect = null, g = f.alternate, null === g ? (f.childLanes = 0, f.lanes = a, f.child = null, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = g.childLanes, f.lanes = g.lanes, f.child = g.child, f.memoizedProps = g.memoizedProps, f.memoizedState = g.memoizedState, f.updateQueue = g.updateQueue, f.type = g.type, a = g.dependencies, f.dependencies = null === a ? null : {
                  lanes: a.lanes,
                  firstContext: a.firstContext
                }), c = c.sibling;

                I$2(P$1, P$1.current & 1 | 2);
                return b.child;
              }

              a = a.sibling;
            }
            null !== d.tail && O$1() > Ji && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);
          }
        } else {
          if (!f) if (a = ih(g), null !== a) {
            if (b.flags |= 64, f = !0, c = a.updateQueue, null !== c && (b.updateQueue = c, b.flags |= 4), Fi(d, !0), null === d.tail && "hidden" === d.tailMode && !g.alternate && !lh) return b = b.lastEffect = d.lastEffect, null !== b && (b.nextEffect = null), null;
          } else 2 * O$1() - d.renderingStartTime > Ji && 1073741824 !== c && (b.flags |= 64, f = !0, Fi(d, !1), b.lanes = 33554432);
          d.isBackwards ? (g.sibling = b.child, b.child = g) : (c = d.last, null !== c ? c.sibling = g : b.child = g, d.last = g);
        }
        return null !== d.tail ? (c = d.tail, d.rendering = c, d.tail = c.sibling, d.lastEffect = b.lastEffect, d.renderingStartTime = O$1(), c.sibling = null, b = P$1.current, I$2(P$1, f ? b & 1 | 2 : b & 1), c) : null;

      case 23:
      case 24:
        return Ki(), null !== a && null !== a.memoizedState !== (null !== b.memoizedState) && "unstable-defer-without-hiding" !== d.mode && (b.flags |= 4), null;
    }

    throw Error(y$2(156, b.tag));
  }

  function Li(a) {
    switch (a.tag) {
      case 1:
        Ff(a.type) && Gf();
        var b = a.flags;
        return b & 4096 ? (a.flags = b & -4097 | 64, a) : null;

      case 3:
        fh();
        H$2(N$1);
        H$2(M$1);
        uh();
        b = a.flags;
        if (0 !== (b & 64)) throw Error(y$2(285));
        a.flags = b & -4097 | 64;
        return a;

      case 5:
        return hh(a), null;

      case 13:
        return H$2(P$1), b = a.flags, b & 4096 ? (a.flags = b & -4097 | 64, a) : null;

      case 19:
        return H$2(P$1), null;

      case 4:
        return fh(), null;

      case 10:
        return rg(a), null;

      case 23:
      case 24:
        return Ki(), null;

      default:
        return null;
    }
  }

  function Mi(a, b) {
    try {
      var c = "",
          d = b;

      do c += Qa(d), d = d.return; while (d);

      var e = c;
    } catch (f) {
      e = "\nError generating stack: " + f.message + "\n" + f.stack;
    }

    return {
      value: a,
      source: b,
      stack: e
    };
  }

  function Ni(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function () {
        throw c;
      });
    }
  }

  var Oi = "function" === typeof WeakMap ? WeakMap : Map;

  function Pi(a, b, c) {
    c = zg(-1, c);
    c.tag = 3;
    c.payload = {
      element: null
    };
    var d = b.value;

    c.callback = function () {
      Qi || (Qi = !0, Ri = d);
      Ni(a, b);
    };

    return c;
  }

  function Si(a, b, c) {
    c = zg(-1, c);
    c.tag = 3;
    var d = a.type.getDerivedStateFromError;

    if ("function" === typeof d) {
      var e = b.value;

      c.payload = function () {
        Ni(a, b);
        return d(e);
      };
    }

    var f = a.stateNode;
    null !== f && "function" === typeof f.componentDidCatch && (c.callback = function () {
      "function" !== typeof d && (null === Ti ? Ti = new Set([this]) : Ti.add(this), Ni(a, b));
      var c = b.stack;
      this.componentDidCatch(b.value, {
        componentStack: null !== c ? c : ""
      });
    });
    return c;
  }

  var Ui = "function" === typeof WeakSet ? WeakSet : Set;

  function Vi(a) {
    var b = a.ref;
    if (null !== b) if ("function" === typeof b) try {
      b(null);
    } catch (c) {
      Wi(a, c);
    } else b.current = null;
  }

  function Xi(a, b) {
    switch (b.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        return;

      case 1:
        if (b.flags & 256 && null !== a) {
          var c = a.memoizedProps,
              d = a.memoizedState;
          a = b.stateNode;
          b = a.getSnapshotBeforeUpdate(b.elementType === b.type ? c : lg(b.type, c), d);
          a.__reactInternalSnapshotBeforeUpdate = b;
        }

        return;

      case 3:
        b.flags & 256 && qf(b.stateNode.containerInfo);
        return;

      case 5:
      case 6:
      case 4:
      case 17:
        return;
    }

    throw Error(y$2(163));
  }

  function Yi(a, b, c) {
    switch (c.tag) {
      case 0:
      case 11:
      case 15:
      case 22:
        b = c.updateQueue;
        b = null !== b ? b.lastEffect : null;

        if (null !== b) {
          a = b = b.next;

          do {
            if (3 === (a.tag & 3)) {
              var d = a.create;
              a.destroy = d();
            }

            a = a.next;
          } while (a !== b);
        }

        b = c.updateQueue;
        b = null !== b ? b.lastEffect : null;

        if (null !== b) {
          a = b = b.next;

          do {
            var e = a;
            d = e.next;
            e = e.tag;
            0 !== (e & 4) && 0 !== (e & 1) && (Zi(c, a), $i(c, a));
            a = d;
          } while (a !== b);
        }

        return;

      case 1:
        a = c.stateNode;
        c.flags & 4 && (null === b ? a.componentDidMount() : (d = c.elementType === c.type ? b.memoizedProps : lg(c.type, b.memoizedProps), a.componentDidUpdate(d, b.memoizedState, a.__reactInternalSnapshotBeforeUpdate)));
        b = c.updateQueue;
        null !== b && Eg(c, b, a);
        return;

      case 3:
        b = c.updateQueue;

        if (null !== b) {
          a = null;
          if (null !== c.child) switch (c.child.tag) {
            case 5:
              a = c.child.stateNode;
              break;

            case 1:
              a = c.child.stateNode;
          }
          Eg(c, b, a);
        }

        return;

      case 5:
        a = c.stateNode;
        null === b && c.flags & 4 && mf(c.type, c.memoizedProps) && a.focus();
        return;

      case 6:
        return;

      case 4:
        return;

      case 12:
        return;

      case 13:
        null === c.memoizedState && (c = c.alternate, null !== c && (c = c.memoizedState, null !== c && (c = c.dehydrated, null !== c && Cc(c))));
        return;

      case 19:
      case 17:
      case 20:
      case 21:
      case 23:
      case 24:
        return;
    }

    throw Error(y$2(163));
  }

  function aj(a, b) {
    for (var c = a;;) {
      if (5 === c.tag) {
        var d = c.stateNode;
        if (b) d = d.style, "function" === typeof d.setProperty ? d.setProperty("display", "none", "important") : d.display = "none";else {
          d = c.stateNode;
          var e = c.memoizedProps.style;
          e = void 0 !== e && null !== e && e.hasOwnProperty("display") ? e.display : null;
          d.style.display = sb("display", e);
        }
      } else if (6 === c.tag) c.stateNode.nodeValue = b ? "" : c.memoizedProps;else if ((23 !== c.tag && 24 !== c.tag || null === c.memoizedState || c === a) && null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }

      if (c === a) break;

      for (; null === c.sibling;) {
        if (null === c.return || c.return === a) return;
        c = c.return;
      }

      c.sibling.return = c.return;
      c = c.sibling;
    }
  }

  function bj(a, b) {
    if (Mf && "function" === typeof Mf.onCommitFiberUnmount) try {
      Mf.onCommitFiberUnmount(Lf, b);
    } catch (f) {}

    switch (b.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        a = b.updateQueue;

        if (null !== a && (a = a.lastEffect, null !== a)) {
          var c = a = a.next;

          do {
            var d = c,
                e = d.destroy;
            d = d.tag;
            if (void 0 !== e) if (0 !== (d & 4)) Zi(b, c);else {
              d = b;

              try {
                e();
              } catch (f) {
                Wi(d, f);
              }
            }
            c = c.next;
          } while (c !== a);
        }

        break;

      case 1:
        Vi(b);
        a = b.stateNode;
        if ("function" === typeof a.componentWillUnmount) try {
          a.props = b.memoizedProps, a.state = b.memoizedState, a.componentWillUnmount();
        } catch (f) {
          Wi(b, f);
        }
        break;

      case 5:
        Vi(b);
        break;

      case 4:
        cj(a, b);
    }
  }

  function dj(a) {
    a.alternate = null;
    a.child = null;
    a.dependencies = null;
    a.firstEffect = null;
    a.lastEffect = null;
    a.memoizedProps = null;
    a.memoizedState = null;
    a.pendingProps = null;
    a.return = null;
    a.updateQueue = null;
  }

  function ej(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }

  function fj(a) {
    a: {
      for (var b = a.return; null !== b;) {
        if (ej(b)) break a;
        b = b.return;
      }

      throw Error(y$2(160));
    }

    var c = b;
    b = c.stateNode;

    switch (c.tag) {
      case 5:
        var d = !1;
        break;

      case 3:
        b = b.containerInfo;
        d = !0;
        break;

      case 4:
        b = b.containerInfo;
        d = !0;
        break;

      default:
        throw Error(y$2(161));
    }

    c.flags & 16 && (pb(b, ""), c.flags &= -17);

    a: b: for (c = a;;) {
      for (; null === c.sibling;) {
        if (null === c.return || ej(c.return)) {
          c = null;
          break a;
        }

        c = c.return;
      }

      c.sibling.return = c.return;

      for (c = c.sibling; 5 !== c.tag && 6 !== c.tag && 18 !== c.tag;) {
        if (c.flags & 2) continue b;
        if (null === c.child || 4 === c.tag) continue b;else c.child.return = c, c = c.child;
      }

      if (!(c.flags & 2)) {
        c = c.stateNode;
        break a;
      }
    }

    d ? gj(a, c, b) : hj(a, c, b);
  }

  function gj(a, b, c) {
    var d = a.tag,
        e = 5 === d || 6 === d;
    if (e) a = e ? a.stateNode : a.stateNode.instance, b ? 8 === c.nodeType ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (8 === c.nodeType ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, null !== c && void 0 !== c || null !== b.onclick || (b.onclick = jf));else if (4 !== d && (a = a.child, null !== a)) for (gj(a, b, c), a = a.sibling; null !== a;) gj(a, b, c), a = a.sibling;
  }

  function hj(a, b, c) {
    var d = a.tag,
        e = 5 === d || 6 === d;
    if (e) a = e ? a.stateNode : a.stateNode.instance, b ? c.insertBefore(a, b) : c.appendChild(a);else if (4 !== d && (a = a.child, null !== a)) for (hj(a, b, c), a = a.sibling; null !== a;) hj(a, b, c), a = a.sibling;
  }

  function cj(a, b) {
    for (var c = b, d = !1, e, f;;) {
      if (!d) {
        d = c.return;

        a: for (;;) {
          if (null === d) throw Error(y$2(160));
          e = d.stateNode;

          switch (d.tag) {
            case 5:
              f = !1;
              break a;

            case 3:
              e = e.containerInfo;
              f = !0;
              break a;

            case 4:
              e = e.containerInfo;
              f = !0;
              break a;
          }

          d = d.return;
        }

        d = !0;
      }

      if (5 === c.tag || 6 === c.tag) {
        a: for (var g = a, h = c, k = h;;) if (bj(g, k), null !== k.child && 4 !== k.tag) k.child.return = k, k = k.child;else {
          if (k === h) break a;

          for (; null === k.sibling;) {
            if (null === k.return || k.return === h) break a;
            k = k.return;
          }

          k.sibling.return = k.return;
          k = k.sibling;
        }

        f ? (g = e, h = c.stateNode, 8 === g.nodeType ? g.parentNode.removeChild(h) : g.removeChild(h)) : e.removeChild(c.stateNode);
      } else if (4 === c.tag) {
        if (null !== c.child) {
          e = c.stateNode.containerInfo;
          f = !0;
          c.child.return = c;
          c = c.child;
          continue;
        }
      } else if (bj(a, c), null !== c.child) {
        c.child.return = c;
        c = c.child;
        continue;
      }

      if (c === b) break;

      for (; null === c.sibling;) {
        if (null === c.return || c.return === b) return;
        c = c.return;
        4 === c.tag && (d = !1);
      }

      c.sibling.return = c.return;
      c = c.sibling;
    }
  }

  function ij(a, b) {
    switch (b.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
      case 22:
        var c = b.updateQueue;
        c = null !== c ? c.lastEffect : null;

        if (null !== c) {
          var d = c = c.next;

          do 3 === (d.tag & 3) && (a = d.destroy, d.destroy = void 0, void 0 !== a && a()), d = d.next; while (d !== c);
        }

        return;

      case 1:
        return;

      case 5:
        c = b.stateNode;

        if (null != c) {
          d = b.memoizedProps;
          var e = null !== a ? a.memoizedProps : d;
          a = b.type;
          var f = b.updateQueue;
          b.updateQueue = null;

          if (null !== f) {
            c[xf] = d;
            "input" === a && "radio" === d.type && null != d.name && $a(c, d);
            wb(a, e);
            b = wb(a, d);

            for (e = 0; e < f.length; e += 2) {
              var g = f[e],
                  h = f[e + 1];
              "style" === g ? tb(c, h) : "dangerouslySetInnerHTML" === g ? ob(c, h) : "children" === g ? pb(c, h) : qa(c, g, h, b);
            }

            switch (a) {
              case "input":
                ab(c, d);
                break;

              case "textarea":
                ib(c, d);
                break;

              case "select":
                a = c._wrapperState.wasMultiple, c._wrapperState.wasMultiple = !!d.multiple, f = d.value, null != f ? fb(c, !!d.multiple, f, !1) : a !== !!d.multiple && (null != d.defaultValue ? fb(c, !!d.multiple, d.defaultValue, !0) : fb(c, !!d.multiple, d.multiple ? [] : "", !1));
            }
          }
        }

        return;

      case 6:
        if (null === b.stateNode) throw Error(y$2(162));
        b.stateNode.nodeValue = b.memoizedProps;
        return;

      case 3:
        c = b.stateNode;
        c.hydrate && (c.hydrate = !1, Cc(c.containerInfo));
        return;

      case 12:
        return;

      case 13:
        null !== b.memoizedState && (jj = O$1(), aj(b.child, !0));
        kj(b);
        return;

      case 19:
        kj(b);
        return;

      case 17:
        return;

      case 23:
      case 24:
        aj(b, null !== b.memoizedState);
        return;
    }

    throw Error(y$2(163));
  }

  function kj(a) {
    var b = a.updateQueue;

    if (null !== b) {
      a.updateQueue = null;
      var c = a.stateNode;
      null === c && (c = a.stateNode = new Ui());
      b.forEach(function (b) {
        var d = lj.bind(null, a, b);
        c.has(b) || (c.add(b), b.then(d, d));
      });
    }
  }

  function mj(a, b) {
    return null !== a && (a = a.memoizedState, null === a || null !== a.dehydrated) ? (b = b.memoizedState, null !== b && null === b.dehydrated) : !1;
  }

  var nj = Math.ceil,
      oj = ra.ReactCurrentDispatcher,
      pj = ra.ReactCurrentOwner,
      X$1 = 0,
      U$1 = null,
      Y = null,
      W$1 = 0,
      qj = 0,
      rj = Bf(0),
      V = 0,
      sj = null,
      tj = 0,
      Dg = 0,
      Hi = 0,
      uj = 0,
      vj = null,
      jj = 0,
      Ji = Infinity;

  function wj() {
    Ji = O$1() + 500;
  }

  var Z$1 = null,
      Qi = !1,
      Ri = null,
      Ti = null,
      xj = !1,
      yj = null,
      zj = 90,
      Aj = [],
      Bj = [],
      Cj = null,
      Dj = 0,
      Ej = null,
      Fj = -1,
      Gj = 0,
      Hj = 0,
      Ij = null,
      Jj = !1;

  function Hg() {
    return 0 !== (X$1 & 48) ? O$1() : -1 !== Fj ? Fj : Fj = O$1();
  }

  function Ig(a) {
    a = a.mode;
    if (0 === (a & 2)) return 1;
    if (0 === (a & 4)) return 99 === eg() ? 1 : 2;
    0 === Gj && (Gj = tj);

    if (0 !== kg.transition) {
      0 !== Hj && (Hj = null !== vj ? vj.pendingLanes : 0);
      a = Gj;
      var b = 4186112 & ~Hj;
      b &= -b;
      0 === b && (a = 4186112 & ~a, b = a & -a, 0 === b && (b = 8192));
      return b;
    }

    a = eg();
    0 !== (X$1 & 4) && 98 === a ? a = Xc(12, Gj) : (a = Sc(a), a = Xc(a, Gj));
    return a;
  }

  function Jg(a, b, c) {
    if (50 < Dj) throw Dj = 0, Ej = null, Error(y$2(185));
    a = Kj(a, b);
    if (null === a) return null;
    $c(a, b, c);
    a === U$1 && (Hi |= b, 4 === V && Ii(a, W$1));
    var d = eg();
    1 === b ? 0 !== (X$1 & 8) && 0 === (X$1 & 48) ? Lj(a) : (Mj(a, c), 0 === X$1 && (wj(), ig())) : (0 === (X$1 & 4) || 98 !== d && 99 !== d || (null === Cj ? Cj = new Set([a]) : Cj.add(a)), Mj(a, c));
    vj = a;
  }

  function Kj(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    null !== c && (c.lanes |= b);
    c = a;

    for (a = a.return; null !== a;) a.childLanes |= b, c = a.alternate, null !== c && (c.childLanes |= b), c = a, a = a.return;

    return 3 === c.tag ? c.stateNode : null;
  }

  function Mj(a, b) {
    for (var c = a.callbackNode, d = a.suspendedLanes, e = a.pingedLanes, f = a.expirationTimes, g = a.pendingLanes; 0 < g;) {
      var h = 31 - Vc(g),
          k = 1 << h,
          l = f[h];

      if (-1 === l) {
        if (0 === (k & d) || 0 !== (k & e)) {
          l = b;
          Rc(k);
          var n = F$2;
          f[h] = 10 <= n ? l + 250 : 6 <= n ? l + 5E3 : -1;
        }
      } else l <= b && (a.expiredLanes |= k);

      g &= ~k;
    }

    d = Uc(a, a === U$1 ? W$1 : 0);
    b = F$2;
    if (0 === d) null !== c && (c !== Zf && Pf(c), a.callbackNode = null, a.callbackPriority = 0);else {
      if (null !== c) {
        if (a.callbackPriority === b) return;
        c !== Zf && Pf(c);
      }

      15 === b ? (c = Lj.bind(null, a), null === ag ? (ag = [c], bg = Of(Uf, jg)) : ag.push(c), c = Zf) : 14 === b ? c = hg(99, Lj.bind(null, a)) : (c = Tc(b), c = hg(c, Nj.bind(null, a)));
      a.callbackPriority = b;
      a.callbackNode = c;
    }
  }

  function Nj(a) {
    Fj = -1;
    Hj = Gj = 0;
    if (0 !== (X$1 & 48)) throw Error(y$2(327));
    var b = a.callbackNode;
    if (Oj() && a.callbackNode !== b) return null;
    var c = Uc(a, a === U$1 ? W$1 : 0);
    if (0 === c) return null;
    var d = c;
    var e = X$1;
    X$1 |= 16;
    var f = Pj();
    if (U$1 !== a || W$1 !== d) wj(), Qj(a, d);

    do try {
      Rj();
      break;
    } catch (h) {
      Sj(a, h);
    } while (1);

    qg();
    oj.current = f;
    X$1 = e;
    null !== Y ? d = 0 : (U$1 = null, W$1 = 0, d = V);
    if (0 !== (tj & Hi)) Qj(a, 0);else if (0 !== d) {
      2 === d && (X$1 |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), c = Wc(a), 0 !== c && (d = Tj(a, c)));
      if (1 === d) throw b = sj, Qj(a, 0), Ii(a, c), Mj(a, O$1()), b;
      a.finishedWork = a.current.alternate;
      a.finishedLanes = c;

      switch (d) {
        case 0:
        case 1:
          throw Error(y$2(345));

        case 2:
          Uj(a);
          break;

        case 3:
          Ii(a, c);

          if ((c & 62914560) === c && (d = jj + 500 - O$1(), 10 < d)) {
            if (0 !== Uc(a, 0)) break;
            e = a.suspendedLanes;

            if ((e & c) !== c) {
              Hg();
              a.pingedLanes |= a.suspendedLanes & e;
              break;
            }

            a.timeoutHandle = of$1(Uj.bind(null, a), d);
            break;
          }

          Uj(a);
          break;

        case 4:
          Ii(a, c);
          if ((c & 4186112) === c) break;
          d = a.eventTimes;

          for (e = -1; 0 < c;) {
            var g = 31 - Vc(c);
            f = 1 << g;
            g = d[g];
            g > e && (e = g);
            c &= ~f;
          }

          c = e;
          c = O$1() - c;
          c = (120 > c ? 120 : 480 > c ? 480 : 1080 > c ? 1080 : 1920 > c ? 1920 : 3E3 > c ? 3E3 : 4320 > c ? 4320 : 1960 * nj(c / 1960)) - c;

          if (10 < c) {
            a.timeoutHandle = of$1(Uj.bind(null, a), c);
            break;
          }

          Uj(a);
          break;

        case 5:
          Uj(a);
          break;

        default:
          throw Error(y$2(329));
      }
    }
    Mj(a, O$1());
    return a.callbackNode === b ? Nj.bind(null, a) : null;
  }

  function Ii(a, b) {
    b &= ~uj;
    b &= ~Hi;
    a.suspendedLanes |= b;
    a.pingedLanes &= ~b;

    for (a = a.expirationTimes; 0 < b;) {
      var c = 31 - Vc(b),
          d = 1 << c;
      a[c] = -1;
      b &= ~d;
    }
  }

  function Lj(a) {
    if (0 !== (X$1 & 48)) throw Error(y$2(327));
    Oj();

    if (a === U$1 && 0 !== (a.expiredLanes & W$1)) {
      var b = W$1;
      var c = Tj(a, b);
      0 !== (tj & Hi) && (b = Uc(a, b), c = Tj(a, b));
    } else b = Uc(a, 0), c = Tj(a, b);

    0 !== a.tag && 2 === c && (X$1 |= 64, a.hydrate && (a.hydrate = !1, qf(a.containerInfo)), b = Wc(a), 0 !== b && (c = Tj(a, b)));
    if (1 === c) throw c = sj, Qj(a, 0), Ii(a, b), Mj(a, O$1()), c;
    a.finishedWork = a.current.alternate;
    a.finishedLanes = b;
    Uj(a);
    Mj(a, O$1());
    return null;
  }

  function Vj() {
    if (null !== Cj) {
      var a = Cj;
      Cj = null;
      a.forEach(function (a) {
        a.expiredLanes |= 24 & a.pendingLanes;
        Mj(a, O$1());
      });
    }

    ig();
  }

  function Wj(a, b) {
    var c = X$1;
    X$1 |= 1;

    try {
      return a(b);
    } finally {
      X$1 = c, 0 === X$1 && (wj(), ig());
    }
  }

  function Xj(a, b) {
    var c = X$1;
    X$1 &= -2;
    X$1 |= 8;

    try {
      return a(b);
    } finally {
      X$1 = c, 0 === X$1 && (wj(), ig());
    }
  }

  function ni(a, b) {
    I$2(rj, qj);
    qj |= b;
    tj |= b;
  }

  function Ki() {
    qj = rj.current;
    H$2(rj);
  }

  function Qj(a, b) {
    a.finishedWork = null;
    a.finishedLanes = 0;
    var c = a.timeoutHandle;
    -1 !== c && (a.timeoutHandle = -1, pf(c));
    if (null !== Y) for (c = Y.return; null !== c;) {
      var d = c;

      switch (d.tag) {
        case 1:
          d = d.type.childContextTypes;
          null !== d && void 0 !== d && Gf();
          break;

        case 3:
          fh();
          H$2(N$1);
          H$2(M$1);
          uh();
          break;

        case 5:
          hh(d);
          break;

        case 4:
          fh();
          break;

        case 13:
          H$2(P$1);
          break;

        case 19:
          H$2(P$1);
          break;

        case 10:
          rg(d);
          break;

        case 23:
        case 24:
          Ki();
      }

      c = c.return;
    }
    U$1 = a;
    Y = Tg(a.current, null);
    W$1 = qj = tj = b;
    V = 0;
    sj = null;
    uj = Hi = Dg = 0;
  }

  function Sj(a, b) {
    do {
      var c = Y;

      try {
        qg();
        vh.current = Gh;

        if (yh) {
          for (var d = R$1.memoizedState; null !== d;) {
            var e = d.queue;
            null !== e && (e.pending = null);
            d = d.next;
          }

          yh = !1;
        }

        xh = 0;
        T = S$1 = R$1 = null;
        zh = !1;
        pj.current = null;

        if (null === c || null === c.return) {
          V = 1;
          sj = b;
          Y = null;
          break;
        }

        a: {
          var f = a,
              g = c.return,
              h = c,
              k = b;
          b = W$1;
          h.flags |= 2048;
          h.firstEffect = h.lastEffect = null;

          if (null !== k && "object" === typeof k && "function" === typeof k.then) {
            var l = k;

            if (0 === (h.mode & 2)) {
              var n = h.alternate;
              n ? (h.updateQueue = n.updateQueue, h.memoizedState = n.memoizedState, h.lanes = n.lanes) : (h.updateQueue = null, h.memoizedState = null);
            }

            var A = 0 !== (P$1.current & 1),
                p = g;

            do {
              var C;

              if (C = 13 === p.tag) {
                var x = p.memoizedState;
                if (null !== x) C = null !== x.dehydrated ? !0 : !1;else {
                  var w = p.memoizedProps;
                  C = void 0 === w.fallback ? !1 : !0 !== w.unstable_avoidThisFallback ? !0 : A ? !1 : !0;
                }
              }

              if (C) {
                var z = p.updateQueue;

                if (null === z) {
                  var u = new Set();
                  u.add(l);
                  p.updateQueue = u;
                } else z.add(l);

                if (0 === (p.mode & 2)) {
                  p.flags |= 64;
                  h.flags |= 16384;
                  h.flags &= -2981;
                  if (1 === h.tag) if (null === h.alternate) h.tag = 17;else {
                    var t = zg(-1, 1);
                    t.tag = 2;
                    Ag(h, t);
                  }
                  h.lanes |= 1;
                  break a;
                }

                k = void 0;
                h = b;
                var q = f.pingCache;
                null === q ? (q = f.pingCache = new Oi(), k = new Set(), q.set(l, k)) : (k = q.get(l), void 0 === k && (k = new Set(), q.set(l, k)));

                if (!k.has(h)) {
                  k.add(h);
                  var v = Yj.bind(null, f, l, h);
                  l.then(v, v);
                }

                p.flags |= 4096;
                p.lanes = b;
                break a;
              }

              p = p.return;
            } while (null !== p);

            k = Error((Ra(h.type) || "A React component") + " suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.");
          }

          5 !== V && (V = 2);
          k = Mi(k, h);
          p = g;

          do {
            switch (p.tag) {
              case 3:
                f = k;
                p.flags |= 4096;
                b &= -b;
                p.lanes |= b;
                var J = Pi(p, f, b);
                Bg(p, J);
                break a;

              case 1:
                f = k;
                var K = p.type,
                    Q = p.stateNode;

                if (0 === (p.flags & 64) && ("function" === typeof K.getDerivedStateFromError || null !== Q && "function" === typeof Q.componentDidCatch && (null === Ti || !Ti.has(Q)))) {
                  p.flags |= 4096;
                  b &= -b;
                  p.lanes |= b;
                  var L = Si(p, f, b);
                  Bg(p, L);
                  break a;
                }

            }

            p = p.return;
          } while (null !== p);
        }

        Zj(c);
      } catch (va) {
        b = va;
        Y === c && null !== c && (Y = c = c.return);
        continue;
      }

      break;
    } while (1);
  }

  function Pj() {
    var a = oj.current;
    oj.current = Gh;
    return null === a ? Gh : a;
  }

  function Tj(a, b) {
    var c = X$1;
    X$1 |= 16;
    var d = Pj();
    U$1 === a && W$1 === b || Qj(a, b);

    do try {
      ak();
      break;
    } catch (e) {
      Sj(a, e);
    } while (1);

    qg();
    X$1 = c;
    oj.current = d;
    if (null !== Y) throw Error(y$2(261));
    U$1 = null;
    W$1 = 0;
    return V;
  }

  function ak() {
    for (; null !== Y;) bk(Y);
  }

  function Rj() {
    for (; null !== Y && !Qf();) bk(Y);
  }

  function bk(a) {
    var b = ck(a.alternate, a, qj);
    a.memoizedProps = a.pendingProps;
    null === b ? Zj(a) : Y = b;
    pj.current = null;
  }

  function Zj(a) {
    var b = a;

    do {
      var c = b.alternate;
      a = b.return;

      if (0 === (b.flags & 2048)) {
        c = Gi(c, b, qj);

        if (null !== c) {
          Y = c;
          return;
        }

        c = b;

        if (24 !== c.tag && 23 !== c.tag || null === c.memoizedState || 0 !== (qj & 1073741824) || 0 === (c.mode & 4)) {
          for (var d = 0, e = c.child; null !== e;) d |= e.lanes | e.childLanes, e = e.sibling;

          c.childLanes = d;
        }

        null !== a && 0 === (a.flags & 2048) && (null === a.firstEffect && (a.firstEffect = b.firstEffect), null !== b.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = b.firstEffect), a.lastEffect = b.lastEffect), 1 < b.flags && (null !== a.lastEffect ? a.lastEffect.nextEffect = b : a.firstEffect = b, a.lastEffect = b));
      } else {
        c = Li(b);

        if (null !== c) {
          c.flags &= 2047;
          Y = c;
          return;
        }

        null !== a && (a.firstEffect = a.lastEffect = null, a.flags |= 2048);
      }

      b = b.sibling;

      if (null !== b) {
        Y = b;
        return;
      }

      Y = b = a;
    } while (null !== b);

    0 === V && (V = 5);
  }

  function Uj(a) {
    var b = eg();
    gg(99, dk.bind(null, a, b));
    return null;
  }

  function dk(a, b) {
    do Oj(); while (null !== yj);

    if (0 !== (X$1 & 48)) throw Error(y$2(327));
    var c = a.finishedWork;
    if (null === c) return null;
    a.finishedWork = null;
    a.finishedLanes = 0;
    if (c === a.current) throw Error(y$2(177));
    a.callbackNode = null;
    var d = c.lanes | c.childLanes,
        e = d,
        f = a.pendingLanes & ~e;
    a.pendingLanes = e;
    a.suspendedLanes = 0;
    a.pingedLanes = 0;
    a.expiredLanes &= e;
    a.mutableReadLanes &= e;
    a.entangledLanes &= e;
    e = a.entanglements;

    for (var g = a.eventTimes, h = a.expirationTimes; 0 < f;) {
      var k = 31 - Vc(f),
          l = 1 << k;
      e[k] = 0;
      g[k] = -1;
      h[k] = -1;
      f &= ~l;
    }

    null !== Cj && 0 === (d & 24) && Cj.has(a) && Cj.delete(a);
    a === U$1 && (Y = U$1 = null, W$1 = 0);
    1 < c.flags ? null !== c.lastEffect ? (c.lastEffect.nextEffect = c, d = c.firstEffect) : d = c : d = c.firstEffect;

    if (null !== d) {
      e = X$1;
      X$1 |= 32;
      pj.current = null;
      kf = fd;
      g = Ne();

      if (Oe(g)) {
        if ("selectionStart" in g) h = {
          start: g.selectionStart,
          end: g.selectionEnd
        };else a: if (h = (h = g.ownerDocument) && h.defaultView || window, (l = h.getSelection && h.getSelection()) && 0 !== l.rangeCount) {
          h = l.anchorNode;
          f = l.anchorOffset;
          k = l.focusNode;
          l = l.focusOffset;

          try {
            h.nodeType, k.nodeType;
          } catch (va) {
            h = null;
            break a;
          }

          var n = 0,
              A = -1,
              p = -1,
              C = 0,
              x = 0,
              w = g,
              z = null;

          b: for (;;) {
            for (var u;;) {
              w !== h || 0 !== f && 3 !== w.nodeType || (A = n + f);
              w !== k || 0 !== l && 3 !== w.nodeType || (p = n + l);
              3 === w.nodeType && (n += w.nodeValue.length);
              if (null === (u = w.firstChild)) break;
              z = w;
              w = u;
            }

            for (;;) {
              if (w === g) break b;
              z === h && ++C === f && (A = n);
              z === k && ++x === l && (p = n);
              if (null !== (u = w.nextSibling)) break;
              w = z;
              z = w.parentNode;
            }

            w = u;
          }

          h = -1 === A || -1 === p ? null : {
            start: A,
            end: p
          };
        } else h = null;
        h = h || {
          start: 0,
          end: 0
        };
      } else h = null;

      lf = {
        focusedElem: g,
        selectionRange: h
      };
      fd = !1;
      Ij = null;
      Jj = !1;
      Z$1 = d;

      do try {
        ek();
      } catch (va) {
        if (null === Z$1) throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      } while (null !== Z$1);

      Ij = null;
      Z$1 = d;

      do try {
        for (g = a; null !== Z$1;) {
          var t = Z$1.flags;
          t & 16 && pb(Z$1.stateNode, "");

          if (t & 128) {
            var q = Z$1.alternate;

            if (null !== q) {
              var v = q.ref;
              null !== v && ("function" === typeof v ? v(null) : v.current = null);
            }
          }

          switch (t & 1038) {
            case 2:
              fj(Z$1);
              Z$1.flags &= -3;
              break;

            case 6:
              fj(Z$1);
              Z$1.flags &= -3;
              ij(Z$1.alternate, Z$1);
              break;

            case 1024:
              Z$1.flags &= -1025;
              break;

            case 1028:
              Z$1.flags &= -1025;
              ij(Z$1.alternate, Z$1);
              break;

            case 4:
              ij(Z$1.alternate, Z$1);
              break;

            case 8:
              h = Z$1;
              cj(g, h);
              var J = h.alternate;
              dj(h);
              null !== J && dj(J);
          }

          Z$1 = Z$1.nextEffect;
        }
      } catch (va) {
        if (null === Z$1) throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      } while (null !== Z$1);

      v = lf;
      q = Ne();
      t = v.focusedElem;
      g = v.selectionRange;

      if (q !== t && t && t.ownerDocument && Me(t.ownerDocument.documentElement, t)) {
        null !== g && Oe(t) && (q = g.start, v = g.end, void 0 === v && (v = q), "selectionStart" in t ? (t.selectionStart = q, t.selectionEnd = Math.min(v, t.value.length)) : (v = (q = t.ownerDocument || document) && q.defaultView || window, v.getSelection && (v = v.getSelection(), h = t.textContent.length, J = Math.min(g.start, h), g = void 0 === g.end ? J : Math.min(g.end, h), !v.extend && J > g && (h = g, g = J, J = h), h = Le(t, J), f = Le(t, g), h && f && (1 !== v.rangeCount || v.anchorNode !== h.node || v.anchorOffset !== h.offset || v.focusNode !== f.node || v.focusOffset !== f.offset) && (q = q.createRange(), q.setStart(h.node, h.offset), v.removeAllRanges(), J > g ? (v.addRange(q), v.extend(f.node, f.offset)) : (q.setEnd(f.node, f.offset), v.addRange(q))))));
        q = [];

        for (v = t; v = v.parentNode;) 1 === v.nodeType && q.push({
          element: v,
          left: v.scrollLeft,
          top: v.scrollTop
        });

        "function" === typeof t.focus && t.focus();

        for (t = 0; t < q.length; t++) v = q[t], v.element.scrollLeft = v.left, v.element.scrollTop = v.top;
      }

      fd = !!kf;
      lf = kf = null;
      a.current = c;
      Z$1 = d;

      do try {
        for (t = a; null !== Z$1;) {
          var K = Z$1.flags;
          K & 36 && Yi(t, Z$1.alternate, Z$1);

          if (K & 128) {
            q = void 0;
            var Q = Z$1.ref;

            if (null !== Q) {
              var L = Z$1.stateNode;

              switch (Z$1.tag) {
                case 5:
                  q = L;
                  break;

                default:
                  q = L;
              }

              "function" === typeof Q ? Q(q) : Q.current = q;
            }
          }

          Z$1 = Z$1.nextEffect;
        }
      } catch (va) {
        if (null === Z$1) throw Error(y$2(330));
        Wi(Z$1, va);
        Z$1 = Z$1.nextEffect;
      } while (null !== Z$1);

      Z$1 = null;
      $f();
      X$1 = e;
    } else a.current = c;

    if (xj) xj = !1, yj = a, zj = b;else for (Z$1 = d; null !== Z$1;) b = Z$1.nextEffect, Z$1.nextEffect = null, Z$1.flags & 8 && (K = Z$1, K.sibling = null, K.stateNode = null), Z$1 = b;
    d = a.pendingLanes;
    0 === d && (Ti = null);
    1 === d ? a === Ej ? Dj++ : (Dj = 0, Ej = a) : Dj = 0;
    c = c.stateNode;
    if (Mf && "function" === typeof Mf.onCommitFiberRoot) try {
      Mf.onCommitFiberRoot(Lf, c, void 0, 64 === (c.current.flags & 64));
    } catch (va) {}
    Mj(a, O$1());
    if (Qi) throw Qi = !1, a = Ri, Ri = null, a;
    if (0 !== (X$1 & 8)) return null;
    ig();
    return null;
  }

  function ek() {
    for (; null !== Z$1;) {
      var a = Z$1.alternate;
      Jj || null === Ij || (0 !== (Z$1.flags & 8) ? dc(Z$1, Ij) && (Jj = !0) : 13 === Z$1.tag && mj(a, Z$1) && dc(Z$1, Ij) && (Jj = !0));
      var b = Z$1.flags;
      0 !== (b & 256) && Xi(a, Z$1);
      0 === (b & 512) || xj || (xj = !0, hg(97, function () {
        Oj();
        return null;
      }));
      Z$1 = Z$1.nextEffect;
    }
  }

  function Oj() {
    if (90 !== zj) {
      var a = 97 < zj ? 97 : zj;
      zj = 90;
      return gg(a, fk);
    }

    return !1;
  }

  function $i(a, b) {
    Aj.push(b, a);
    xj || (xj = !0, hg(97, function () {
      Oj();
      return null;
    }));
  }

  function Zi(a, b) {
    Bj.push(b, a);
    xj || (xj = !0, hg(97, function () {
      Oj();
      return null;
    }));
  }

  function fk() {
    if (null === yj) return !1;
    var a = yj;
    yj = null;
    if (0 !== (X$1 & 48)) throw Error(y$2(331));
    var b = X$1;
    X$1 |= 32;
    var c = Bj;
    Bj = [];

    for (var d = 0; d < c.length; d += 2) {
      var e = c[d],
          f = c[d + 1],
          g = e.destroy;
      e.destroy = void 0;
      if ("function" === typeof g) try {
        g();
      } catch (k) {
        if (null === f) throw Error(y$2(330));
        Wi(f, k);
      }
    }

    c = Aj;
    Aj = [];

    for (d = 0; d < c.length; d += 2) {
      e = c[d];
      f = c[d + 1];

      try {
        var h = e.create;
        e.destroy = h();
      } catch (k) {
        if (null === f) throw Error(y$2(330));
        Wi(f, k);
      }
    }

    for (h = a.current.firstEffect; null !== h;) a = h.nextEffect, h.nextEffect = null, h.flags & 8 && (h.sibling = null, h.stateNode = null), h = a;

    X$1 = b;
    ig();
    return !0;
  }

  function gk(a, b, c) {
    b = Mi(c, b);
    b = Pi(a, b, 1);
    Ag(a, b);
    b = Hg();
    a = Kj(a, 1);
    null !== a && ($c(a, 1, b), Mj(a, b));
  }

  function Wi(a, b) {
    if (3 === a.tag) gk(a, a, b);else for (var c = a.return; null !== c;) {
      if (3 === c.tag) {
        gk(c, a, b);
        break;
      } else if (1 === c.tag) {
        var d = c.stateNode;

        if ("function" === typeof c.type.getDerivedStateFromError || "function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) {
          a = Mi(b, a);
          var e = Si(c, a, 1);
          Ag(c, e);
          e = Hg();
          c = Kj(c, 1);
          if (null !== c) $c(c, 1, e), Mj(c, e);else if ("function" === typeof d.componentDidCatch && (null === Ti || !Ti.has(d))) try {
            d.componentDidCatch(b, a);
          } catch (f) {}
          break;
        }
      }

      c = c.return;
    }
  }

  function Yj(a, b, c) {
    var d = a.pingCache;
    null !== d && d.delete(b);
    b = Hg();
    a.pingedLanes |= a.suspendedLanes & c;
    U$1 === a && (W$1 & c) === c && (4 === V || 3 === V && (W$1 & 62914560) === W$1 && 500 > O$1() - jj ? Qj(a, 0) : uj |= c);
    Mj(a, b);
  }

  function lj(a, b) {
    var c = a.stateNode;
    null !== c && c.delete(b);
    b = 0;
    0 === b && (b = a.mode, 0 === (b & 2) ? b = 1 : 0 === (b & 4) ? b = 99 === eg() ? 1 : 2 : (0 === Gj && (Gj = tj), b = Yc(62914560 & ~Gj), 0 === b && (b = 4194304)));
    c = Hg();
    a = Kj(a, b);
    null !== a && ($c(a, b, c), Mj(a, c));
  }

  var ck;

  ck = function (a, b, c) {
    var d = b.lanes;
    if (null !== a) {
      if (a.memoizedProps !== b.pendingProps || N$1.current) ug = !0;else if (0 !== (c & d)) ug = 0 !== (a.flags & 16384) ? !0 : !1;else {
        ug = !1;

        switch (b.tag) {
          case 3:
            ri(b);
            sh();
            break;

          case 5:
            gh(b);
            break;

          case 1:
            Ff(b.type) && Jf(b);
            break;

          case 4:
            eh(b, b.stateNode.containerInfo);
            break;

          case 10:
            d = b.memoizedProps.value;
            var e = b.type._context;
            I$2(mg, e._currentValue);
            e._currentValue = d;
            break;

          case 13:
            if (null !== b.memoizedState) {
              if (0 !== (c & b.child.childLanes)) return ti(a, b, c);
              I$2(P$1, P$1.current & 1);
              b = hi(a, b, c);
              return null !== b ? b.sibling : null;
            }

            I$2(P$1, P$1.current & 1);
            break;

          case 19:
            d = 0 !== (c & b.childLanes);

            if (0 !== (a.flags & 64)) {
              if (d) return Ai(a, b, c);
              b.flags |= 64;
            }

            e = b.memoizedState;
            null !== e && (e.rendering = null, e.tail = null, e.lastEffect = null);
            I$2(P$1, P$1.current);
            if (d) break;else return null;

          case 23:
          case 24:
            return b.lanes = 0, mi(a, b, c);
        }

        return hi(a, b, c);
      }
    } else ug = !1;
    b.lanes = 0;

    switch (b.tag) {
      case 2:
        d = b.type;
        null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
        a = b.pendingProps;
        e = Ef(b, M$1.current);
        tg(b, c);
        e = Ch(null, b, d, a, e, c);
        b.flags |= 1;

        if ("object" === typeof e && null !== e && "function" === typeof e.render && void 0 === e.$$typeof) {
          b.tag = 1;
          b.memoizedState = null;
          b.updateQueue = null;

          if (Ff(d)) {
            var f = !0;
            Jf(b);
          } else f = !1;

          b.memoizedState = null !== e.state && void 0 !== e.state ? e.state : null;
          xg(b);
          var g = d.getDerivedStateFromProps;
          "function" === typeof g && Gg(b, d, g, a);
          e.updater = Kg;
          b.stateNode = e;
          e._reactInternals = b;
          Og(b, d, a, c);
          b = qi(null, b, d, !0, f, c);
        } else b.tag = 0, fi(null, b, e, c), b = b.child;

        return b;

      case 16:
        e = b.elementType;

        a: {
          null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2);
          a = b.pendingProps;
          f = e._init;
          e = f(e._payload);
          b.type = e;
          f = b.tag = hk(e);
          a = lg(e, a);

          switch (f) {
            case 0:
              b = li(null, b, e, a, c);
              break a;

            case 1:
              b = pi(null, b, e, a, c);
              break a;

            case 11:
              b = gi(null, b, e, a, c);
              break a;

            case 14:
              b = ii(null, b, e, lg(e.type, a), d, c);
              break a;
          }

          throw Error(y$2(306, e, ""));
        }

        return b;

      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), li(a, b, d, e, c);

      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), pi(a, b, d, e, c);

      case 3:
        ri(b);
        d = b.updateQueue;
        if (null === a || null === d) throw Error(y$2(282));
        d = b.pendingProps;
        e = b.memoizedState;
        e = null !== e ? e.element : null;
        yg(a, b);
        Cg(b, d, null, c);
        d = b.memoizedState.element;
        if (d === e) sh(), b = hi(a, b, c);else {
          e = b.stateNode;
          if (f = e.hydrate) kh = rf(b.stateNode.containerInfo.firstChild), jh = b, f = lh = !0;

          if (f) {
            a = e.mutableSourceEagerHydrationData;
            if (null != a) for (e = 0; e < a.length; e += 2) f = a[e], f._workInProgressVersionPrimary = a[e + 1], th.push(f);
            c = Zg(b, null, d, c);

            for (b.child = c; c;) c.flags = c.flags & -3 | 1024, c = c.sibling;
          } else fi(a, b, d, c), sh();

          b = b.child;
        }
        return b;

      case 5:
        return gh(b), null === a && ph(b), d = b.type, e = b.pendingProps, f = null !== a ? a.memoizedProps : null, g = e.children, nf(d, e) ? g = null : null !== f && nf(d, f) && (b.flags |= 16), oi(a, b), fi(a, b, g, c), b.child;

      case 6:
        return null === a && ph(b), null;

      case 13:
        return ti(a, b, c);

      case 4:
        return eh(b, b.stateNode.containerInfo), d = b.pendingProps, null === a ? b.child = Yg(b, null, d, c) : fi(a, b, d, c), b.child;

      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), gi(a, b, d, e, c);

      case 7:
        return fi(a, b, b.pendingProps, c), b.child;

      case 8:
        return fi(a, b, b.pendingProps.children, c), b.child;

      case 12:
        return fi(a, b, b.pendingProps.children, c), b.child;

      case 10:
        a: {
          d = b.type._context;
          e = b.pendingProps;
          g = b.memoizedProps;
          f = e.value;
          var h = b.type._context;
          I$2(mg, h._currentValue);
          h._currentValue = f;
          if (null !== g) if (h = g.value, f = He(h, f) ? 0 : ("function" === typeof d._calculateChangedBits ? d._calculateChangedBits(h, f) : 1073741823) | 0, 0 === f) {
            if (g.children === e.children && !N$1.current) {
              b = hi(a, b, c);
              break a;
            }
          } else for (h = b.child, null !== h && (h.return = b); null !== h;) {
            var k = h.dependencies;

            if (null !== k) {
              g = h.child;

              for (var l = k.firstContext; null !== l;) {
                if (l.context === d && 0 !== (l.observedBits & f)) {
                  1 === h.tag && (l = zg(-1, c & -c), l.tag = 2, Ag(h, l));
                  h.lanes |= c;
                  l = h.alternate;
                  null !== l && (l.lanes |= c);
                  sg(h.return, c);
                  k.lanes |= c;
                  break;
                }

                l = l.next;
              }
            } else g = 10 === h.tag ? h.type === b.type ? null : h.child : h.child;

            if (null !== g) g.return = h;else for (g = h; null !== g;) {
              if (g === b) {
                g = null;
                break;
              }

              h = g.sibling;

              if (null !== h) {
                h.return = g.return;
                g = h;
                break;
              }

              g = g.return;
            }
            h = g;
          }
          fi(a, b, e.children, c);
          b = b.child;
        }

        return b;

      case 9:
        return e = b.type, f = b.pendingProps, d = f.children, tg(b, c), e = vg(e, f.unstable_observedBits), d = d(e), b.flags |= 1, fi(a, b, d, c), b.child;

      case 14:
        return e = b.type, f = lg(e, b.pendingProps), f = lg(e.type, f), ii(a, b, e, f, d, c);

      case 15:
        return ki(a, b, b.type, b.pendingProps, d, c);

      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : lg(d, e), null !== a && (a.alternate = null, b.alternate = null, b.flags |= 2), b.tag = 1, Ff(d) ? (a = !0, Jf(b)) : a = !1, tg(b, c), Mg(b, d, e), Og(b, d, e, c), qi(null, b, d, !0, a, c);

      case 19:
        return Ai(a, b, c);

      case 23:
        return mi(a, b, c);

      case 24:
        return mi(a, b, c);
    }

    throw Error(y$2(156, b.tag));
  };

  function ik(a, b, c, d) {
    this.tag = a;
    this.key = c;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.ref = null;
    this.pendingProps = b;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = d;
    this.flags = 0;
    this.lastEffect = this.firstEffect = this.nextEffect = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }

  function nh(a, b, c, d) {
    return new ik(a, b, c, d);
  }

  function ji(a) {
    a = a.prototype;
    return !(!a || !a.isReactComponent);
  }

  function hk(a) {
    if ("function" === typeof a) return ji(a) ? 1 : 0;

    if (void 0 !== a && null !== a) {
      a = a.$$typeof;
      if (a === Aa) return 11;
      if (a === Da) return 14;
    }

    return 2;
  }

  function Tg(a, b) {
    var c = a.alternate;
    null === c ? (c = nh(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.nextEffect = null, c.firstEffect = null, c.lastEffect = null);
    c.childLanes = a.childLanes;
    c.lanes = a.lanes;
    c.child = a.child;
    c.memoizedProps = a.memoizedProps;
    c.memoizedState = a.memoizedState;
    c.updateQueue = a.updateQueue;
    b = a.dependencies;
    c.dependencies = null === b ? null : {
      lanes: b.lanes,
      firstContext: b.firstContext
    };
    c.sibling = a.sibling;
    c.index = a.index;
    c.ref = a.ref;
    return c;
  }

  function Vg(a, b, c, d, e, f) {
    var g = 2;
    d = a;
    if ("function" === typeof a) ji(a) && (g = 1);else if ("string" === typeof a) g = 5;else a: switch (a) {
      case ua:
        return Xg(c.children, e, f, b);

      case Ha:
        g = 8;
        e |= 16;
        break;

      case wa:
        g = 8;
        e |= 1;
        break;

      case xa:
        return a = nh(12, c, b, e | 8), a.elementType = xa, a.type = xa, a.lanes = f, a;

      case Ba:
        return a = nh(13, c, b, e), a.type = Ba, a.elementType = Ba, a.lanes = f, a;

      case Ca:
        return a = nh(19, c, b, e), a.elementType = Ca, a.lanes = f, a;

      case Ia:
        return vi(c, e, f, b);

      case Ja:
        return a = nh(24, c, b, e), a.elementType = Ja, a.lanes = f, a;

      default:
        if ("object" === typeof a && null !== a) switch (a.$$typeof) {
          case ya:
            g = 10;
            break a;

          case za:
            g = 9;
            break a;

          case Aa:
            g = 11;
            break a;

          case Da:
            g = 14;
            break a;

          case Ea:
            g = 16;
            d = null;
            break a;

          case Fa:
            g = 22;
            break a;
        }
        throw Error(y$2(130, null == a ? a : typeof a, ""));
    }
    b = nh(g, c, b, e);
    b.elementType = a;
    b.type = d;
    b.lanes = f;
    return b;
  }

  function Xg(a, b, c, d) {
    a = nh(7, a, d, b);
    a.lanes = c;
    return a;
  }

  function vi(a, b, c, d) {
    a = nh(23, a, d, b);
    a.elementType = Ia;
    a.lanes = c;
    return a;
  }

  function Ug(a, b, c) {
    a = nh(6, a, null, b);
    a.lanes = c;
    return a;
  }

  function Wg(a, b, c) {
    b = nh(4, null !== a.children ? a.children : [], a.key, b);
    b.lanes = c;
    b.stateNode = {
      containerInfo: a.containerInfo,
      pendingChildren: null,
      implementation: a.implementation
    };
    return b;
  }

  function jk(a, b, c) {
    this.tag = b;
    this.containerInfo = a;
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.pendingContext = this.context = null;
    this.hydrate = c;
    this.callbackNode = null;
    this.callbackPriority = 0;
    this.eventTimes = Zc(0);
    this.expirationTimes = Zc(-1);
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = Zc(0);
    this.mutableSourceEagerHydrationData = null;
  }

  function kk(a, b, c) {
    var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: ta,
      key: null == d ? null : "" + d,
      children: a,
      containerInfo: b,
      implementation: c
    };
  }

  function lk(a, b, c, d) {
    var e = b.current,
        f = Hg(),
        g = Ig(e);

    a: if (c) {
      c = c._reactInternals;

      b: {
        if (Zb(c) !== c || 1 !== c.tag) throw Error(y$2(170));
        var h = c;

        do {
          switch (h.tag) {
            case 3:
              h = h.stateNode.context;
              break b;

            case 1:
              if (Ff(h.type)) {
                h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                break b;
              }

          }

          h = h.return;
        } while (null !== h);

        throw Error(y$2(171));
      }

      if (1 === c.tag) {
        var k = c.type;

        if (Ff(k)) {
          c = If(c, k, h);
          break a;
        }
      }

      c = h;
    } else c = Cf;

    null === b.context ? b.context = c : b.pendingContext = c;
    b = zg(f, g);
    b.payload = {
      element: a
    };
    d = void 0 === d ? null : d;
    null !== d && (b.callback = d);
    Ag(e, b);
    Jg(e, g, f);
    return g;
  }

  function mk(a) {
    a = a.current;
    if (!a.child) return null;

    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;

      default:
        return a.child.stateNode;
    }
  }

  function nk(a, b) {
    a = a.memoizedState;

    if (null !== a && null !== a.dehydrated) {
      var c = a.retryLane;
      a.retryLane = 0 !== c && c < b ? c : b;
    }
  }

  function ok(a, b) {
    nk(a, b);
    (a = a.alternate) && nk(a, b);
  }

  function pk() {
    return null;
  }

  function qk(a, b, c) {
    var d = null != c && null != c.hydrationOptions && c.hydrationOptions.mutableSources || null;
    c = new jk(a, b, null != c && !0 === c.hydrate);
    b = nh(3, null, null, 2 === b ? 7 : 1 === b ? 3 : 0);
    c.current = b;
    b.stateNode = c;
    xg(b);
    a[ff] = c.current;
    cf(8 === a.nodeType ? a.parentNode : a);
    if (d) for (a = 0; a < d.length; a++) {
      b = d[a];
      var e = b._getVersion;
      e = e(b._source);
      null == c.mutableSourceEagerHydrationData ? c.mutableSourceEagerHydrationData = [b, e] : c.mutableSourceEagerHydrationData.push(b, e);
    }
    this._internalRoot = c;
  }

  qk.prototype.render = function (a) {
    lk(a, this._internalRoot, null, null);
  };

  qk.prototype.unmount = function () {
    var a = this._internalRoot,
        b = a.containerInfo;
    lk(null, a, null, function () {
      b[ff] = null;
    });
  };

  function rk(a) {
    return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
  }

  function sk(a, b) {
    b || (b = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null, b = !(!b || 1 !== b.nodeType || !b.hasAttribute("data-reactroot")));
    if (!b) for (var c; c = a.lastChild;) a.removeChild(c);
    return new qk(a, 0, b ? {
      hydrate: !0
    } : void 0);
  }

  function tk(a, b, c, d, e) {
    var f = c._reactRootContainer;

    if (f) {
      var g = f._internalRoot;

      if ("function" === typeof e) {
        var h = e;

        e = function () {
          var a = mk(g);
          h.call(a);
        };
      }

      lk(b, g, a, e);
    } else {
      f = c._reactRootContainer = sk(c, d);
      g = f._internalRoot;

      if ("function" === typeof e) {
        var k = e;

        e = function () {
          var a = mk(g);
          k.call(a);
        };
      }

      Xj(function () {
        lk(b, g, a, e);
      });
    }

    return mk(g);
  }

  ec = function (a) {
    if (13 === a.tag) {
      var b = Hg();
      Jg(a, 4, b);
      ok(a, 4);
    }
  };

  fc = function (a) {
    if (13 === a.tag) {
      var b = Hg();
      Jg(a, 67108864, b);
      ok(a, 67108864);
    }
  };

  gc = function (a) {
    if (13 === a.tag) {
      var b = Hg(),
          c = Ig(a);
      Jg(a, c, b);
      ok(a, c);
    }
  };

  hc = function (a, b) {
    return b();
  };

  yb = function (a, b, c) {
    switch (b) {
      case "input":
        ab(a, c);
        b = c.name;

        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode;) c = c.parentNode;

          c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]');

          for (b = 0; b < c.length; b++) {
            var d = c[b];

            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(y$2(90));
              Wa(d);
              ab(d, e);
            }
          }
        }

        break;

      case "textarea":
        ib(a, c);
        break;

      case "select":
        b = c.value, null != b && fb(a, !!c.multiple, b, !1);
    }
  };

  Gb = Wj;

  Hb = function (a, b, c, d, e) {
    var f = X$1;
    X$1 |= 4;

    try {
      return gg(98, a.bind(null, b, c, d, e));
    } finally {
      X$1 = f, 0 === X$1 && (wj(), ig());
    }
  };

  Ib = function () {
    0 === (X$1 & 49) && (Vj(), Oj());
  };

  Jb = function (a, b) {
    var c = X$1;
    X$1 |= 2;

    try {
      return a(b);
    } finally {
      X$1 = c, 0 === X$1 && (wj(), ig());
    }
  };

  function uk(a, b) {
    var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!rk(b)) throw Error(y$2(200));
    return kk(a, b, null, c);
  }

  var vk = {
    Events: [Cb, ue, Db, Eb, Fb, Oj, {
      current: !1
    }]
  },
      wk = {
    findFiberByHostInstance: wc,
    bundleType: 0,
    version: "17.0.2",
    rendererPackageName: "react-dom"
  };
  var xk = {
    bundleType: wk.bundleType,
    version: wk.version,
    rendererPackageName: wk.rendererPackageName,
    rendererConfig: wk.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ra.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (a) {
      a = cc(a);
      return null === a ? null : a.stateNode;
    },
    findFiberByHostInstance: wk.findFiberByHostInstance || pk,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null
  };

  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var yk = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!yk.isDisabled && yk.supportsFiber) try {
      Lf = yk.inject(xk), Mf = yk;
    } catch (a) {}
  }

  reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vk;
  reactDom_production_min.createPortal = uk;

  reactDom_production_min.findDOMNode = function (a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternals;

    if (void 0 === b) {
      if ("function" === typeof a.render) throw Error(y$2(188));
      throw Error(y$2(268, Object.keys(a)));
    }

    a = cc(b);
    a = null === a ? null : a.stateNode;
    return a;
  };

  reactDom_production_min.flushSync = function (a, b) {
    var c = X$1;
    if (0 !== (c & 48)) return a(b);
    X$1 |= 1;

    try {
      if (a) return gg(99, a.bind(null, b));
    } finally {
      X$1 = c, ig();
    }
  };

  reactDom_production_min.hydrate = function (a, b, c) {
    if (!rk(b)) throw Error(y$2(200));
    return tk(null, a, b, !0, c);
  };

  reactDom_production_min.render = function (a, b, c) {
    if (!rk(b)) throw Error(y$2(200));
    return tk(null, a, b, !1, c);
  };

  reactDom_production_min.unmountComponentAtNode = function (a) {
    if (!rk(a)) throw Error(y$2(40));
    return a._reactRootContainer ? (Xj(function () {
      tk(null, null, a, !1, function () {
        a._reactRootContainer = null;
        a[ff] = null;
      });
    }), !0) : !1;
  };

  reactDom_production_min.unstable_batchedUpdates = Wj;

  reactDom_production_min.unstable_createPortal = function (a, b) {
    return uk(a, b, 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null);
  };

  reactDom_production_min.unstable_renderSubtreeIntoContainer = function (a, b, c, d) {
    if (!rk(c)) throw Error(y$2(200));
    if (null == a || void 0 === a._reactInternals) throw Error(y$2(38));
    return tk(a, b, c, !1, d);
  };

  reactDom_production_min.version = "17.0.2";

  function checkDCE() {
    /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
      return;
    }

    try {
      // Verify that the code above has been dead code eliminated (DCE'd).
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      // DevTools shouldn't crash React, no matter what.
      // We should still report in case we break this code.
      console.error(err);
    }
  }

  {
    // DCE check should happen before ReactDOM bundle executes so that
    // DevTools can report bad minification during injection.
    checkDCE();
    reactDom.exports = reactDom_production_min;
  }

  var ReactDOM = reactDom.exports;

  var jquery = {exports: {}};

  /*!
   * jQuery JavaScript Library v3.6.0
   * https://jquery.com/
   *
   * Includes Sizzle.js
   * https://sizzlejs.com/
   *
   * Copyright OpenJS Foundation and other contributors
   * Released under the MIT license
   * https://jquery.org/license
   *
   * Date: 2021-03-02T17:08Z
   */

  (function (module) {
  (function (global, factory) {

    {
      // For CommonJS and CommonJS-like environments where a proper `window`
      // is present, execute the factory and get jQuery.
      // For environments that do not have a `window` with a `document`
      // (such as Node.js), expose a factory as module.exports.
      // This accentuates the need for the creation of a real `window`.
      // e.g. var jQuery = require("jquery")(window);
      // See ticket #14549 for more info.
      module.exports = global.document ? factory(global, true) : function (w) {
        if (!w.document) {
          throw new Error("jQuery requires a window with a document");
        }

        return factory(w);
      };
    } // Pass this if window is not defined yet

  })(typeof window !== "undefined" ? window : commonjsGlobal, function (window, noGlobal) {

    var arr = [];
    var getProto = Object.getPrototypeOf;
    var slice = arr.slice;
    var flat = function (array) {
      return arr.concat.apply([], array);
    };
    var push = arr.push;
    var indexOf = arr.indexOf;
    var class2type = {};
    var toString = class2type.toString;
    var hasOwn = class2type.hasOwnProperty;
    var fnToString = hasOwn.toString;
    var ObjectFunctionString = fnToString.call(Object);
    var support = {};

    var isFunction = function isFunction(obj) {
      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
      // Plus for old WebKit, typeof returns "function" for HTML collections
      // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
      return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
    };

    var isWindow = function isWindow(obj) {
      return obj != null && obj === obj.window;
    };

    var document = window.document;
    var preservedScriptAttributes = {
      type: true,
      src: true,
      nonce: true,
      noModule: true
    };

    function DOMEval(code, node, doc) {
      doc = doc || document;
      var i,
          val,
          script = doc.createElement("script");
      script.text = code;

      if (node) {
        for (i in preservedScriptAttributes) {
          // Support: Firefox 64+, Edge 18+
          // Some browsers don't support the "nonce" property on scripts.
          // On the other hand, just using `getAttribute` is not enough as
          // the `nonce` attribute is reset to an empty string whenever it
          // becomes browsing-context connected.
          // See https://github.com/whatwg/html/issues/2369
          // See https://html.spec.whatwg.org/#nonce-attributes
          // The `node.getAttribute` check was added for the sake of
          // `jQuery.globalEval` so that it can fake a nonce-containing node
          // via an object.
          val = node[i] || node.getAttribute && node.getAttribute(i);

          if (val) {
            script.setAttribute(i, val);
          }
        }
      }

      doc.head.appendChild(script).parentNode.removeChild(script);
    }

    function toType(obj) {
      if (obj == null) {
        return obj + "";
      } // Support: Android <=2.3 only (functionish RegExp)


      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    }
    /* global Symbol */
    // Defining this global in .eslintrc.json would create a danger of using the global
    // unguarded in another place, it seems safer to define global only for this module


    var version = "3.6.0",
        // Define a local copy of jQuery
    jQuery = function (selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      // Need init if jQuery is called (just allow error to be thrown if not included)
      return new jQuery.fn.init(selector, context);
    };

    jQuery.fn = jQuery.prototype = {
      // The current version of jQuery being used
      jquery: version,
      constructor: jQuery,
      // The default length of a jQuery object is 0
      length: 0,
      toArray: function () {
        return slice.call(this);
      },
      // Get the Nth element in the matched element set OR
      // Get the whole matched element set as a clean array
      get: function (num) {
        // Return all the elements in a clean array
        if (num == null) {
          return slice.call(this);
        } // Return just the one element from the set


        return num < 0 ? this[num + this.length] : this[num];
      },
      // Take an array of elements and push it onto the stack
      // (returning the new matched element set)
      pushStack: function (elems) {
        // Build a new jQuery matched element set
        var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

        ret.prevObject = this; // Return the newly-formed element set

        return ret;
      },
      // Execute a callback for every element in the matched set.
      each: function (callback) {
        return jQuery.each(this, callback);
      },
      map: function (callback) {
        return this.pushStack(jQuery.map(this, function (elem, i) {
          return callback.call(elem, i, elem);
        }));
      },
      slice: function () {
        return this.pushStack(slice.apply(this, arguments));
      },
      first: function () {
        return this.eq(0);
      },
      last: function () {
        return this.eq(-1);
      },
      even: function () {
        return this.pushStack(jQuery.grep(this, function (_elem, i) {
          return (i + 1) % 2;
        }));
      },
      odd: function () {
        return this.pushStack(jQuery.grep(this, function (_elem, i) {
          return i % 2;
        }));
      },
      eq: function (i) {
        var len = this.length,
            j = +i + (i < 0 ? len : 0);
        return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
      },
      end: function () {
        return this.prevObject || this.constructor();
      },
      // For internal use only.
      // Behaves like an Array's method, not like a jQuery method.
      push: push,
      sort: arr.sort,
      splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function () {
      var options,
          name,
          src,
          copy,
          copyIsArray,
          clone,
          target = arguments[0] || {},
          i = 1,
          length = arguments.length,
          deep = false; // Handle a deep copy situation

      if (typeof target === "boolean") {
        deep = target; // Skip the boolean and the target

        target = arguments[i] || {};
        i++;
      } // Handle case when target is a string or something (possible in deep copy)


      if (typeof target !== "object" && !isFunction(target)) {
        target = {};
      } // Extend jQuery itself if only one argument is passed


      if (i === length) {
        target = this;
        i--;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            copy = options[name]; // Prevent Object.prototype pollution
            // Prevent never-ending loop

            if (name === "__proto__" || target === copy) {
              continue;
            } // Recurse if we're merging plain objects or arrays


            if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
              src = target[name]; // Ensure proper type for the source value

              if (copyIsArray && !Array.isArray(src)) {
                clone = [];
              } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                clone = {};
              } else {
                clone = src;
              }

              copyIsArray = false; // Never move original objects, clone them

              target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      } // Return the modified object


      return target;
    };

    jQuery.extend({
      // Unique for each copy of jQuery on the page
      expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
      // Assume jQuery is ready without the ready module
      isReady: true,
      error: function (msg) {
        throw new Error(msg);
      },
      noop: function () {},
      isPlainObject: function (obj) {
        var proto, Ctor; // Detect obvious negatives
        // Use toString instead of jQuery.type to catch host objects

        if (!obj || toString.call(obj) !== "[object Object]") {
          return false;
        }

        proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

        if (!proto) {
          return true;
        } // Objects with prototype are plain iff they were constructed by a global Object function


        Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
        return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
      },
      isEmptyObject: function (obj) {
        var name;

        for (name in obj) {
          return false;
        }

        return true;
      },
      // Evaluates a script in a provided context; falls back to the global one
      // if not specified.
      globalEval: function (code, options, doc) {
        DOMEval(code, {
          nonce: options && options.nonce
        }, doc);
      },
      each: function (obj, callback) {
        var length,
            i = 0;

        if (isArrayLike(obj)) {
          length = obj.length;

          for (; i < length; i++) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            if (callback.call(obj[i], i, obj[i]) === false) {
              break;
            }
          }
        }

        return obj;
      },
      // results is for internal usage only
      makeArray: function (arr, results) {
        var ret = results || [];

        if (arr != null) {
          if (isArrayLike(Object(arr))) {
            jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
          } else {
            push.call(ret, arr);
          }
        }

        return ret;
      },
      inArray: function (elem, arr, i) {
        return arr == null ? -1 : indexOf.call(arr, elem, i);
      },
      // Support: Android <=4.0 only, PhantomJS 1 only
      // push.apply(_, arraylike) throws on ancient WebKit
      merge: function (first, second) {
        var len = +second.length,
            j = 0,
            i = first.length;

        for (; j < len; j++) {
          first[i++] = second[j];
        }

        first.length = i;
        return first;
      },
      grep: function (elems, callback, invert) {
        var callbackInverse,
            matches = [],
            i = 0,
            length = elems.length,
            callbackExpect = !invert; // Go through the array, only saving the items
        // that pass the validator function

        for (; i < length; i++) {
          callbackInverse = !callback(elems[i], i);

          if (callbackInverse !== callbackExpect) {
            matches.push(elems[i]);
          }
        }

        return matches;
      },
      // arg is for internal usage only
      map: function (elems, callback, arg) {
        var length,
            value,
            i = 0,
            ret = []; // Go through the array, translating each of the items to their new values

        if (isArrayLike(elems)) {
          length = elems.length;

          for (; i < length; i++) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          } // Go through every key on the object,

        } else {
          for (i in elems) {
            value = callback(elems[i], i, arg);

            if (value != null) {
              ret.push(value);
            }
          }
        } // Flatten any nested arrays


        return flat(ret);
      },
      // A global GUID counter for objects
      guid: 1,
      // jQuery.support is not used in Core but other projects attach their
      // properties to it so it needs to exist.
      support: support
    });

    if (typeof Symbol === "function") {
      jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    } // Populate the class2type map


    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
      class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArrayLike(obj) {
      // Support: real iOS 8.2 only (not reproducible in simulator)
      // `in` check used to prevent JIT error (gh-2145)
      // hasOwn isn't used here due to false negatives
      // regarding Nodelist length in IE
      var length = !!obj && "length" in obj && obj.length,
          type = toType(obj);

      if (isFunction(obj) || isWindow(obj)) {
        return false;
      }

      return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
    }

    var Sizzle =
    /*!
     * Sizzle CSS Selector Engine v2.3.6
     * https://sizzlejs.com/
     *
     * Copyright JS Foundation and other contributors
     * Released under the MIT license
     * https://js.foundation/
     *
     * Date: 2021-02-16
     */
    function (window) {
      var i,
          support,
          Expr,
          getText,
          isXML,
          tokenize,
          compile,
          select,
          outermostContext,
          sortInput,
          hasDuplicate,
          // Local document vars
      setDocument,
          document,
          docElem,
          documentIsHTML,
          rbuggyQSA,
          rbuggyMatches,
          matches,
          contains,
          // Instance-specific data
      expando = "sizzle" + 1 * new Date(),
          preferredDoc = window.document,
          dirruns = 0,
          done = 0,
          classCache = createCache(),
          tokenCache = createCache(),
          compilerCache = createCache(),
          nonnativeSelectorCache = createCache(),
          sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
        }

        return 0;
      },
          // Instance methods
      hasOwn = {}.hasOwnProperty,
          arr = [],
          pop = arr.pop,
          pushNative = arr.push,
          push = arr.push,
          slice = arr.slice,
          // Use a stripped-down indexOf as it's faster than native
      // https://jsperf.com/thor-indexof-vs-for/5
      indexOf = function (list, elem) {
        var i = 0,
            len = list.length;

        for (; i < len; i++) {
          if (list[i] === elem) {
            return i;
          }
        }

        return -1;
      },
          booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
          // Regular expressions
      // http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = "[\\x20\\t\\r\\n\\f]",
          // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
      identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
          // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
      "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
      // or strings [capture 3 or capture 4]"
      "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
          pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
      // 1. quoted (capture 3; capture 4 or capture 5)
      "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
      "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
      ".*" + ")\\)|)",
          // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rwhitespace = new RegExp(whitespace + "+", "g"),
          rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
          rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
          rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
          rdescend = new RegExp(whitespace + "|>"),
          rpseudo = new RegExp(pseudos),
          ridentifier = new RegExp("^" + identifier + "$"),
          matchExpr = {
        "ID": new RegExp("^#(" + identifier + ")"),
        "CLASS": new RegExp("^\\.(" + identifier + ")"),
        "TAG": new RegExp("^(" + identifier + "|[*])"),
        "ATTR": new RegExp("^" + attributes),
        "PSEUDO": new RegExp("^" + pseudos),
        "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
        "bool": new RegExp("^(?:" + booleans + ")$", "i"),
        // For use in libraries implementing .is()
        // We use this for POS matching in `select`
        "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
      },
          rhtml = /HTML$/i,
          rinputs = /^(?:input|select|textarea|button)$/i,
          rheader = /^h\d$/i,
          rnative = /^[^{]+\{\s*\[native \w/,
          // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
          rsibling = /[+~]/,
          // CSS escapes
      // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
          funescape = function (escape, nonHex) {
        var high = "0x" + escape.slice(1) - 0x10000;
        return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
        nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
        // Support: IE <=11+
        // For values outside the Basic Multilingual Plane (BMP), manually construct a
        // surrogate pair
        high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
      },
          // CSS string/identifier serialization
      // https://drafts.csswg.org/cssom/#common-serializing-idioms
      rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
          fcssescape = function (ch, asCodePoint) {
        if (asCodePoint) {
          // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
          if (ch === "\0") {
            return "\uFFFD";
          } // Control characters and (dependent upon position) numbers get escaped as code points


          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        } // Other potentially-special ASCII characters get backslash-escaped


        return "\\" + ch;
      },
          // Used for iframes
      // See setDocument()
      // Removing the function wrapper causes a "Permission Denied"
      // error in IE
      unloadHandler = function () {
        setDocument();
      },
          inDisabledFieldset = addCombinator(function (elem) {
        return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
      }, {
        dir: "parentNode",
        next: "legend"
      }); // Optimize for push.apply( _, NodeList )


      try {
        push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
        // Detect silently failing push.apply
        // eslint-disable-next-line no-unused-expressions

        arr[preferredDoc.childNodes.length].nodeType;
      } catch (e) {
        push = {
          apply: arr.length ? // Leverage slice if possible
          function (target, els) {
            pushNative.apply(target, slice.call(els));
          } : // Support: IE<9
          // Otherwise append directly
          function (target, els) {
            var j = target.length,
                i = 0; // Can't trust NodeList.length

            while (target[j++] = els[i++]) {}

            target.length = j - 1;
          }
        };
      }

      function Sizzle(selector, context, results, seed) {
        var m,
            i,
            elem,
            nid,
            match,
            groups,
            newSelector,
            newContext = context && context.ownerDocument,
            // nodeType defaults to 9, since context defaults to document
        nodeType = context ? context.nodeType : 9;
        results = results || []; // Return early from calls with invalid selector or context

        if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
          return results;
        } // Try to shortcut find operations (as opposed to filters) in HTML documents


        if (!seed) {
          setDocument(context);
          context = context || document;

          if (documentIsHTML) {
            // If the selector is sufficiently simple, try using a "get*By*" DOM method
            // (excepting DocumentFragment context, where the methods don't exist)
            if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
              // ID selector
              if (m = match[1]) {
                // Document context
                if (nodeType === 9) {
                  if (elem = context.getElementById(m)) {
                    // Support: IE, Opera, Webkit
                    // TODO: identify versions
                    // getElementById can match elements by name instead of ID
                    if (elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  } else {
                    return results;
                  } // Element context

                } else {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } // Type selector

              } else if (match[2]) {
                push.apply(results, context.getElementsByTagName(selector));
                return results; // Class selector
              } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            } // Take advantage of querySelectorAll


            if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
            // Exclude object elements
            nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
              newSelector = selector;
              newContext = context; // qSA considers elements outside a scoping root when evaluating child or
              // descendant combinators, which is not what we want.
              // In such cases, we work around the behavior by prefixing every selector in the
              // list with an ID selector referencing the scope context.
              // The technique has to be used as well when a leading combinator is used
              // as such selectors are not recognized by querySelectorAll.
              // Thanks to Andrew Dupont for this technique.

              if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                // Expand context for sibling selectors
                newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
                // supports it & if we're not changing the context.

                if (newContext !== context || !support.scope) {
                  // Capture the context ID, setting it first if necessary
                  if (nid = context.getAttribute("id")) {
                    nid = nid.replace(rcssescape, fcssescape);
                  } else {
                    context.setAttribute("id", nid = expando);
                  }
                } // Prefix every selector in the list


                groups = tokenize(selector);
                i = groups.length;

                while (i--) {
                  groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
                }

                newSelector = groups.join(",");
              }

              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {
                nonnativeSelectorCache(selector, true);
              } finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        } // All others


        return select(selector.replace(rtrim, "$1"), context, results, seed);
      }
      /**
       * Create key-value caches of limited size
       * @returns {function(string, object)} Returns the Object data after storing it on itself with
       *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
       *	deleting the oldest entry
       */


      function createCache() {
        var keys = [];

        function cache(key, value) {
          // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
          if (keys.push(key + " ") > Expr.cacheLength) {
            // Only keep the most recent entries
            delete cache[keys.shift()];
          }

          return cache[key + " "] = value;
        }

        return cache;
      }
      /**
       * Mark a function for special use by Sizzle
       * @param {Function} fn The function to mark
       */


      function markFunction(fn) {
        fn[expando] = true;
        return fn;
      }
      /**
       * Support testing using an element
       * @param {Function} fn Passed the created element and returns a boolean result
       */


      function assert(fn) {
        var el = document.createElement("fieldset");

        try {
          return !!fn(el);
        } catch (e) {
          return false;
        } finally {
          // Remove from its parent by default
          if (el.parentNode) {
            el.parentNode.removeChild(el);
          } // release memory in IE


          el = null;
        }
      }
      /**
       * Adds the same handler for all of the specified attrs
       * @param {String} attrs Pipe-separated list of attributes
       * @param {Function} handler The method that will be applied
       */


      function addHandle(attrs, handler) {
        var arr = attrs.split("|"),
            i = arr.length;

        while (i--) {
          Expr.attrHandle[arr[i]] = handler;
        }
      }
      /**
       * Checks document order of two siblings
       * @param {Element} a
       * @param {Element} b
       * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
       */


      function siblingCheck(a, b) {
        var cur = b && a,
            diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

        if (diff) {
          return diff;
        } // Check if b follows a


        if (cur) {
          while (cur = cur.nextSibling) {
            if (cur === b) {
              return -1;
            }
          }
        }

        return a ? 1 : -1;
      }
      /**
       * Returns a function to use in pseudos for input types
       * @param {String} type
       */


      function createInputPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === type;
        };
      }
      /**
       * Returns a function to use in pseudos for buttons
       * @param {String} type
       */


      function createButtonPseudo(type) {
        return function (elem) {
          var name = elem.nodeName.toLowerCase();
          return (name === "input" || name === "button") && elem.type === type;
        };
      }
      /**
       * Returns a function to use in pseudos for :enabled/:disabled
       * @param {Boolean} disabled true for :disabled; false for :enabled
       */


      function createDisabledPseudo(disabled) {
        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
        return function (elem) {
          // Only certain elements can match :enabled or :disabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
          // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
          if ("form" in elem) {
            // Check for inherited disabledness on relevant non-disabled elements:
            // * listed form-associated elements in a disabled fieldset
            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
            // * option elements in a disabled optgroup
            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
            // All such elements have a "form" property.
            if (elem.parentNode && elem.disabled === false) {
              // Option elements defer to a parent optgroup if present
              if ("label" in elem) {
                if ("label" in elem.parentNode) {
                  return elem.parentNode.disabled === disabled;
                } else {
                  return elem.disabled === disabled;
                }
              } // Support: IE 6 - 11
              // Use the isDisabled shortcut property to check for disabled fieldset ancestors


              return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

              /* jshint -W018 */
              elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
            }

            return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
            // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
            // even exist on them, let alone have a boolean value.
          } else if ("label" in elem) {
            return elem.disabled === disabled;
          } // Remaining elements are neither :enabled nor :disabled


          return false;
        };
      }
      /**
       * Returns a function to use in pseudos for positionals
       * @param {Function} fn
       */


      function createPositionalPseudo(fn) {
        return markFunction(function (argument) {
          argument = +argument;
          return markFunction(function (seed, matches) {
            var j,
                matchIndexes = fn([], seed.length, argument),
                i = matchIndexes.length; // Match elements found at the specified indexes

            while (i--) {
              if (seed[j = matchIndexes[i]]) {
                seed[j] = !(matches[j] = seed[j]);
              }
            }
          });
        });
      }
      /**
       * Checks a node for validity as a Sizzle context
       * @param {Element|Object=} context
       * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
       */


      function testContext(context) {
        return context && typeof context.getElementsByTagName !== "undefined" && context;
      } // Expose support vars for convenience


      support = Sizzle.support = {};
      /**
       * Detects XML nodes
       * @param {Element|Object} elem An element or a document
       * @returns {Boolean} True iff elem is a non-HTML XML node
       */

      isXML = Sizzle.isXML = function (elem) {
        var namespace = elem && elem.namespaceURI,
            docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8
        // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
        // https://bugs.jquery.com/ticket/4833

        return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
      };
      /**
       * Sets document-related variables once based on the current document
       * @param {Element|Object} [doc] An element or document object to use to set the document
       * @returns {Object} Returns the current document
       */


      setDocument = Sizzle.setDocument = function (node) {
        var hasCompare,
            subWindow,
            doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq

        if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
          return document;
        } // Update global variables


        document = doc;
        docElem = document.documentElement;
        documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq

        if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
          // Support: IE 11, Edge
          if (subWindow.addEventListener) {
            subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
          } else if (subWindow.attachEvent) {
            subWindow.attachEvent("onunload", unloadHandler);
          }
        } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
        // Safari 4 - 5 only, Opera <=11.6 - 12.x only
        // IE/Edge & older browsers don't support the :scope pseudo-class.
        // Support: Safari 6.0 only
        // Safari 6.0 supports :scope but it's an alias of :root there.


        support.scope = assert(function (el) {
          docElem.appendChild(el).appendChild(document.createElement("div"));
          return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
        });
        /* Attributes
        ---------------------------------------------------------------------- */
        // Support: IE<8
        // Verify that getAttribute really returns attributes and not properties
        // (excepting IE8 booleans)

        support.attributes = assert(function (el) {
          el.className = "i";
          return !el.getAttribute("className");
        });
        /* getElement(s)By*
        ---------------------------------------------------------------------- */
        // Check if getElementsByTagName("*") returns only elements

        support.getElementsByTagName = assert(function (el) {
          el.appendChild(document.createComment(""));
          return !el.getElementsByTagName("*").length;
        }); // Support: IE<9

        support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
        // Check if getElementById returns elements by name
        // The broken getElementById methods don't pick up programmatically-set names,
        // so use a roundabout getElementsByName test

        support.getById = assert(function (el) {
          docElem.appendChild(el).id = expando;
          return !document.getElementsByName || !document.getElementsByName(expando).length;
        }); // ID filter and find

        if (support.getById) {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              return elem.getAttribute("id") === attrId;
            };
          };

          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var elem = context.getElementById(id);
              return elem ? [elem] : [];
            }
          };
        } else {
          Expr.filter["ID"] = function (id) {
            var attrId = id.replace(runescape, funescape);
            return function (elem) {
              var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
              return node && node.value === attrId;
            };
          }; // Support: IE 6 - 7 only
          // getElementById is not reliable as a find shortcut


          Expr.find["ID"] = function (id, context) {
            if (typeof context.getElementById !== "undefined" && documentIsHTML) {
              var node,
                  i,
                  elems,
                  elem = context.getElementById(id);

              if (elem) {
                // Verify the id attribute
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                } // Fall back on getElementsByName


                elems = context.getElementsByName(id);
                i = 0;

                while (elem = elems[i++]) {
                  node = elem.getAttributeNode("id");

                  if (node && node.value === id) {
                    return [elem];
                  }
                }
              }

              return [];
            }
          };
        } // Tag


        Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
          if (typeof context.getElementsByTagName !== "undefined") {
            return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
          } else if (support.qsa) {
            return context.querySelectorAll(tag);
          }
        } : function (tag, context) {
          var elem,
              tmp = [],
              i = 0,
              // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
          results = context.getElementsByTagName(tag); // Filter out possible comments

          if (tag === "*") {
            while (elem = results[i++]) {
              if (elem.nodeType === 1) {
                tmp.push(elem);
              }
            }

            return tmp;
          }

          return results;
        }; // Class

        Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
          if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
            return context.getElementsByClassName(className);
          }
        };
        /* QSA/matchesSelector
        ---------------------------------------------------------------------- */
        // QSA and matchesSelector support
        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


        rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
        // We allow this because of a bug in IE8/9 that throws an error
        // whenever `document.activeElement` is accessed on an iframe
        // So, we allow :focus to pass through QSA all the time to avoid the IE error
        // See https://bugs.jquery.com/ticket/13378

        rbuggyQSA = [];

        if (support.qsa = rnative.test(document.querySelectorAll)) {
          // Build QSA regex
          // Regex strategy adopted from Diego Perini
          assert(function (el) {
            var input; // Select is set to empty string on purpose
            // This is to test IE's treatment of not explicitly
            // setting a boolean content attribute,
            // since its presence should be enough
            // https://bugs.jquery.com/ticket/12359

            docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
            // Nothing should be selected when empty strings follow ^= or $= or *=
            // The test attribute must be unknown in Opera but "safe" for WinRT
            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

            if (el.querySelectorAll("[msallowcapture^='']").length) {
              rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
            } // Support: IE8
            // Boolean attributes and "value" are not treated correctly


            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            } // Support: IE 11+, Edge 15 - 18+
            // IE 11/Edge don't find elements on a `[name='']` query in some cases.
            // Adding a temporary attribute to the document before the selection works
            // around the issue.
            // Interestingly, IE 10 & older don't seem to have the issue.


            input = document.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);

            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
            } // Webkit/Opera - :checked should return selected option elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            // IE8 throws error here and will not see later tests


            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            } // Support: Safari 8+, iOS 8+
            // https://bugs.webkit.org/show_bug.cgi?id=136851
            // In-page `selector#id sibling-combinator selector` fails


            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            } // Support: Firefox <=3.6 - 5 only
            // Old Firefox doesn't throw on a badly-escaped identifier.


            el.querySelectorAll("\\\f");
            rbuggyQSA.push("[\\r\\n\\f]");
          });
          assert(function (el) {
            el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
            // The type and name attributes are restricted during .innerHTML assignment

            var input = document.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D"); // Support: IE8
            // Enforce case-sensitivity of name attribute

            if (el.querySelectorAll("[name=d]").length) {
              rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
            } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
            // IE8 throws error here and will not see later tests


            if (el.querySelectorAll(":enabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Support: IE9-11+
            // IE's :disabled selector does not pick up the children of disabled fieldsets


            docElem.appendChild(el).disabled = true;

            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            } // Support: Opera 10 - 11 only
            // Opera 10-11 does not throw on post-comma invalid pseudos


            el.querySelectorAll("*,:x");
            rbuggyQSA.push(",.*:");
          });
        }

        if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
          assert(function (el) {
            // Check to see if it's possible to do matchesSelector
            // on a disconnected node (IE 9)
            support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
            // Gecko does not error, returns false instead

            matches.call(el, "[s!='']:x");
            rbuggyMatches.push("!=", pseudos);
          });
        }

        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
        /* Contains
        ---------------------------------------------------------------------- */

        hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
        // Purposefully self-exclusive
        // As in, an element does not contain itself

        contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
          var adown = a.nodeType === 9 ? a.documentElement : a,
              bup = b && b.parentNode;
          return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
        } : function (a, b) {
          if (b) {
            while (b = b.parentNode) {
              if (b === a) {
                return true;
              }
            }
          }

          return false;
        };
        /* Sorting
        ---------------------------------------------------------------------- */
        // Document order sorting

        sortOrder = hasCompare ? function (a, b) {
          // Flag for duplicate removal
          if (a === b) {
            hasDuplicate = true;
            return 0;
          } // Sort on method existence if only one input has compareDocumentPosition


          var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

          if (compare) {
            return compare;
          } // Calculate position if both inputs belong to the same document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq


          compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
          1; // Disconnected nodes

          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            // Choose the first element that is related to our preferred document
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
              return -1;
            } // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq


            if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
              return 1;
            } // Maintain original order


            return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
          }

          return compare & 4 ? -1 : 1;
        } : function (a, b) {
          // Exit early if the nodes are identical
          if (a === b) {
            hasDuplicate = true;
            return 0;
          }

          var cur,
              i = 0,
              aup = a.parentNode,
              bup = b.parentNode,
              ap = [a],
              bp = [b]; // Parentless nodes are either documents or disconnected

          if (!aup || !bup) {
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.

            /* eslint-disable eqeqeq */
            return a == document ? -1 : b == document ? 1 :
            /* eslint-enable eqeqeq */
            aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
          } else if (aup === bup) {
            return siblingCheck(a, b);
          } // Otherwise we need full lists of their ancestors for comparison


          cur = a;

          while (cur = cur.parentNode) {
            ap.unshift(cur);
          }

          cur = b;

          while (cur = cur.parentNode) {
            bp.unshift(cur);
          } // Walk down the tree looking for a discrepancy


          while (ap[i] === bp[i]) {
            i++;
          }

          return i ? // Do a sibling check if the nodes have a common ancestor
          siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.

          /* eslint-disable eqeqeq */
          ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
          /* eslint-enable eqeqeq */
          0;
        };
        return document;
      };

      Sizzle.matches = function (expr, elements) {
        return Sizzle(expr, null, null, elements);
      };

      Sizzle.matchesSelector = function (elem, expr) {
        setDocument(elem);

        if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
          try {
            var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

            if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
            // fragment in IE 9
            elem.document && elem.document.nodeType !== 11) {
              return ret;
            }
          } catch (e) {
            nonnativeSelectorCache(expr, true);
          }
        }

        return Sizzle(expr, document, null, [elem]).length > 0;
      };

      Sizzle.contains = function (context, elem) {
        // Set document vars if needed
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ((context.ownerDocument || context) != document) {
          setDocument(context);
        }

        return contains(context, elem);
      };

      Sizzle.attr = function (elem, name) {
        // Set document vars if needed
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq
        if ((elem.ownerDocument || elem) != document) {
          setDocument(elem);
        }

        var fn = Expr.attrHandle[name.toLowerCase()],
            // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
        return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
      };

      Sizzle.escape = function (sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };

      Sizzle.error = function (msg) {
        throw new Error("Syntax error, unrecognized expression: " + msg);
      };
      /**
       * Document sorting and removing duplicates
       * @param {ArrayLike} results
       */


      Sizzle.uniqueSort = function (results) {
        var elem,
            duplicates = [],
            j = 0,
            i = 0; // Unless we *know* we can detect duplicates, assume their presence

        hasDuplicate = !support.detectDuplicates;
        sortInput = !support.sortStable && results.slice(0);
        results.sort(sortOrder);

        if (hasDuplicate) {
          while (elem = results[i++]) {
            if (elem === results[i]) {
              j = duplicates.push(i);
            }
          }

          while (j--) {
            results.splice(duplicates[j], 1);
          }
        } // Clear input after sorting to release objects
        // See https://github.com/jquery/sizzle/pull/225


        sortInput = null;
        return results;
      };
      /**
       * Utility function for retrieving the text value of an array of DOM nodes
       * @param {Array|Element} elem
       */


      getText = Sizzle.getText = function (elem) {
        var node,
            ret = "",
            i = 0,
            nodeType = elem.nodeType;

        if (!nodeType) {
          // If no nodeType, this is expected to be an array
          while (node = elem[i++]) {
            // Do not traverse comment nodes
            ret += getText(node);
          }
        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          // Use textContent for elements
          // innerText usage removed for consistency of new lines (jQuery #11153)
          if (typeof elem.textContent === "string") {
            return elem.textContent;
          } else {
            // Traverse its children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else if (nodeType === 3 || nodeType === 4) {
          return elem.nodeValue;
        } // Do not include comment or processing instruction nodes


        return ret;
      };

      Expr = Sizzle.selectors = {
        // Can be adjusted by the user
        cacheLength: 50,
        createPseudo: markFunction,
        match: matchExpr,
        attrHandle: {},
        find: {},
        relative: {
          ">": {
            dir: "parentNode",
            first: true
          },
          " ": {
            dir: "parentNode"
          },
          "+": {
            dir: "previousSibling",
            first: true
          },
          "~": {
            dir: "previousSibling"
          }
        },
        preFilter: {
          "ATTR": function (match) {
            match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

            match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

            if (match[2] === "~=") {
              match[3] = " " + match[3] + " ";
            }

            return match.slice(0, 4);
          },
          "CHILD": function (match) {
            /* matches from matchExpr["CHILD"]
            	1 type (only|nth|...)
            	2 what (child|of-type)
            	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
            	4 xn-component of xn+y argument ([+-]?\d*n|)
            	5 sign of xn-component
            	6 x of xn-component
            	7 sign of y-component
            	8 y of y-component
            */
            match[1] = match[1].toLowerCase();

            if (match[1].slice(0, 3) === "nth") {
              // nth-* requires argument
              if (!match[3]) {
                Sizzle.error(match[0]);
              } // numeric x and y parameters for Expr.filter.CHILD
              // remember that false/true cast respectively to 0/1


              match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
              match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
            } else if (match[3]) {
              Sizzle.error(match[0]);
            }

            return match;
          },
          "PSEUDO": function (match) {
            var excess,
                unquoted = !match[6] && match[2];

            if (matchExpr["CHILD"].test(match[0])) {
              return null;
            } // Accept quoted arguments as-is


            if (match[3]) {
              match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
            } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
            excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
            excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
              // excess is a negative index
              match[0] = match[0].slice(0, excess);
              match[2] = unquoted.slice(0, excess);
            } // Return only captures needed by the pseudo filter method (type and argument)


            return match.slice(0, 3);
          }
        },
        filter: {
          "TAG": function (nodeNameSelector) {
            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
            return nodeNameSelector === "*" ? function () {
              return true;
            } : function (elem) {
              return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
            };
          },
          "CLASS": function (className) {
            var pattern = classCache[className + " "];
            return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
              return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
            });
          },
          "ATTR": function (name, operator, check) {
            return function (elem) {
              var result = Sizzle.attr(elem, name);

              if (result == null) {
                return operator === "!=";
              }

              if (!operator) {
                return true;
              }

              result += "";
              /* eslint-disable max-len */

              return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              /* eslint-enable max-len */
            };
          },
          "CHILD": function (type, what, _argument, first, last) {
            var simple = type.slice(0, 3) !== "nth",
                forward = type.slice(-4) !== "last",
                ofType = what === "of-type";
            return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
            function (elem) {
              return !!elem.parentNode;
            } : function (elem, _context, xml) {
              var cache,
                  uniqueCache,
                  outerCache,
                  node,
                  nodeIndex,
                  start,
                  dir = simple !== forward ? "nextSibling" : "previousSibling",
                  parent = elem.parentNode,
                  name = ofType && elem.nodeName.toLowerCase(),
                  useCache = !xml && !ofType,
                  diff = false;

              if (parent) {
                // :(first|last|only)-(child|of-type)
                if (simple) {
                  while (dir) {
                    node = elem;

                    while (node = node[dir]) {
                      if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                        return false;
                      }
                    } // Reverse direction for :only-* (if we haven't yet done so)


                    start = dir = type === "only" && !start && "nextSibling";
                  }

                  return true;
                }

                start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

                if (forward && useCache) {
                  // Seek `elem` from a previously-cached index
                  // ...in a gzip-friendly way
                  node = parent;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex && cache[2];
                  node = nodeIndex && parent.childNodes[nodeIndex];

                  while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                  diff = nodeIndex = 0) || start.pop()) {
                    // When found, cache indexes on `parent` and break
                    if (node.nodeType === 1 && ++diff && node === elem) {
                      uniqueCache[type] = [dirruns, nodeIndex, diff];
                      break;
                    }
                  }
                } else {
                  // Use previously-cached element index if available
                  if (useCache) {
                    // ...in a gzip-friendly way
                    node = elem;
                    outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                    // Defend against cloned attroperties (jQuery gh-1709)

                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex;
                  } // xml :nth-child(...)
                  // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                  if (diff === false) {
                    // Use the same loop as above to seek `elem` from the start
                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                      if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                        // Cache the index of each encountered element
                        if (useCache) {
                          outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                          // Defend against cloned attroperties (jQuery gh-1709)

                          uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                          uniqueCache[type] = [dirruns, diff];
                        }

                        if (node === elem) {
                          break;
                        }
                      }
                    }
                  }
                } // Incorporate the offset, then check against cycle size


                diff -= last;
                return diff === first || diff % first === 0 && diff / first >= 0;
              }
            };
          },
          "PSEUDO": function (pseudo, argument) {
            // pseudo-class names are case-insensitive
            // http://www.w3.org/TR/selectors/#pseudo-classes
            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
            // Remember that setFilters inherits from pseudos
            var args,
                fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
            // arguments are needed to create the filter function
            // just as Sizzle does

            if (fn[expando]) {
              return fn(argument);
            } // But maintain support for old signatures


            if (fn.length > 1) {
              args = [pseudo, pseudo, "", argument];
              return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                var idx,
                    matched = fn(seed, argument),
                    i = matched.length;

                while (i--) {
                  idx = indexOf(seed, matched[i]);
                  seed[idx] = !(matches[idx] = matched[i]);
                }
              }) : function (elem) {
                return fn(elem, 0, args);
              };
            }

            return fn;
          }
        },
        pseudos: {
          // Potentially complex pseudos
          "not": markFunction(function (selector) {
            // Trim the selector passed to compile
            // to avoid treating leading and trailing
            // spaces as combinators
            var input = [],
                results = [],
                matcher = compile(selector.replace(rtrim, "$1"));
            return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
              var elem,
                  unmatched = matcher(seed, null, xml, []),
                  i = seed.length; // Match elements unmatched by `matcher`

              while (i--) {
                if (elem = unmatched[i]) {
                  seed[i] = !(matches[i] = elem);
                }
              }
            }) : function (elem, _context, xml) {
              input[0] = elem;
              matcher(input, null, xml, results); // Don't keep the element (issue #299)

              input[0] = null;
              return !results.pop();
            };
          }),
          "has": markFunction(function (selector) {
            return function (elem) {
              return Sizzle(selector, elem).length > 0;
            };
          }),
          "contains": markFunction(function (text) {
            text = text.replace(runescape, funescape);
            return function (elem) {
              return (elem.textContent || getText(elem)).indexOf(text) > -1;
            };
          }),
          // "Whether an element is represented by a :lang() selector
          // is based solely on the element's language value
          // being equal to the identifier C,
          // or beginning with the identifier C immediately followed by "-".
          // The matching of C against the element's language value is performed case-insensitively.
          // The identifier C does not have to be a valid language name."
          // http://www.w3.org/TR/selectors/#lang-pseudo
          "lang": markFunction(function (lang) {
            // lang value must be a valid identifier
            if (!ridentifier.test(lang || "")) {
              Sizzle.error("unsupported lang: " + lang);
            }

            lang = lang.replace(runescape, funescape).toLowerCase();
            return function (elem) {
              var elemLang;

              do {
                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                  elemLang = elemLang.toLowerCase();
                  return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                }
              } while ((elem = elem.parentNode) && elem.nodeType === 1);

              return false;
            };
          }),
          // Miscellaneous
          "target": function (elem) {
            var hash = window.location && window.location.hash;
            return hash && hash.slice(1) === elem.id;
          },
          "root": function (elem) {
            return elem === docElem;
          },
          "focus": function (elem) {
            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
          },
          // Boolean properties
          "enabled": createDisabledPseudo(false),
          "disabled": createDisabledPseudo(true),
          "checked": function (elem) {
            // In CSS3, :checked should return both checked and selected elements
            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
            var nodeName = elem.nodeName.toLowerCase();
            return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
          },
          "selected": function (elem) {
            // Accessing this property makes selected-by-default
            // options in Safari work properly
            if (elem.parentNode) {
              // eslint-disable-next-line no-unused-expressions
              elem.parentNode.selectedIndex;
            }

            return elem.selected === true;
          },
          // Contents
          "empty": function (elem) {
            // http://www.w3.org/TR/selectors/#empty-pseudo
            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
            //   but not by others (comment: 8; processing instruction: 7; etc.)
            // nodeType < 6 works because attributes (2) do not appear as children
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              if (elem.nodeType < 6) {
                return false;
              }
            }

            return true;
          },
          "parent": function (elem) {
            return !Expr.pseudos["empty"](elem);
          },
          // Element/input types
          "header": function (elem) {
            return rheader.test(elem.nodeName);
          },
          "input": function (elem) {
            return rinputs.test(elem.nodeName);
          },
          "button": function (elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === "button" || name === "button";
          },
          "text": function (elem) {
            var attr;
            return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
            (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
          },
          // Position-in-collection
          "first": createPositionalPseudo(function () {
            return [0];
          }),
          "last": createPositionalPseudo(function (_matchIndexes, length) {
            return [length - 1];
          }),
          "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
            return [argument < 0 ? argument + length : argument];
          }),
          "even": createPositionalPseudo(function (matchIndexes, length) {
            var i = 0;

            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "odd": createPositionalPseudo(function (matchIndexes, length) {
            var i = 1;

            for (; i < length; i += 2) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument > length ? length : argument;

            for (; --i >= 0;) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          }),
          "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
            var i = argument < 0 ? argument + length : argument;

            for (; ++i < length;) {
              matchIndexes.push(i);
            }

            return matchIndexes;
          })
        }
      };
      Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

      for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
        Expr.pseudos[i] = createInputPseudo(i);
      }

      for (i in {
        submit: true,
        reset: true
      }) {
        Expr.pseudos[i] = createButtonPseudo(i);
      } // Easy API for creating new setFilters


      function setFilters() {}

      setFilters.prototype = Expr.filters = Expr.pseudos;
      Expr.setFilters = new setFilters();

      tokenize = Sizzle.tokenize = function (selector, parseOnly) {
        var matched,
            match,
            tokens,
            type,
            soFar,
            groups,
            preFilters,
            cached = tokenCache[selector + " "];

        if (cached) {
          return parseOnly ? 0 : cached.slice(0);
        }

        soFar = selector;
        groups = [];
        preFilters = Expr.preFilter;

        while (soFar) {
          // Comma and first run
          if (!matched || (match = rcomma.exec(soFar))) {
            if (match) {
              // Don't consume trailing commas as valid
              soFar = soFar.slice(match[0].length) || soFar;
            }

            groups.push(tokens = []);
          }

          matched = false; // Combinators

          if (match = rcombinators.exec(soFar)) {
            matched = match.shift();
            tokens.push({
              value: matched,
              // Cast descendant combinators to space
              type: match[0].replace(rtrim, " ")
            });
            soFar = soFar.slice(matched.length);
          } // Filters


          for (type in Expr.filter) {
            if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: type,
                matches: match
              });
              soFar = soFar.slice(matched.length);
            }
          }

          if (!matched) {
            break;
          }
        } // Return the length of the invalid excess
        // if we're just parsing
        // Otherwise, throw an error or return tokens


        return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
        tokenCache(selector, groups).slice(0);
      };

      function toSelector(tokens) {
        var i = 0,
            len = tokens.length,
            selector = "";

        for (; i < len; i++) {
          selector += tokens[i].value;
        }

        return selector;
      }

      function addCombinator(matcher, combinator, base) {
        var dir = combinator.dir,
            skip = combinator.next,
            key = skip || dir,
            checkNonElements = base && key === "parentNode",
            doneName = done++;
        return combinator.first ? // Check against closest ancestor/preceding element
        function (elem, context, xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              return matcher(elem, context, xml);
            }
          }

          return false;
        } : // Check against all ancestor/preceding elements
        function (elem, context, xml) {
          var oldCache,
              uniqueCache,
              outerCache,
              newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

          if (xml) {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                if (matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          } else {
            while (elem = elem[dir]) {
              if (elem.nodeType === 1 || checkNonElements) {
                outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                if (skip && skip === elem.nodeName.toLowerCase()) {
                  elem = elem[dir] || elem;
                } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                  // Assign to newCache so results back-propagate to previous elements
                  return newCache[2] = oldCache[2];
                } else {
                  // Reuse newcache so results back-propagate to previous elements
                  uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                  if (newCache[2] = matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            }
          }

          return false;
        };
      }

      function elementMatcher(matchers) {
        return matchers.length > 1 ? function (elem, context, xml) {
          var i = matchers.length;

          while (i--) {
            if (!matchers[i](elem, context, xml)) {
              return false;
            }
          }

          return true;
        } : matchers[0];
      }

      function multipleContexts(selector, contexts, results) {
        var i = 0,
            len = contexts.length;

        for (; i < len; i++) {
          Sizzle(selector, contexts[i], results);
        }

        return results;
      }

      function condense(unmatched, map, filter, context, xml) {
        var elem,
            newUnmatched = [],
            i = 0,
            len = unmatched.length,
            mapped = map != null;

        for (; i < len; i++) {
          if (elem = unmatched[i]) {
            if (!filter || filter(elem, context, xml)) {
              newUnmatched.push(elem);

              if (mapped) {
                map.push(i);
              }
            }
          }
        }

        return newUnmatched;
      }

      function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
        if (postFilter && !postFilter[expando]) {
          postFilter = setMatcher(postFilter);
        }

        if (postFinder && !postFinder[expando]) {
          postFinder = setMatcher(postFinder, postSelector);
        }

        return markFunction(function (seed, results, context, xml) {
          var temp,
              i,
              elem,
              preMap = [],
              postMap = [],
              preexisting = results.length,
              // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
              // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
              matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
          postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
          [] : // ...otherwise use results directly
          results : matcherIn; // Find primary matches

          if (matcher) {
            matcher(matcherIn, matcherOut, context, xml);
          } // Apply postFilter


          if (postFilter) {
            temp = condense(matcherOut, postMap);
            postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

            i = temp.length;

            while (i--) {
              if (elem = temp[i]) {
                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
              }
            }
          }

          if (seed) {
            if (postFinder || preFilter) {
              if (postFinder) {
                // Get the final matcherOut by condensing this intermediate into postFinder contexts
                temp = [];
                i = matcherOut.length;

                while (i--) {
                  if (elem = matcherOut[i]) {
                    // Restore matcherIn since elem is not yet a final match
                    temp.push(matcherIn[i] = elem);
                  }
                }

                postFinder(null, matcherOut = [], temp, xml);
              } // Move matched elements from seed to results to keep them synchronized


              i = matcherOut.length;

              while (i--) {
                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                  seed[temp] = !(results[temp] = elem);
                }
              }
            } // Add elements to results, through postFinder if defined

          } else {
            matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

            if (postFinder) {
              postFinder(null, results, matcherOut, xml);
            } else {
              push.apply(results, matcherOut);
            }
          }
        });
      }

      function matcherFromTokens(tokens) {
        var checkContext,
            matcher,
            j,
            len = tokens.length,
            leadingRelative = Expr.relative[tokens[0].type],
            implicitRelative = leadingRelative || Expr.relative[" "],
            i = leadingRelative ? 1 : 0,
            // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true),
            matchAnyContext = addCombinator(function (elem) {
          return indexOf(checkContext, elem) > -1;
        }, implicitRelative, true),
            matchers = [function (elem, context, xml) {
          var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

          checkContext = null;
          return ret;
        }];

        for (; i < len; i++) {
          if (matcher = Expr.relative[tokens[i].type]) {
            matchers = [addCombinator(elementMatcher(matchers), matcher)];
          } else {
            matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

            if (matcher[expando]) {
              // Find the next relative operator (if any) for proper handling
              j = ++i;

              for (; j < len; j++) {
                if (Expr.relative[tokens[j].type]) {
                  break;
                }
              }

              return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
              tokens.slice(0, i - 1).concat({
                value: tokens[i - 2].type === " " ? "*" : ""
              })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
            }

            matchers.push(matcher);
          }
        }

        return elementMatcher(matchers);
      }

      function matcherFromGroupMatchers(elementMatchers, setMatchers) {
        var bySet = setMatchers.length > 0,
            byElement = elementMatchers.length > 0,
            superMatcher = function (seed, context, xml, results, outermost) {
          var elem,
              j,
              matcher,
              matchedCount = 0,
              i = "0",
              unmatched = seed && [],
              setMatched = [],
              contextBackup = outermostContext,
              // We must always have either seed elements or outermost context
          elems = seed || byElement && Expr.find["TAG"]("*", outermost),
              // Use integer dirruns iff this is the outermost matcher
          dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
              len = elems.length;

          if (outermost) {
            // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq
            outermostContext = context == document || context || outermost;
          } // Add elements passing elementMatchers directly to results
          // Support: IE<9, Safari
          // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


          for (; i !== len && (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0; // Support: IE 11+, Edge 17 - 18+
              // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
              // two documents; shallow comparisons work.
              // eslint-disable-next-line eqeqeq

              if (!context && elem.ownerDocument != document) {
                setDocument(elem);
                xml = !documentIsHTML;
              }

              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context || document, xml)) {
                  results.push(elem);
                  break;
                }
              }

              if (outermost) {
                dirruns = dirrunsUnique;
              }
            } // Track unmatched elements for set filters


            if (bySet) {
              // They will have gone through all possible matchers
              if (elem = !matcher && elem) {
                matchedCount--;
              } // Lengthen the array for every element, matched or not


              if (seed) {
                unmatched.push(elem);
              }
            }
          } // `i` is now the count of elements visited above, and adding it to `matchedCount`
          // makes the latter nonnegative.


          matchedCount += i; // Apply set filters to unmatched elements
          // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
          // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
          // no element matchers and no seed.
          // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
          // case, which will result in a "00" `matchedCount` that differs from `i` but is also
          // numerically zero.

          if (bySet && i !== matchedCount) {
            j = 0;

            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }

            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              } // Discard index placeholder values to get only actual matches


              setMatched = condense(setMatched);
            } // Add matches to results


            push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          } // Override manipulation of globals by nested matchers


          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }

          return unmatched;
        };

        return bySet ? markFunction(superMatcher) : superMatcher;
      }

      compile = Sizzle.compile = function (selector, match
      /* Internal Use Only */
      ) {
        var i,
            setMatchers = [],
            elementMatchers = [],
            cached = compilerCache[selector + " "];

        if (!cached) {
          // Generate a function of recursive functions that can be used to check each element
          if (!match) {
            match = tokenize(selector);
          }

          i = match.length;

          while (i--) {
            cached = matcherFromTokens(match[i]);

            if (cached[expando]) {
              setMatchers.push(cached);
            } else {
              elementMatchers.push(cached);
            }
          } // Cache the compiled function


          cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

          cached.selector = selector;
        }

        return cached;
      };
      /**
       * A low-level selection function that works with Sizzle's compiled
       *  selector functions
       * @param {String|Function} selector A selector or a pre-compiled
       *  selector function built with Sizzle.compile
       * @param {Element} context
       * @param {Array} [results]
       * @param {Array} [seed] A set of elements to match against
       */


      select = Sizzle.select = function (selector, context, results, seed) {
        var i,
            tokens,
            token,
            type,
            find,
            compiled = typeof selector === "function" && selector,
            match = !seed && tokenize(selector = compiled.selector || selector);
        results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
        // (the latter of which guarantees us context)

        if (match.length === 1) {
          // Reduce context if the leading compound selector is an ID
          tokens = match[0] = match[0].slice(0);

          if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

            if (!context) {
              return results; // Precompiled matchers will still verify ancestry, so step up a level
            } else if (compiled) {
              context = context.parentNode;
            }

            selector = selector.slice(tokens.shift().value.length);
          } // Fetch a seed set for right-to-left matching


          i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

          while (i--) {
            token = tokens[i]; // Abort if we hit a combinator

            if (Expr.relative[type = token.type]) {
              break;
            }

            if (find = Expr.find[type]) {
              // Search, expanding context for leading sibling combinators
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);

                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }

                break;
              }
            }
          }
        } // Compile and execute a filtering function if one is not provided
        // Provide `match` to avoid retokenization if we modified the selector above


        (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
        return results;
      }; // One-time assignments
      // Sort stability


      support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
      // Always assume duplicates if they aren't passed to the comparison function

      support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

      setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
      // Detached nodes confoundingly follow *each other*

      support.sortDetached = assert(function (el) {
        // Should return 1, but returns 4 (following)
        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
      }); // Support: IE<8
      // Prevent attribute/property "interpolation"
      // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

      if (!assert(function (el) {
        el.innerHTML = "<a href='#'></a>";
        return el.firstChild.getAttribute("href") === "#";
      })) {
        addHandle("type|href|height|width", function (elem, name, isXML) {
          if (!isXML) {
            return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
          }
        });
      } // Support: IE<9
      // Use defaultValue in place of getAttribute("value")


      if (!support.attributes || !assert(function (el) {
        el.innerHTML = "<input/>";
        el.firstChild.setAttribute("value", "");
        return el.firstChild.getAttribute("value") === "";
      })) {
        addHandle("value", function (elem, _name, isXML) {
          if (!isXML && elem.nodeName.toLowerCase() === "input") {
            return elem.defaultValue;
          }
        });
      } // Support: IE<9
      // Use getAttributeNode to fetch booleans when getAttribute lies


      if (!assert(function (el) {
        return el.getAttribute("disabled") == null;
      })) {
        addHandle(booleans, function (elem, name, isXML) {
          var val;

          if (!isXML) {
            return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
          }
        });
      }

      return Sizzle;
    }(window);

    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors; // Deprecated

    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
    jQuery.escapeSelector = Sizzle.escape;

    var dir = function (elem, dir, until) {
      var matched = [],
          truncate = until !== undefined;

      while ((elem = elem[dir]) && elem.nodeType !== 9) {
        if (elem.nodeType === 1) {
          if (truncate && jQuery(elem).is(until)) {
            break;
          }

          matched.push(elem);
        }
      }

      return matched;
    };

    var siblings = function (n, elem) {
      var matched = [];

      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          matched.push(n);
        }
      }

      return matched;
    };

    var rneedsContext = jQuery.expr.match.needsContext;

    function nodeName(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    }

    var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

    function winnow(elements, qualifier, not) {
      if (isFunction(qualifier)) {
        return jQuery.grep(elements, function (elem, i) {
          return !!qualifier.call(elem, i, elem) !== not;
        });
      } // Single element


      if (qualifier.nodeType) {
        return jQuery.grep(elements, function (elem) {
          return elem === qualifier !== not;
        });
      } // Arraylike of elements (jQuery, arguments, Array)


      if (typeof qualifier !== "string") {
        return jQuery.grep(elements, function (elem) {
          return indexOf.call(qualifier, elem) > -1 !== not;
        });
      } // Filtered directly for both simple and complex selectors


      return jQuery.filter(qualifier, elements, not);
    }

    jQuery.filter = function (expr, elems, not) {
      var elem = elems[0];

      if (not) {
        expr = ":not(" + expr + ")";
      }

      if (elems.length === 1 && elem.nodeType === 1) {
        return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
      }

      return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    };

    jQuery.fn.extend({
      find: function (selector) {
        var i,
            ret,
            len = this.length,
            self = this;

        if (typeof selector !== "string") {
          return this.pushStack(jQuery(selector).filter(function () {
            for (i = 0; i < len; i++) {
              if (jQuery.contains(self[i], this)) {
                return true;
              }
            }
          }));
        }

        ret = this.pushStack([]);

        for (i = 0; i < len; i++) {
          jQuery.find(selector, self[i], ret);
        }

        return len > 1 ? jQuery.uniqueSort(ret) : ret;
      },
      filter: function (selector) {
        return this.pushStack(winnow(this, selector || [], false));
      },
      not: function (selector) {
        return this.pushStack(winnow(this, selector || [], true));
      },
      is: function (selector) {
        return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
        // so $("p:first").is("p:last") won't return true for a doc with two "p".
        typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
      }
    }); // Initialize a jQuery object
    // A central reference to the root jQuery(document)

    var rootjQuery,
        // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    // Shortcut simple #id case for speed
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
        init = jQuery.fn.init = function (selector, context, root) {
      var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

      if (!selector) {
        return this;
      } // Method init() accepts an alternate rootjQuery
      // so migrate can support jQuery.sub (gh-2101)


      root = root || rootjQuery; // Handle HTML strings

      if (typeof selector === "string") {
        if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [null, selector, null];
        } else {
          match = rquickExpr.exec(selector);
        } // Match html or make sure no context is specified for #id


        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
            // Intentionally let the error be thrown if parseHTML is not present

            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (isFunction(this[match])) {
                  this[match](context[match]); // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }

            return this; // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);

            if (elem) {
              // Inject the element directly into the jQuery object
              this[0] = elem;
              this.length = 1;
            }

            return this;
          } // HANDLE: $(expr, $(...))

        } else if (!context || context.jquery) {
          return (context || root).find(selector); // HANDLE: $(expr, context)
          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        } // HANDLE: $(DOMElement)

      } else if (selector.nodeType) {
        this[0] = selector;
        this.length = 1;
        return this; // HANDLE: $(function)
        // Shortcut for document ready
      } else if (isFunction(selector)) {
        return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
        selector(jQuery);
      }

      return jQuery.makeArray(selector, this);
    }; // Give the init function the jQuery prototype for later instantiation


    init.prototype = jQuery.fn; // Initialize central reference

    rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/,
        // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
    jQuery.fn.extend({
      has: function (target) {
        var targets = jQuery(target, this),
            l = targets.length;
        return this.filter(function () {
          var i = 0;

          for (; i < l; i++) {
            if (jQuery.contains(this, targets[i])) {
              return true;
            }
          }
        });
      },
      closest: function (selectors, context) {
        var cur,
            i = 0,
            l = this.length,
            matched = [],
            targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

        if (!rneedsContext.test(selectors)) {
          for (; i < l; i++) {
            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
              // Always skip document fragments
              if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
              cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
              }
            }
          }
        }

        return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
      },
      // Determine the position of an element within the set
      index: function (elem) {
        // No argument, return index in parent
        if (!elem) {
          return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        } // Index in selector


        if (typeof elem === "string") {
          return indexOf.call(jQuery(elem), this[0]);
        } // Locate the position of the desired element


        return indexOf.call(this, // If it receives a jQuery object, the first element is used
        elem.jquery ? elem[0] : elem);
      },
      add: function (selector, context) {
        return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
      },
      addBack: function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      }
    });

    function sibling(cur, dir) {
      while ((cur = cur[dir]) && cur.nodeType !== 1) {}

      return cur;
    }

    jQuery.each({
      parent: function (elem) {
        var parent = elem.parentNode;
        return parent && parent.nodeType !== 11 ? parent : null;
      },
      parents: function (elem) {
        return dir(elem, "parentNode");
      },
      parentsUntil: function (elem, _i, until) {
        return dir(elem, "parentNode", until);
      },
      next: function (elem) {
        return sibling(elem, "nextSibling");
      },
      prev: function (elem) {
        return sibling(elem, "previousSibling");
      },
      nextAll: function (elem) {
        return dir(elem, "nextSibling");
      },
      prevAll: function (elem) {
        return dir(elem, "previousSibling");
      },
      nextUntil: function (elem, _i, until) {
        return dir(elem, "nextSibling", until);
      },
      prevUntil: function (elem, _i, until) {
        return dir(elem, "previousSibling", until);
      },
      siblings: function (elem) {
        return siblings((elem.parentNode || {}).firstChild, elem);
      },
      children: function (elem) {
        return siblings(elem.firstChild);
      },
      contents: function (elem) {
        if (elem.contentDocument != null && // Support: IE 11+
        // <object> elements with no `data` attribute has an object
        // `contentDocument` with a `null` prototype.
        getProto(elem.contentDocument)) {
          return elem.contentDocument;
        } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.


        if (nodeName(elem, "template")) {
          elem = elem.content || elem;
        }

        return jQuery.merge([], elem.childNodes);
      }
    }, function (name, fn) {
      jQuery.fn[name] = function (until, selector) {
        var matched = jQuery.map(this, fn, until);

        if (name.slice(-5) !== "Until") {
          selector = until;
        }

        if (selector && typeof selector === "string") {
          matched = jQuery.filter(selector, matched);
        }

        if (this.length > 1) {
          // Remove duplicates
          if (!guaranteedUnique[name]) {
            jQuery.uniqueSort(matched);
          } // Reverse order for parents* and prev-derivatives


          if (rparentsprev.test(name)) {
            matched.reverse();
          }
        }

        return this.pushStack(matched);
      };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

    function createOptions(options) {
      var object = {};
      jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
        object[flag] = true;
      });
      return object;
    }
    /*
     * Create a callback list using the following parameters:
     *
     *	options: an optional list of space-separated options that will change how
     *			the callback list behaves or a more traditional option object
     *
     * By default a callback list will act like an event callback list and can be
     * "fired" multiple times.
     *
     * Possible options:
     *
     *	once:			will ensure the callback list can only be fired once (like a Deferred)
     *
     *	memory:			will keep track of previous values and will call any callback added
     *					after the list has been fired right away with the latest "memorized"
     *					values (like a Deferred)
     *
     *	unique:			will ensure a callback can only be added once (no duplicate in the list)
     *
     *	stopOnFalse:	interrupt callings when a callback returns false
     *
     */


    jQuery.Callbacks = function (options) {
      // Convert options from String-formatted to Object-formatted if needed
      // (we check in cache first)
      options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

      var // Flag to know if list is currently firing
      firing,
          // Last fire value for non-forgettable lists
      memory,
          // Flag to know if list was already fired
      fired,
          // Flag to prevent firing
      locked,
          // Actual callback list
      list = [],
          // Queue of execution data for repeatable lists
      queue = [],
          // Index of currently firing callback (modified by add/remove as needed)
      firingIndex = -1,
          // Fire callbacks
      fire = function () {
        // Enforce single-firing
        locked = locked || options.once; // Execute callbacks for all pending executions,
        // respecting firingIndex overrides and runtime changes

        fired = firing = true;

        for (; queue.length; firingIndex = -1) {
          memory = queue.shift();

          while (++firingIndex < list.length) {
            // Run callback and check for early termination
            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
              // Jump to end and forget the data so .add doesn't re-fire
              firingIndex = list.length;
              memory = false;
            }
          }
        } // Forget the data if we're done with it


        if (!options.memory) {
          memory = false;
        }

        firing = false; // Clean up if we're done firing for good

        if (locked) {
          // Keep an empty list if we have data for future add calls
          if (memory) {
            list = []; // Otherwise, this object is spent
          } else {
            list = "";
          }
        }
      },
          // Actual Callbacks object
      self = {
        // Add a callback or a collection of callbacks to the list
        add: function () {
          if (list) {
            // If we have memory from a past run, we should fire after adding
            if (memory && !firing) {
              firingIndex = list.length - 1;
              queue.push(memory);
            }

            (function add(args) {
              jQuery.each(args, function (_, arg) {
                if (isFunction(arg)) {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && toType(arg) !== "string") {
                  // Inspect recursively
                  add(arg);
                }
              });
            })(arguments);

            if (memory && !firing) {
              fire();
            }
          }

          return this;
        },
        // Remove a callback from the list
        remove: function () {
          jQuery.each(arguments, function (_, arg) {
            var index;

            while ((index = jQuery.inArray(arg, list, index)) > -1) {
              list.splice(index, 1); // Handle firing indexes

              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          });
          return this;
        },
        // Check if a given callback is in the list.
        // If no argument is given, return whether or not list has callbacks attached.
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
        },
        // Remove all callbacks from the list
        empty: function () {
          if (list) {
            list = [];
          }

          return this;
        },
        // Disable .fire and .add
        // Abort any current/pending executions
        // Clear all callbacks and values
        disable: function () {
          locked = queue = [];
          list = memory = "";
          return this;
        },
        disabled: function () {
          return !list;
        },
        // Disable .fire
        // Also disable .add unless we have memory (since it would have no effect)
        // Abort any pending executions
        lock: function () {
          locked = queue = [];

          if (!memory && !firing) {
            list = memory = "";
          }

          return this;
        },
        locked: function () {
          return !!locked;
        },
        // Call all callbacks with the given context and arguments
        fireWith: function (context, args) {
          if (!locked) {
            args = args || [];
            args = [context, args.slice ? args.slice() : args];
            queue.push(args);

            if (!firing) {
              fire();
            }
          }

          return this;
        },
        // Call all the callbacks with the given arguments
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        // To know if the callbacks have already been called at least once
        fired: function () {
          return !!fired;
        }
      };

      return self;
    };

    function Identity(v) {
      return v;
    }

    function Thrower(ex) {
      throw ex;
    }

    function adoptValue(value, resolve, reject, noValue) {
      var method;

      try {
        // Check for promise aspect first to privilege synchronous behavior
        if (value && isFunction(method = value.promise)) {
          method.call(value).done(resolve).fail(reject); // Other thenables
        } else if (value && isFunction(method = value.then)) {
          method.call(value, resolve, reject); // Other non-thenables
        } else {
          // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
          // * false: [ value ].slice( 0 ) => resolve( value )
          // * true: [ value ].slice( 1 ) => resolve()
          resolve.apply(undefined, [value].slice(noValue));
        } // For Promises/A+, convert exceptions into rejections
        // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
        // Deferred#then to conditionally suppress rejection.

      } catch (value) {
        // Support: Android 4.0 only
        // Strict mode functions invoked without .call/.apply get global-object context
        reject.apply(undefined, [value]);
      }
    }

    jQuery.extend({
      Deferred: function (func) {
        var tuples = [// action, add listener, callbacks,
        // ... .then handlers, argument index, [final state]
        ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
            state = "pending",
            promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          "catch": function (fn) {
            return promise.then(null, fn);
          },
          // Keep pipe for back-compat
          pipe: function
            /* fnDone, fnFail, fnProgress */
          () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (_i, tuple) {
                // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
                // deferred.done(function() { bind to newDefer or newDefer.resolve })
                // deferred.fail(function() { bind to newDefer or newDefer.reject })

                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);

                  if (returned && isFunction(returned.promise)) {
                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                  } else {
                    newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          then: function (onFulfilled, onRejected, onProgress) {
            var maxDepth = 0;

            function resolve(depth, deferred, handler, special) {
              return function () {
                var that = this,
                    args = arguments,
                    mightThrow = function () {
                  var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                  // https://promisesaplus.com/#point-59
                  // Ignore double-resolution attempts

                  if (depth < maxDepth) {
                    return;
                  }

                  returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                  // https://promisesaplus.com/#point-48

                  if (returned === deferred.promise()) {
                    throw new TypeError("Thenable self-resolution");
                  } // Support: Promises/A+ sections 2.3.3.1, 3.5
                  // https://promisesaplus.com/#point-54
                  // https://promisesaplus.com/#point-75
                  // Retrieve `then` only once


                  then = returned && ( // Support: Promises/A+ section 2.3.4
                  // https://promisesaplus.com/#point-64
                  // Only check objects and functions for thenability
                  typeof returned === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                  if (isFunction(then)) {
                    // Special processors (notify) just wait for resolution
                    if (special) {
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                    } else {
                      // ...and disregard older resolution values
                      maxDepth++;
                      then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                    } // Handle all other returned values

                  } else {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Identity) {
                      that = undefined;
                      args = [returned];
                    } // Process the value(s)
                    // Default process is resolve


                    (special || deferred.resolveWith)(that, args);
                  }
                },
                    // Only normal processors (resolve) catch and reject exceptions
                process = special ? mightThrow : function () {
                  try {
                    mightThrow();
                  } catch (e) {
                    if (jQuery.Deferred.exceptionHook) {
                      jQuery.Deferred.exceptionHook(e, process.stackTrace);
                    } // Support: Promises/A+ section 2.3.3.3.4.1
                    // https://promisesaplus.com/#point-61
                    // Ignore post-resolution exceptions


                    if (depth + 1 >= maxDepth) {
                      // Only substitute handlers pass on context
                      // and multiple values (non-spec behavior)
                      if (handler !== Thrower) {
                        that = undefined;
                        args = [e];
                      }

                      deferred.rejectWith(that, args);
                    }
                  }
                }; // Support: Promises/A+ section 2.3.3.3.1
                // https://promisesaplus.com/#point-57
                // Re-resolve promises immediately to dodge false rejection from
                // subsequent errors


                if (depth) {
                  process();
                } else {
                  // Call an optional hook to record the stack, in case of exception
                  // since it's otherwise lost when execution goes async
                  if (jQuery.Deferred.getStackHook) {
                    process.stackTrace = jQuery.Deferred.getStackHook();
                  }

                  window.setTimeout(process);
                }
              };
            }

            return jQuery.Deferred(function (newDefer) {
              // progress_handlers.add( ... )
              tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

              tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

              tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
            }).promise();
          },
          // Get a promise for this deferred
          // If obj is provided, the promise aspect is added to the object
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        },
            deferred = {}; // Add list-specific methods

        jQuery.each(tuples, function (i, tuple) {
          var list = tuple[2],
              stateString = tuple[5]; // promise.progress = list.add
          // promise.done = list.add
          // promise.fail = list.add

          promise[tuple[1]] = list.add; // Handle state

          if (stateString) {
            list.add(function () {
              // state = "resolved" (i.e., fulfilled)
              // state = "rejected"
              state = stateString;
            }, // rejected_callbacks.disable
            // fulfilled_callbacks.disable
            tuples[3 - i][2].disable, // rejected_handlers.disable
            // fulfilled_handlers.disable
            tuples[3 - i][3].disable, // progress_callbacks.lock
            tuples[0][2].lock, // progress_handlers.lock
            tuples[0][3].lock);
          } // progress_handlers.fire
          // fulfilled_handlers.fire
          // rejected_handlers.fire


          list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
          // deferred.resolve = function() { deferred.resolveWith(...) }
          // deferred.reject = function() { deferred.rejectWith(...) }

          deferred[tuple[0]] = function () {
            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
            return this;
          }; // deferred.notifyWith = list.fireWith
          // deferred.resolveWith = list.fireWith
          // deferred.rejectWith = list.fireWith


          deferred[tuple[0] + "With"] = list.fireWith;
        }); // Make the deferred a promise

        promise.promise(deferred); // Call given func if any

        if (func) {
          func.call(deferred, deferred);
        } // All done!


        return deferred;
      },
      // Deferred helper
      when: function (singleValue) {
        var // count of uncompleted subordinates
        remaining = arguments.length,
            // count of unprocessed arguments
        i = remaining,
            // subordinate fulfillment data
        resolveContexts = Array(i),
            resolveValues = slice.call(arguments),
            // the primary Deferred
        primary = jQuery.Deferred(),
            // subordinate callback factory
        updateFunc = function (i) {
          return function (value) {
            resolveContexts[i] = this;
            resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;

            if (! --remaining) {
              primary.resolveWith(resolveContexts, resolveValues);
            }
          };
        }; // Single- and empty arguments are adopted like Promise.resolve


        if (remaining <= 1) {
          adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

          if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
            return primary.then();
          }
        } // Multiple arguments are aggregated like Promise.all array elements


        while (i--) {
          adoptValue(resolveValues[i], updateFunc(i), primary.reject);
        }

        return primary.promise();
      }
    }); // These usually indicate a programmer mistake during development,
    // warn about them ASAP rather than swallowing them by default.

    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

    jQuery.Deferred.exceptionHook = function (error, stack) {
      // Support: IE 8 - 9 only
      // Console exists when dev tools are open, which can happen at any time
      if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
        window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
      }
    };

    jQuery.readyException = function (error) {
      window.setTimeout(function () {
        throw error;
      });
    }; // The deferred used on DOM ready


    var readyList = jQuery.Deferred();

    jQuery.fn.ready = function (fn) {
      readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
      // happens at the time of error handling instead of callback
      // registration.
      .catch(function (error) {
        jQuery.readyException(error);
      });
      return this;
    };

    jQuery.extend({
      // Is the DOM ready to be used? Set to true once it occurs.
      isReady: false,
      // A counter to track how many items to wait for before
      // the ready event fires. See #6781
      readyWait: 1,
      // Handle when the DOM is ready
      ready: function (wait) {
        // Abort if there are pending holds or we're already ready
        if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
          return;
        } // Remember that the DOM is ready


        jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

        if (wait !== true && --jQuery.readyWait > 0) {
          return;
        } // If there are functions bound, to execute


        readyList.resolveWith(document, [jQuery]);
      }
    });
    jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

    function completed() {
      document.removeEventListener("DOMContentLoaded", completed);
      window.removeEventListener("load", completed);
      jQuery.ready();
    } // Catch cases where $(document).ready() is called
    // after the browser event has already occurred.
    // Support: IE <=9 - 10 only
    // Older IE sometimes signals "interactive" too soon


    if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
      // Handle it asynchronously to allow scripts the opportunity to delay ready
      window.setTimeout(jQuery.ready);
    } else {
      // Use the handy event callback
      document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

      window.addEventListener("load", completed);
    } // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function


    var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0,
          len = elems.length,
          bulk = key == null; // Sets many values

      if (toType(key) === "object") {
        chainable = true;

        for (i in key) {
          access(elems, fn, i, key[i], true, emptyGet, raw);
        } // Sets one value

      } else if (value !== undefined) {
        chainable = true;

        if (!isFunction(value)) {
          raw = true;
        }

        if (bulk) {
          // Bulk operations run against the entire set
          if (raw) {
            fn.call(elems, value);
            fn = null; // ...except when executing function values
          } else {
            bulk = fn;

            fn = function (elem, _key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }

        if (fn) {
          for (; i < len; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }

      if (chainable) {
        return elems;
      } // Gets


      if (bulk) {
        return fn.call(elems);
      }

      return len ? fn(elems[0], key) : emptyGet;
    }; // Matches dashed string for camelizing


    var rmsPrefix = /^-ms-/,
        rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

    function fcamelCase(_all, letter) {
      return letter.toUpperCase();
    } // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)


    function camelCase(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    }

    var acceptData = function (owner) {
      // Accepts only:
      //  - Node
      //    - Node.ELEMENT_NODE
      //    - Node.DOCUMENT_NODE
      //  - Object
      //    - Any
      return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
    };

    function Data() {
      this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;
    Data.prototype = {
      cache: function (owner) {
        // Check if the owner object already has a cache
        var value = owner[this.expando]; // If not, create one

        if (!value) {
          value = {}; // We can accept data for non-element nodes in modern browsers,
          // but we should not, see #8335.
          // Always return an empty object.

          if (acceptData(owner)) {
            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if (owner.nodeType) {
              owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
              // configurable must be true to allow the property to be
              // deleted when data is removed
            } else {
              Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: true
              });
            }
          }
        }

        return value;
      },
      set: function (owner, data, value) {
        var prop,
            cache = this.cache(owner); // Handle: [ owner, key, value ] args
        // Always use camelCase key (gh-2257)

        if (typeof data === "string") {
          cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
        } else {
          // Copy the properties one-by-one to the cache object
          for (prop in data) {
            cache[camelCase(prop)] = data[prop];
          }
        }

        return cache;
      },
      get: function (owner, key) {
        return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
        owner[this.expando] && owner[this.expando][camelCase(key)];
      },
      access: function (owner, key, value) {
        // In cases where either:
        //
        //   1. No key was specified
        //   2. A string key was specified, but no value provided
        //
        // Take the "read" path and allow the get method to determine
        // which value to return, respectively either:
        //
        //   1. The entire cache object
        //   2. The data stored at the key
        //
        if (key === undefined || key && typeof key === "string" && value === undefined) {
          return this.get(owner, key);
        } // When the key is not a string, or both a key and value
        // are specified, set or extend (existing objects) with either:
        //
        //   1. An object of properties
        //   2. A key and value
        //


        this.set(owner, key, value); // Since the "set" path can have two possible entry points
        // return the expected data based on which path was taken[*]

        return value !== undefined ? value : key;
      },
      remove: function (owner, key) {
        var i,
            cache = owner[this.expando];

        if (cache === undefined) {
          return;
        }

        if (key !== undefined) {
          // Support array or space separated string of keys
          if (Array.isArray(key)) {
            // If key is an array of keys...
            // We always set camelCase keys, so remove that.
            key = key.map(camelCase);
          } else {
            key = camelCase(key); // If a key with the spaces exists, use it.
            // Otherwise, create an array by matching non-whitespace

            key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
          }

          i = key.length;

          while (i--) {
            delete cache[key[i]];
          }
        } // Remove the expando if there's no more data


        if (key === undefined || jQuery.isEmptyObject(cache)) {
          // Support: Chrome <=35 - 45
          // Webkit & Blink performance suffers when deleting properties
          // from DOM nodes, so set to undefined instead
          // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
          if (owner.nodeType) {
            owner[this.expando] = undefined;
          } else {
            delete owner[this.expando];
          }
        }
      },
      hasData: function (owner) {
        var cache = owner[this.expando];
        return cache !== undefined && !jQuery.isEmptyObject(cache);
      }
    };
    var dataPriv = new Data();
    var dataUser = new Data(); //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
        rmultiDash = /[A-Z]/g;

    function getData(data) {
      if (data === "true") {
        return true;
      }

      if (data === "false") {
        return false;
      }

      if (data === "null") {
        return null;
      } // Only convert to a number if it doesn't change the string


      if (data === +data + "") {
        return +data;
      }

      if (rbrace.test(data)) {
        return JSON.parse(data);
      }

      return data;
    }

    function dataAttr(elem, key, data) {
      var name; // If nothing was found internally, try to fetch any
      // data from the HTML5 data-* attribute

      if (data === undefined && elem.nodeType === 1) {
        name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
        data = elem.getAttribute(name);

        if (typeof data === "string") {
          try {
            data = getData(data);
          } catch (e) {} // Make sure we set the data so it isn't changed later


          dataUser.set(elem, key, data);
        } else {
          data = undefined;
        }
      }

      return data;
    }

    jQuery.extend({
      hasData: function (elem) {
        return dataUser.hasData(elem) || dataPriv.hasData(elem);
      },
      data: function (elem, name, data) {
        return dataUser.access(elem, name, data);
      },
      removeData: function (elem, name) {
        dataUser.remove(elem, name);
      },
      // TODO: Now that all calls to _data and _removeData have been replaced
      // with direct calls to dataPriv methods, these can be deprecated.
      _data: function (elem, name, data) {
        return dataPriv.access(elem, name, data);
      },
      _removeData: function (elem, name) {
        dataPriv.remove(elem, name);
      }
    });
    jQuery.fn.extend({
      data: function (key, value) {
        var i,
            name,
            data,
            elem = this[0],
            attrs = elem && elem.attributes; // Gets all values

        if (key === undefined) {
          if (this.length) {
            data = dataUser.get(elem);

            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
              i = attrs.length;

              while (i--) {
                // Support: IE 11 only
                // The attrs elements can be null (#14894)
                if (attrs[i]) {
                  name = attrs[i].name;

                  if (name.indexOf("data-") === 0) {
                    name = camelCase(name.slice(5));
                    dataAttr(elem, name, data[name]);
                  }
                }
              }

              dataPriv.set(elem, "hasDataAttrs", true);
            }
          }

          return data;
        } // Sets multiple values


        if (typeof key === "object") {
          return this.each(function () {
            dataUser.set(this, key);
          });
        }

        return access(this, function (value) {
          var data; // The calling jQuery object (element matches) is not empty
          // (and therefore has an element appears at this[ 0 ]) and the
          // `value` parameter was not undefined. An empty jQuery object
          // will result in `undefined` for elem = this[ 0 ] which will
          // throw an exception if an attempt to read a data cache is made.

          if (elem && value === undefined) {
            // Attempt to get data from the cache
            // The key will always be camelCased in Data
            data = dataUser.get(elem, key);

            if (data !== undefined) {
              return data;
            } // Attempt to "discover" the data in
            // HTML5 custom data-* attrs


            data = dataAttr(elem, key);

            if (data !== undefined) {
              return data;
            } // We tried really hard, but the data doesn't exist.


            return;
          } // Set the data...


          this.each(function () {
            // We always store the camelCased key
            dataUser.set(this, key, value);
          });
        }, null, value, arguments.length > 1, null, true);
      },
      removeData: function (key) {
        return this.each(function () {
          dataUser.remove(this, key);
        });
      }
    });
    jQuery.extend({
      queue: function (elem, type, data) {
        var queue;

        if (elem) {
          type = (type || "fx") + "queue";
          queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

          if (data) {
            if (!queue || Array.isArray(data)) {
              queue = dataPriv.access(elem, type, jQuery.makeArray(data));
            } else {
              queue.push(data);
            }
          }

          return queue || [];
        }
      },
      dequeue: function (elem, type) {
        type = type || "fx";

        var queue = jQuery.queue(elem, type),
            startLength = queue.length,
            fn = queue.shift(),
            hooks = jQuery._queueHooks(elem, type),
            next = function () {
          jQuery.dequeue(elem, type);
        }; // If the fx queue is dequeued, always remove the progress sentinel


        if (fn === "inprogress") {
          fn = queue.shift();
          startLength--;
        }

        if (fn) {
          // Add a progress sentinel to prevent the fx queue from being
          // automatically dequeued
          if (type === "fx") {
            queue.unshift("inprogress");
          } // Clear up the last queue stop function


          delete hooks.stop;
          fn.call(elem, next, hooks);
        }

        if (!startLength && hooks) {
          hooks.empty.fire();
        }
      },
      // Not public - generate a queueHooks object, or return the current one
      _queueHooks: function (elem, type) {
        var key = type + "queueHooks";
        return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
          empty: jQuery.Callbacks("once memory").add(function () {
            dataPriv.remove(elem, [type + "queue", key]);
          })
        });
      }
    });
    jQuery.fn.extend({
      queue: function (type, data) {
        var setter = 2;

        if (typeof type !== "string") {
          data = type;
          type = "fx";
          setter--;
        }

        if (arguments.length < setter) {
          return jQuery.queue(this[0], type);
        }

        return data === undefined ? this : this.each(function () {
          var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

          jQuery._queueHooks(this, type);

          if (type === "fx" && queue[0] !== "inprogress") {
            jQuery.dequeue(this, type);
          }
        });
      },
      dequeue: function (type) {
        return this.each(function () {
          jQuery.dequeue(this, type);
        });
      },
      clearQueue: function (type) {
        return this.queue(type || "fx", []);
      },
      // Get a promise resolved when queues of a certain type
      // are emptied (fx is the type by default)
      promise: function (type, obj) {
        var tmp,
            count = 1,
            defer = jQuery.Deferred(),
            elements = this,
            i = this.length,
            resolve = function () {
          if (! --count) {
            defer.resolveWith(elements, [elements]);
          }
        };

        if (typeof type !== "string") {
          obj = type;
          type = undefined;
        }

        type = type || "fx";

        while (i--) {
          tmp = dataPriv.get(elements[i], type + "queueHooks");

          if (tmp && tmp.empty) {
            count++;
            tmp.empty.add(resolve);
          }
        }

        resolve();
        return defer.promise(obj);
      }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
    var cssExpand = ["Top", "Right", "Bottom", "Left"];
    var documentElement = document.documentElement;

    var isAttached = function (elem) {
      return jQuery.contains(elem.ownerDocument, elem);
    },
        composed = {
      composed: true
    }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
    // Check attachment across shadow DOM boundaries when possible (gh-3504)
    // Support: iOS 10.0-10.2 only
    // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
    // leading to errors. We need to check for `getRootNode`.


    if (documentElement.getRootNode) {
      isAttached = function (elem) {
        return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
      };
    }

    var isHiddenWithinTree = function (elem, el) {
      // isHiddenWithinTree might be called from jQuery#filter function;
      // in that case, element will be second argument
      elem = el || elem; // Inline style trumps all

      return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
      // Support: Firefox <=43 - 45
      // Disconnected elements can have computed display: none, so first confirm that elem is
      // in the document.
      isAttached(elem) && jQuery.css(elem, "display") === "none";
    };

    function adjustCSS(elem, prop, valueParts, tween) {
      var adjusted,
          scale,
          maxIterations = 20,
          currentValue = tween ? function () {
        return tween.cur();
      } : function () {
        return jQuery.css(elem, prop, "");
      },
          initial = currentValue(),
          unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
          // Starting value computation is required for potential unit mismatches
      initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

      if (initialInUnit && initialInUnit[3] !== unit) {
        // Support: Firefox <=54
        // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
        initial = initial / 2; // Trust units reported by jQuery.css

        unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

        initialInUnit = +initial || 1;

        while (maxIterations--) {
          // Evaluate and update our best guess (doubling guesses that zero out).
          // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
          jQuery.style(elem, prop, initialInUnit + unit);

          if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
            maxIterations = 0;
          }

          initialInUnit = initialInUnit / scale;
        }

        initialInUnit = initialInUnit * 2;
        jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

        valueParts = valueParts || [];
      }

      if (valueParts) {
        initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

        adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

        if (tween) {
          tween.unit = unit;
          tween.start = initialInUnit;
          tween.end = adjusted;
        }
      }

      return adjusted;
    }

    var defaultDisplayMap = {};

    function getDefaultDisplay(elem) {
      var temp,
          doc = elem.ownerDocument,
          nodeName = elem.nodeName,
          display = defaultDisplayMap[nodeName];

      if (display) {
        return display;
      }

      temp = doc.body.appendChild(doc.createElement(nodeName));
      display = jQuery.css(temp, "display");
      temp.parentNode.removeChild(temp);

      if (display === "none") {
        display = "block";
      }

      defaultDisplayMap[nodeName] = display;
      return display;
    }

    function showHide(elements, show) {
      var display,
          elem,
          values = [],
          index = 0,
          length = elements.length; // Determine new display value for elements that need to change

      for (; index < length; index++) {
        elem = elements[index];

        if (!elem.style) {
          continue;
        }

        display = elem.style.display;

        if (show) {
          // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
          // check is required in this first loop unless we have a nonempty display value (either
          // inline or about-to-be-restored)
          if (display === "none") {
            values[index] = dataPriv.get(elem, "display") || null;

            if (!values[index]) {
              elem.style.display = "";
            }
          }

          if (elem.style.display === "" && isHiddenWithinTree(elem)) {
            values[index] = getDefaultDisplay(elem);
          }
        } else {
          if (display !== "none") {
            values[index] = "none"; // Remember what we're overwriting

            dataPriv.set(elem, "display", display);
          }
        }
      } // Set the display of the elements in a second loop to avoid constant reflow


      for (index = 0; index < length; index++) {
        if (values[index] != null) {
          elements[index].style.display = values[index];
        }
      }

      return elements;
    }

    jQuery.fn.extend({
      show: function () {
        return showHide(this, true);
      },
      hide: function () {
        return showHide(this);
      },
      toggle: function (state) {
        if (typeof state === "boolean") {
          return state ? this.show() : this.hide();
        }

        return this.each(function () {
          if (isHiddenWithinTree(this)) {
            jQuery(this).show();
          } else {
            jQuery(this).hide();
          }
        });
      }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i;
    var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
    var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

    (function () {
      var fragment = document.createDocumentFragment(),
          div = fragment.appendChild(document.createElement("div")),
          input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
      // Check state lost if the name is set (#11217)
      // Support: Windows Web Apps (WWA)
      // `name` and `type` must use .setAttribute for WWA (#14901)

      input.setAttribute("type", "radio");
      input.setAttribute("checked", "checked");
      input.setAttribute("name", "t");
      div.appendChild(input); // Support: Android <=4.1 only
      // Older WebKit doesn't clone checked state correctly in fragments

      support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
      // Make sure textarea (and checkbox) defaultValue is properly cloned

      div.innerHTML = "<textarea>x</textarea>";
      support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
      // IE <=9 replaces <option> tags with their contents when inserted outside of
      // the select element.

      div.innerHTML = "<option></option>";
      support.option = !!div.lastChild;
    })(); // We have to close these tags to support XHTML (#13200)


    var wrapMap = {
      // XHTML parsers do not magically insert elements in the
      // same way that tag soup parsers do. So we cannot shorten
      // this by omitting <tbody> or other required elements.
      thead: [1, "<table>", "</table>"],
      col: [2, "<table><colgroup>", "</colgroup></table>"],
      tr: [2, "<table><tbody>", "</tbody></table>"],
      td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
      _default: [0, "", ""]
    };
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td; // Support: IE <=9 only

    if (!support.option) {
      wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
    }

    function getAll(context, tag) {
      // Support: IE <=9 - 11 only
      // Use typeof to avoid zero-argument method invocation on host objects (#15151)
      var ret;

      if (typeof context.getElementsByTagName !== "undefined") {
        ret = context.getElementsByTagName(tag || "*");
      } else if (typeof context.querySelectorAll !== "undefined") {
        ret = context.querySelectorAll(tag || "*");
      } else {
        ret = [];
      }

      if (tag === undefined || tag && nodeName(context, tag)) {
        return jQuery.merge([context], ret);
      }

      return ret;
    } // Mark scripts as having already been evaluated


    function setGlobalEval(elems, refElements) {
      var i = 0,
          l = elems.length;

      for (; i < l; i++) {
        dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
      }
    }

    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
      var elem,
          tmp,
          tag,
          wrap,
          attached,
          j,
          fragment = context.createDocumentFragment(),
          nodes = [],
          i = 0,
          l = elems.length;

      for (; i < l; i++) {
        elem = elems[i];

        if (elem || elem === 0) {
          // Add nodes directly
          if (toType(elem) === "object") {
            // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
          } else {
            tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

            j = wrap[0];

            while (j--) {
              tmp = tmp.lastChild;
            } // Support: Android <=4.0 only, PhantomJS 1 only
            // push.apply(_, arraylike) throws on ancient WebKit


            jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

            tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

            tmp.textContent = "";
          }
        }
      } // Remove wrapper from fragment


      fragment.textContent = "";
      i = 0;

      while (elem = nodes[i++]) {
        // Skip elements already in the context collection (trac-4087)
        if (selection && jQuery.inArray(elem, selection) > -1) {
          if (ignored) {
            ignored.push(elem);
          }

          continue;
        }

        attached = isAttached(elem); // Append to fragment

        tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

        if (attached) {
          setGlobalEval(tmp);
        } // Capture executables


        if (scripts) {
          j = 0;

          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || "")) {
              scripts.push(elem);
            }
          }
        }
      }

      return fragment;
    }

    var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
      return true;
    }

    function returnFalse() {
      return false;
    } // Support: IE <=9 - 11+
    // focus() and blur() are asynchronous, except when they are no-op.
    // So expect focus to be synchronous when the element is already active,
    // and blur to be synchronous when the element is not already active.
    // (focus and blur are always synchronous in other supported browsers,
    // this just defines when we can count on it).


    function expectSync(elem, type) {
      return elem === safeActiveElement() === (type === "focus");
    } // Support: IE <=9 only
    // Accessing document.activeElement can throw unexpectedly
    // https://bugs.jquery.com/ticket/13393


    function safeActiveElement() {
      try {
        return document.activeElement;
      } catch (err) {}
    }

    function on(elem, types, selector, data, fn, one) {
      var origFn, type; // Types can be a map of types/handlers

      if (typeof types === "object") {
        // ( types-Object, selector, data )
        if (typeof selector !== "string") {
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }

        for (type in types) {
          on(elem, type, selector, data, types[type], one);
        }

        return elem;
      }

      if (data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === "string") {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }

      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return elem;
      }

      if (one === 1) {
        origFn = fn;

        fn = function (event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        }; // Use same guid so caller can remove using origFn


        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }

      return elem.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    }
    /*
     * Helper functions for managing events -- not part of the public interface.
     * Props to Dean Edwards' addEvent library for many of the ideas.
     */


    jQuery.event = {
      global: {},
      add: function (elem, types, handler, data, selector) {
        var handleObjIn,
            eventHandle,
            tmp,
            events,
            t,
            handleObj,
            special,
            handlers,
            type,
            namespaces,
            origType,
            elemData = dataPriv.get(elem); // Only attach events to objects that accept data

        if (!acceptData(elem)) {
          return;
        } // Caller can pass in an object of custom data in lieu of the handler


        if (handler.handler) {
          handleObjIn = handler;
          handler = handleObjIn.handler;
          selector = handleObjIn.selector;
        } // Ensure that invalid selectors throw exceptions at attach time
        // Evaluate against documentElement in case elem is a non-element node (e.g., document)


        if (selector) {
          jQuery.find.matchesSelector(documentElement, selector);
        } // Make sure that the handler has a unique ID, used to find/remove it later


        if (!handler.guid) {
          handler.guid = jQuery.guid++;
        } // Init the element's event structure and main handler, if this is the first


        if (!(events = elemData.events)) {
          events = elemData.events = Object.create(null);
        }

        if (!(eventHandle = elemData.handle)) {
          eventHandle = elemData.handle = function (e) {
            // Discard the second event of a jQuery.event.trigger() and
            // when an event is called after a page has unloaded
            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
          };
        } // Handle multiple events separated by a space


        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;

        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

          if (!type) {
            continue;
          } // If event changes its type, use the special event handlers for the changed type


          special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

          type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

          special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

          handleObj = jQuery.extend({
            type: type,
            origType: origType,
            data: data,
            handler: handler,
            guid: handler.guid,
            selector: selector,
            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
            namespace: namespaces.join(".")
          }, handleObjIn); // Init the event handler queue if we're the first

          if (!(handlers = events[type])) {
            handlers = events[type] = [];
            handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

            if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
              if (elem.addEventListener) {
                elem.addEventListener(type, eventHandle);
              }
            }
          }

          if (special.add) {
            special.add.call(elem, handleObj);

            if (!handleObj.handler.guid) {
              handleObj.handler.guid = handler.guid;
            }
          } // Add to the element's handler list, delegates in front


          if (selector) {
            handlers.splice(handlers.delegateCount++, 0, handleObj);
          } else {
            handlers.push(handleObj);
          } // Keep track of which events have ever been used, for event optimization


          jQuery.event.global[type] = true;
        }
      },
      // Detach an event or set of events from an element
      remove: function (elem, types, handler, selector, mappedTypes) {
        var j,
            origCount,
            tmp,
            events,
            t,
            handleObj,
            special,
            handlers,
            type,
            namespaces,
            origType,
            elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

        if (!elemData || !(events = elemData.events)) {
          return;
        } // Once for each type.namespace in types; type may be omitted


        types = (types || "").match(rnothtmlwhite) || [""];
        t = types.length;

        while (t--) {
          tmp = rtypenamespace.exec(types[t]) || [];
          type = origType = tmp[1];
          namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

          if (!type) {
            for (type in events) {
              jQuery.event.remove(elem, type + types[t], handler, selector, true);
            }

            continue;
          }

          special = jQuery.event.special[type] || {};
          type = (selector ? special.delegateType : special.bindType) || type;
          handlers = events[type] || [];
          tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

          origCount = j = handlers.length;

          while (j--) {
            handleObj = handlers[j];

            if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
              handlers.splice(j, 1);

              if (handleObj.selector) {
                handlers.delegateCount--;
              }

              if (special.remove) {
                special.remove.call(elem, handleObj);
              }
            }
          } // Remove generic event handler if we removed something and no more handlers exist
          // (avoids potential for endless recursion during removal of special event handlers)


          if (origCount && !handlers.length) {
            if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
              jQuery.removeEvent(elem, type, elemData.handle);
            }

            delete events[type];
          }
        } // Remove data and the expando if it's no longer used


        if (jQuery.isEmptyObject(events)) {
          dataPriv.remove(elem, "handle events");
        }
      },
      dispatch: function (nativeEvent) {
        var i,
            j,
            ret,
            matched,
            handleObj,
            handlerQueue,
            args = new Array(arguments.length),
            // Make a writable jQuery.Event from the native event object
        event = jQuery.event.fix(nativeEvent),
            handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
            special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

        args[0] = event;

        for (i = 1; i < arguments.length; i++) {
          args[i] = arguments[i];
        }

        event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

        if (special.preDispatch && special.preDispatch.call(this, event) === false) {
          return;
        } // Determine handlers


        handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

        i = 0;

        while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
          event.currentTarget = matched.elem;
          j = 0;

          while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
            // If the event is namespaced, then each handler is only invoked if it is
            // specially universal or its namespaces are a superset of the event's.
            if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
              event.handleObj = handleObj;
              event.data = handleObj.data;
              ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

              if (ret !== undefined) {
                if ((event.result = ret) === false) {
                  event.preventDefault();
                  event.stopPropagation();
                }
              }
            }
          }
        } // Call the postDispatch hook for the mapped type


        if (special.postDispatch) {
          special.postDispatch.call(this, event);
        }

        return event.result;
      },
      handlers: function (event, handlers) {
        var i,
            handleObj,
            sel,
            matchedHandlers,
            matchedSelectors,
            handlerQueue = [],
            delegateCount = handlers.delegateCount,
            cur = event.target; // Find delegate handlers

        if (delegateCount && // Support: IE <=9
        // Black-hole SVG <use> instance trees (trac-13180)
        cur.nodeType && // Support: Firefox <=42
        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
        // Support: IE 11 only
        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
        !(event.type === "click" && event.button >= 1)) {
          for (; cur !== this; cur = cur.parentNode || this) {
            // Don't check non-elements (#13208)
            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
              matchedHandlers = [];
              matchedSelectors = {};

              for (i = 0; i < delegateCount; i++) {
                handleObj = handlers[i]; // Don't conflict with Object.prototype properties (#13203)

                sel = handleObj.selector + " ";

                if (matchedSelectors[sel] === undefined) {
                  matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                }

                if (matchedSelectors[sel]) {
                  matchedHandlers.push(handleObj);
                }
              }

              if (matchedHandlers.length) {
                handlerQueue.push({
                  elem: cur,
                  handlers: matchedHandlers
                });
              }
            }
          }
        } // Add the remaining (directly-bound) handlers


        cur = this;

        if (delegateCount < handlers.length) {
          handlerQueue.push({
            elem: cur,
            handlers: handlers.slice(delegateCount)
          });
        }

        return handlerQueue;
      },
      addProp: function (name, hook) {
        Object.defineProperty(jQuery.Event.prototype, name, {
          enumerable: true,
          configurable: true,
          get: isFunction(hook) ? function () {
            if (this.originalEvent) {
              return hook(this.originalEvent);
            }
          } : function () {
            if (this.originalEvent) {
              return this.originalEvent[name];
            }
          },
          set: function (value) {
            Object.defineProperty(this, name, {
              enumerable: true,
              configurable: true,
              writable: true,
              value: value
            });
          }
        });
      },
      fix: function (originalEvent) {
        return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
      },
      special: {
        load: {
          // Prevent triggered image.load events from bubbling to window.load
          noBubble: true
        },
        click: {
          // Utilize native event to ensure correct state for checkable inputs
          setup: function (data) {
            // For mutual compressibility with _default, replace `this` access with a local var.
            // `|| data` is dead code meant only to preserve the variable through minification.
            var el = this || data; // Claim the first handler

            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              // dataPriv.set( el, "click", ... )
              leverageNative(el, "click", returnTrue);
            } // Return false to allow normal processing in the caller


            return false;
          },
          trigger: function (data) {
            // For mutual compressibility with _default, replace `this` access with a local var.
            // `|| data` is dead code meant only to preserve the variable through minification.
            var el = this || data; // Force setup before triggering a click

            if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
              leverageNative(el, "click");
            } // Return non-false to allow normal event-path propagation


            return true;
          },
          // For cross-browser consistency, suppress native .click() on links
          // Also prevent it if we're currently inside a leveraged native-event stack
          _default: function (event) {
            var target = event.target;
            return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
          }
        },
        beforeunload: {
          postDispatch: function (event) {
            // Support: Firefox 20+
            // Firefox doesn't alert if the returnValue field is not set.
            if (event.result !== undefined && event.originalEvent) {
              event.originalEvent.returnValue = event.result;
            }
          }
        }
      }
    }; // Ensure the presence of an event listener that handles manually-triggered
    // synthetic events by interrupting progress until reinvoked in response to
    // *native* events that it fires directly, ensuring that state changes have
    // already occurred before other listeners are invoked.

    function leverageNative(el, type, expectSync) {
      // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
      if (!expectSync) {
        if (dataPriv.get(el, type) === undefined) {
          jQuery.event.add(el, type, returnTrue);
        }

        return;
      } // Register the controller as a special universal handler for all event namespaces


      dataPriv.set(el, type, false);
      jQuery.event.add(el, type, {
        namespace: false,
        handler: function (event) {
          var notAsync,
              result,
              saved = dataPriv.get(this, type);

          if (event.isTrigger & 1 && this[type]) {
            // Interrupt processing of the outer synthetic .trigger()ed event
            // Saved data should be false in such cases, but might be a leftover capture object
            // from an async native handler (gh-4350)
            if (!saved.length) {
              // Store arguments for use when handling the inner native event
              // There will always be at least one argument (an event object), so this array
              // will not be confused with a leftover capture object.
              saved = slice.call(arguments);
              dataPriv.set(this, type, saved); // Trigger the native event and capture its result
              // Support: IE <=9 - 11+
              // focus() and blur() are asynchronous

              notAsync = expectSync(this, type);
              this[type]();
              result = dataPriv.get(this, type);

              if (saved !== result || notAsync) {
                dataPriv.set(this, type, false);
              } else {
                result = {};
              }

              if (saved !== result) {
                // Cancel the outer synthetic event
                event.stopImmediatePropagation();
                event.preventDefault(); // Support: Chrome 86+
                // In Chrome, if an element having a focusout handler is blurred by
                // clicking outside of it, it invokes the handler synchronously. If
                // that handler calls `.remove()` on the element, the data is cleared,
                // leaving `result` undefined. We need to guard against this.

                return result && result.value;
              } // If this is an inner synthetic event for an event with a bubbling surrogate
              // (focus or blur), assume that the surrogate already propagated from triggering the
              // native event and prevent that from happening again here.
              // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
              // bubbling surrogate propagates *after* the non-bubbling base), but that seems
              // less bad than duplication.

            } else if ((jQuery.event.special[type] || {}).delegateType) {
              event.stopPropagation();
            } // If this is a native event triggered above, everything is now in order
            // Fire an inner synthetic event with the original arguments

          } else if (saved.length) {
            // ...and capture the result
            dataPriv.set(this, type, {
              value: jQuery.event.trigger( // Support: IE <=9 - 11+
              // Extend with the prototype to reset the above stopImmediatePropagation()
              jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
            }); // Abort handling of the native event

            event.stopImmediatePropagation();
          }
        }
      });
    }

    jQuery.removeEvent = function (elem, type, handle) {
      // This "if" is needed for plain objects
      if (elem.removeEventListener) {
        elem.removeEventListener(type, handle);
      }
    };

    jQuery.Event = function (src, props) {
      // Allow instantiation without the 'new' keyword
      if (!(this instanceof jQuery.Event)) {
        return new jQuery.Event(src, props);
      } // Event object


      if (src && src.type) {
        this.originalEvent = src;
        this.type = src.type; // Events bubbling up the document may have been marked as prevented
        // by a handler lower down the tree; reflect the correct value.

        this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
        src.returnValue === false ? returnTrue : returnFalse; // Create target properties
        // Support: Safari <=6 - 7 only
        // Target should not be a text node (#504, #13143)

        this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
        this.currentTarget = src.currentTarget;
        this.relatedTarget = src.relatedTarget; // Event type
      } else {
        this.type = src;
      } // Put explicitly provided properties onto the event object


      if (props) {
        jQuery.extend(this, props);
      } // Create a timestamp if incoming event doesn't have one


      this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

      this[jQuery.expando] = true;
    }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


    jQuery.Event.prototype = {
      constructor: jQuery.Event,
      isDefaultPrevented: returnFalse,
      isPropagationStopped: returnFalse,
      isImmediatePropagationStopped: returnFalse,
      isSimulated: false,
      preventDefault: function () {
        var e = this.originalEvent;
        this.isDefaultPrevented = returnTrue;

        if (e && !this.isSimulated) {
          e.preventDefault();
        }
      },
      stopPropagation: function () {
        var e = this.originalEvent;
        this.isPropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopPropagation();
        }
      },
      stopImmediatePropagation: function () {
        var e = this.originalEvent;
        this.isImmediatePropagationStopped = returnTrue;

        if (e && !this.isSimulated) {
          e.stopImmediatePropagation();
        }

        this.stopPropagation();
      }
    }; // Includes all common event props including KeyEvent and MouseEvent specific props

    jQuery.each({
      altKey: true,
      bubbles: true,
      cancelable: true,
      changedTouches: true,
      ctrlKey: true,
      detail: true,
      eventPhase: true,
      metaKey: true,
      pageX: true,
      pageY: true,
      shiftKey: true,
      view: true,
      "char": true,
      code: true,
      charCode: true,
      key: true,
      keyCode: true,
      button: true,
      buttons: true,
      clientX: true,
      clientY: true,
      offsetX: true,
      offsetY: true,
      pointerId: true,
      pointerType: true,
      screenX: true,
      screenY: true,
      targetTouches: true,
      toElement: true,
      touches: true,
      which: true
    }, jQuery.event.addProp);
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (type, delegateType) {
      jQuery.event.special[type] = {
        // Utilize native event if possible so blur/focus sequence is correct
        setup: function () {
          // Claim the first handler
          // dataPriv.set( this, "focus", ... )
          // dataPriv.set( this, "blur", ... )
          leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

          return false;
        },
        trigger: function () {
          // Force setup before trigger
          leverageNative(this, type); // Return non-false to allow normal event-path propagation

          return true;
        },
        // Suppress native focus or blur as it's already being fired
        // in leverageNative.
        _default: function () {
          return true;
        },
        delegateType: delegateType
      };
    }); // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).

    jQuery.each({
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      pointerenter: "pointerover",
      pointerleave: "pointerout"
    }, function (orig, fix) {
      jQuery.event.special[orig] = {
        delegateType: fix,
        bindType: fix,
        handle: function (event) {
          var ret,
              target = this,
              related = event.relatedTarget,
              handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
          // NB: No relatedTarget if the mouse left/entered the browser window

          if (!related || related !== target && !jQuery.contains(target, related)) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply(this, arguments);
            event.type = fix;
          }

          return ret;
        }
      };
    });
    jQuery.fn.extend({
      on: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn);
      },
      one: function (types, selector, data, fn) {
        return on(this, types, selector, data, fn, 1);
      },
      off: function (types, selector, fn) {
        var handleObj, type;

        if (types && types.preventDefault && types.handleObj) {
          // ( event )  dispatched jQuery.Event
          handleObj = types.handleObj;
          jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
          return this;
        }

        if (typeof types === "object") {
          // ( types-object [, selector] )
          for (type in types) {
            this.off(type, selector, types[type]);
          }

          return this;
        }

        if (selector === false || typeof selector === "function") {
          // ( types [, fn] )
          fn = selector;
          selector = undefined;
        }

        if (fn === false) {
          fn = returnFalse;
        }

        return this.each(function () {
          jQuery.event.remove(this, types, fn, selector);
        });
      }
    });
    var // Support: IE <=10 - 11, Edge 12 - 13 only
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i,
        // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
        rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

    function manipulationTarget(elem, content) {
      if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
        return jQuery(elem).children("tbody")[0] || elem;
      }

      return elem;
    } // Replace/restore the type attribute of script elements for safe DOM manipulation


    function disableScript(elem) {
      elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
      return elem;
    }

    function restoreScript(elem) {
      if ((elem.type || "").slice(0, 5) === "true/") {
        elem.type = elem.type.slice(5);
      } else {
        elem.removeAttribute("type");
      }

      return elem;
    }

    function cloneCopyEvent(src, dest) {
      var i, l, type, pdataOld, udataOld, udataCur, events;

      if (dest.nodeType !== 1) {
        return;
      } // 1. Copy private data: events, handlers, etc.


      if (dataPriv.hasData(src)) {
        pdataOld = dataPriv.get(src);
        events = pdataOld.events;

        if (events) {
          dataPriv.remove(dest, "handle events");

          for (type in events) {
            for (i = 0, l = events[type].length; i < l; i++) {
              jQuery.event.add(dest, type, events[type][i]);
            }
          }
        }
      } // 2. Copy user data


      if (dataUser.hasData(src)) {
        udataOld = dataUser.access(src);
        udataCur = jQuery.extend({}, udataOld);
        dataUser.set(dest, udataCur);
      }
    } // Fix IE bugs, see support tests


    function fixInput(src, dest) {
      var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

      if (nodeName === "input" && rcheckableType.test(src.type)) {
        dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
      } else if (nodeName === "input" || nodeName === "textarea") {
        dest.defaultValue = src.defaultValue;
      }
    }

    function domManip(collection, args, callback, ignored) {
      // Flatten any nested arrays
      args = flat(args);
      var fragment,
          first,
          scripts,
          hasScripts,
          node,
          doc,
          i = 0,
          l = collection.length,
          iNoClone = l - 1,
          value = args[0],
          valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

      if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
        return collection.each(function (index) {
          var self = collection.eq(index);

          if (valueIsFunction) {
            args[0] = value.call(this, index, self.html());
          }

          domManip(self, args, callback, ignored);
        });
      }

      if (l) {
        fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
        first = fragment.firstChild;

        if (fragment.childNodes.length === 1) {
          fragment = first;
        } // Require either new content or an interest in ignored elements to invoke the callback


        if (first || ignored) {
          scripts = jQuery.map(getAll(fragment, "script"), disableScript);
          hasScripts = scripts.length; // Use the original fragment for the last item
          // instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).

          for (; i < l; i++) {
            node = fragment;

            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

              if (hasScripts) {
                // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                jQuery.merge(scripts, getAll(node, "script"));
              }
            }

            callback.call(collection[i], node, i);
          }

          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

            jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];

              if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                if (node.src && (node.type || "").toLowerCase() !== "module") {
                  // Optional AJAX dependency, but won't run scripts if not present
                  if (jQuery._evalUrl && !node.noModule) {
                    jQuery._evalUrl(node.src, {
                      nonce: node.nonce || node.getAttribute("nonce")
                    }, doc);
                  }
                } else {
                  DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                }
              }
            }
          }
        }
      }

      return collection;
    }

    function remove(elem, selector, keepData) {
      var node,
          nodes = selector ? jQuery.filter(selector, elem) : elem,
          i = 0;

      for (; (node = nodes[i]) != null; i++) {
        if (!keepData && node.nodeType === 1) {
          jQuery.cleanData(getAll(node));
        }

        if (node.parentNode) {
          if (keepData && isAttached(node)) {
            setGlobalEval(getAll(node, "script"));
          }

          node.parentNode.removeChild(node);
        }
      }

      return elem;
    }

    jQuery.extend({
      htmlPrefilter: function (html) {
        return html;
      },
      clone: function (elem, dataAndEvents, deepDataAndEvents) {
        var i,
            l,
            srcElements,
            destElements,
            clone = elem.cloneNode(true),
            inPage = isAttached(elem); // Fix IE cloning issues

        if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
          // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
          destElements = getAll(clone);
          srcElements = getAll(elem);

          for (i = 0, l = srcElements.length; i < l; i++) {
            fixInput(srcElements[i], destElements[i]);
          }
        } // Copy the events from the original to the clone


        if (dataAndEvents) {
          if (deepDataAndEvents) {
            srcElements = srcElements || getAll(elem);
            destElements = destElements || getAll(clone);

            for (i = 0, l = srcElements.length; i < l; i++) {
              cloneCopyEvent(srcElements[i], destElements[i]);
            }
          } else {
            cloneCopyEvent(elem, clone);
          }
        } // Preserve script evaluation history


        destElements = getAll(clone, "script");

        if (destElements.length > 0) {
          setGlobalEval(destElements, !inPage && getAll(elem, "script"));
        } // Return the cloned set


        return clone;
      },
      cleanData: function (elems) {
        var data,
            elem,
            type,
            special = jQuery.event.special,
            i = 0;

        for (; (elem = elems[i]) !== undefined; i++) {
          if (acceptData(elem)) {
            if (data = elem[dataPriv.expando]) {
              if (data.events) {
                for (type in data.events) {
                  if (special[type]) {
                    jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                  } else {
                    jQuery.removeEvent(elem, type, data.handle);
                  }
                }
              } // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove


              elem[dataPriv.expando] = undefined;
            }

            if (elem[dataUser.expando]) {
              // Support: Chrome <=35 - 45+
              // Assign undefined instead of using delete, see Data#remove
              elem[dataUser.expando] = undefined;
            }
          }
        }
      }
    });
    jQuery.fn.extend({
      detach: function (selector) {
        return remove(this, selector, true);
      },
      remove: function (selector) {
        return remove(this, selector);
      },
      text: function (value) {
        return access(this, function (value) {
          return value === undefined ? jQuery.text(this) : this.empty().each(function () {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              this.textContent = value;
            }
          });
        }, null, value, arguments.length);
      },
      append: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.appendChild(elem);
          }
        });
      },
      prepend: function () {
        return domManip(this, arguments, function (elem) {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            var target = manipulationTarget(this, elem);
            target.insertBefore(elem, target.firstChild);
          }
        });
      },
      before: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this);
          }
        });
      },
      after: function () {
        return domManip(this, arguments, function (elem) {
          if (this.parentNode) {
            this.parentNode.insertBefore(elem, this.nextSibling);
          }
        });
      },
      empty: function () {
        var elem,
            i = 0;

        for (; (elem = this[i]) != null; i++) {
          if (elem.nodeType === 1) {
            // Prevent memory leaks
            jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

            elem.textContent = "";
          }
        }

        return this;
      },
      clone: function (dataAndEvents, deepDataAndEvents) {
        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
        return this.map(function () {
          return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
        });
      },
      html: function (value) {
        return access(this, function (value) {
          var elem = this[0] || {},
              i = 0,
              l = this.length;

          if (value === undefined && elem.nodeType === 1) {
            return elem.innerHTML;
          } // See if we can take a shortcut and just use innerHTML


          if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
            value = jQuery.htmlPrefilter(value);

            try {
              for (; i < l; i++) {
                elem = this[i] || {}; // Remove element nodes and prevent memory leaks

                if (elem.nodeType === 1) {
                  jQuery.cleanData(getAll(elem, false));
                  elem.innerHTML = value;
                }
              }

              elem = 0; // If using innerHTML throws an exception, use the fallback method
            } catch (e) {}
          }

          if (elem) {
            this.empty().append(value);
          }
        }, null, value, arguments.length);
      },
      replaceWith: function () {
        var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

        return domManip(this, arguments, function (elem) {
          var parent = this.parentNode;

          if (jQuery.inArray(this, ignored) < 0) {
            jQuery.cleanData(getAll(this));

            if (parent) {
              parent.replaceChild(elem, this);
            }
          } // Force callback invocation

        }, ignored);
      }
    });
    jQuery.each({
      appendTo: "append",
      prependTo: "prepend",
      insertBefore: "before",
      insertAfter: "after",
      replaceAll: "replaceWith"
    }, function (name, original) {
      jQuery.fn[name] = function (selector) {
        var elems,
            ret = [],
            insert = jQuery(selector),
            last = insert.length - 1,
            i = 0;

        for (; i <= last; i++) {
          elems = i === last ? this : this.clone(true);
          jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
          // .get() because push.apply(_, arraylike) throws on ancient WebKit

          push.apply(ret, elems.get());
        }

        return this.pushStack(ret);
      };
    });
    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

    var getStyles = function (elem) {
      // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
      // IE throws on elements created in popups
      // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
      var view = elem.ownerDocument.defaultView;

      if (!view || !view.opener) {
        view = window;
      }

      return view.getComputedStyle(elem);
    };

    var swap = function (elem, options, callback) {
      var ret,
          name,
          old = {}; // Remember the old values, and insert the new ones

      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }

      ret = callback.call(elem); // Revert the old values

      for (name in options) {
        elem.style[name] = old[name];
      }

      return ret;
    };

    var rboxStyle = new RegExp(cssExpand.join("|"), "i");

    (function () {
      // Executing both pixelPosition & boxSizingReliable tests require only one layout
      // so they're executed at the same time to save the second computation.
      function computeStyleTests() {
        // This is a singleton, we need to execute it only once
        if (!div) {
          return;
        }

        container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
        div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
        documentElement.appendChild(container).appendChild(div);
        var divStyle = window.getComputedStyle(div);
        pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

        reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
        // Some styles come back with percentage values, even though they shouldn't

        div.style.right = "60%";
        pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
        // Detect misreporting of content dimensions for box-sizing:border-box elements

        boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
        // Detect overflow:scroll screwiness (gh-3699)
        // Support: Chrome <=64
        // Don't get tricked when zoom affects offsetWidth (gh-4029)

        div.style.position = "absolute";
        scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
        documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
        // it will also be a sign that checks already performed

        div = null;
      }

      function roundPixelMeasures(measure) {
        return Math.round(parseFloat(measure));
      }

      var pixelPositionVal,
          boxSizingReliableVal,
          scrollboxSizeVal,
          pixelBoxStylesVal,
          reliableTrDimensionsVal,
          reliableMarginLeftVal,
          container = document.createElement("div"),
          div = document.createElement("div"); // Finish early in limited (non-browser) environments

      if (!div.style) {
        return;
      } // Support: IE <=9 - 11 only
      // Style of cloned element affects source element cloned (#8908)


      div.style.backgroundClip = "content-box";
      div.cloneNode(true).style.backgroundClip = "";
      support.clearCloneStyle = div.style.backgroundClip === "content-box";
      jQuery.extend(support, {
        boxSizingReliable: function () {
          computeStyleTests();
          return boxSizingReliableVal;
        },
        pixelBoxStyles: function () {
          computeStyleTests();
          return pixelBoxStylesVal;
        },
        pixelPosition: function () {
          computeStyleTests();
          return pixelPositionVal;
        },
        reliableMarginLeft: function () {
          computeStyleTests();
          return reliableMarginLeftVal;
        },
        scrollboxSize: function () {
          computeStyleTests();
          return scrollboxSizeVal;
        },
        // Support: IE 9 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Behavior in IE 9 is more subtle than in newer versions & it passes
        // some versions of this test; make sure not to make it pass there!
        //
        // Support: Firefox 70+
        // Only Firefox includes border widths
        // in computed dimensions. (gh-4529)
        reliableTrDimensions: function () {
          var table, tr, trChild, trStyle;

          if (reliableTrDimensionsVal == null) {
            table = document.createElement("table");
            tr = document.createElement("tr");
            trChild = document.createElement("div");
            table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
            tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
            // Height set through cssText does not get applied.
            // Computed height then comes back as 0.

            tr.style.height = "1px";
            trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
            // In our bodyBackground.html iframe,
            // display for all div elements is set to "inline",
            // which causes a problem only in Android 8 Chrome 86.
            // Ensuring the div is display: block
            // gets around this issue.

            trChild.style.display = "block";
            documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
            trStyle = window.getComputedStyle(tr);
            reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
            documentElement.removeChild(table);
          }

          return reliableTrDimensionsVal;
        }
      });
    })();

    function curCSS(elem, name, computed) {
      var width,
          minWidth,
          maxWidth,
          ret,
          // Support: Firefox 51+
      // Retrieving style before computed somehow
      // fixes an issue with getting wrong values
      // on detached elements
      style = elem.style;
      computed = computed || getStyles(elem); // getPropertyValue is needed for:
      //   .css('filter') (IE 9 only, #12537)
      //   .css('--customProperty) (#3144)

      if (computed) {
        ret = computed.getPropertyValue(name) || computed[name];

        if (ret === "" && !isAttached(elem)) {
          ret = jQuery.style(elem, name);
        } // A tribute to the "awesome hack by Dean Edwards"
        // Android Browser returns percentage for some values,
        // but width seems to be reliably pixels.
        // This is against the CSSOM draft spec:
        // https://drafts.csswg.org/cssom/#resolved-values


        if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
          // Remember the original values
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth; // Put in the new values to get a computed value out

          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width; // Revert the changed values

          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }

      return ret !== undefined ? // Support: IE <=9 - 11 only
      // IE returns zIndex value as an integer.
      ret + "" : ret;
    }

    function addGetHookIf(conditionFn, hookFn) {
      // Define the hook, we'll check on the first run if it's really needed.
      return {
        get: function () {
          if (conditionFn()) {
            // Hook not needed (or it's not possible to use it due
            // to missing dependency), remove it.
            delete this.get;
            return;
          } // Hook needed; redefine it so that the support test is not executed again.


          return (this.get = hookFn).apply(this, arguments);
        }
      };
    }

    var cssPrefixes = ["Webkit", "Moz", "ms"],
        emptyStyle = document.createElement("div").style,
        vendorProps = {}; // Return a vendor-prefixed property or undefined

    function vendorPropName(name) {
      // Check for vendor prefixed names
      var capName = name[0].toUpperCase() + name.slice(1),
          i = cssPrefixes.length;

      while (i--) {
        name = cssPrefixes[i] + capName;

        if (name in emptyStyle) {
          return name;
        }
      }
    } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


    function finalPropName(name) {
      var final = jQuery.cssProps[name] || vendorProps[name];

      if (final) {
        return final;
      }

      if (name in emptyStyle) {
        return name;
      }

      return vendorProps[name] = vendorPropName(name) || name;
    }

    var // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/,
        rcustomProp = /^--/,
        cssShow = {
      position: "absolute",
      visibility: "hidden",
      display: "block"
    },
        cssNormalTransform = {
      letterSpacing: "0",
      fontWeight: "400"
    };

    function setPositiveNumber(_elem, value, subtract) {
      // Any relative (+/-) values have already been
      // normalized at this point
      var matches = rcssNum.exec(value);
      return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
      Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }

    function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
      var i = dimension === "width" ? 1 : 0,
          extra = 0,
          delta = 0; // Adjustment may not be necessary

      if (box === (isBorderBox ? "border" : "content")) {
        return 0;
      }

      for (; i < 4; i += 2) {
        // Both box models exclude margin
        if (box === "margin") {
          delta += jQuery.css(elem, box + cssExpand[i], true, styles);
        } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


        if (!isBorderBox) {
          // Add padding
          delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

          if (box !== "padding") {
            delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
          } else {
            extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          } // If we get here with a border-box (content + padding + border), we're seeking "content" or
          // "padding" or "margin"

        } else {
          // For "content", subtract padding
          if (box === "content") {
            delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
          } // For "content" or "padding", subtract border


          if (box !== "margin") {
            delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
          }
        }
      } // Account for positive content-box scroll gutter when requested by providing computedVal


      if (!isBorderBox && computedVal >= 0) {
        // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
        // Assuming integer scroll gutter, subtract the rest and round down
        delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
        // Use an explicit zero to avoid NaN (gh-3964)
        )) || 0;
      }

      return delta;
    }

    function getWidthOrHeight(elem, dimension, extra) {
      // Start with computed style
      var styles = getStyles(elem),
          // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
      // Fake content-box until we know it's needed to know the true value.
      boxSizingNeeded = !support.boxSizingReliable() || extra,
          isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
          valueIsBorderBox = isBorderBox,
          val = curCSS(elem, dimension, styles),
          offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
      // Return a confounding non-pixel value or feign ignorance, as appropriate.

      if (rnumnonpx.test(val)) {
        if (!extra) {
          return val;
        }

        val = "auto";
      } // Support: IE 9 - 11 only
      // Use offsetWidth/offsetHeight for when box sizing is unreliable.
      // In those cases, the computed value can be trusted to be border-box.


      if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Interestingly, in some cases IE 9 doesn't suffer from this issue.
      !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
      // This happens for inline elements with no explicit setting (gh-3571)
      val === "auto" || // Support: Android <=4.1 - 4.3 only
      // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
      !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
      elem.getClientRects().length) {
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
        // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
        // retrieved value as a content box dimension.

        valueIsBorderBox = offsetProp in elem;

        if (valueIsBorderBox) {
          val = elem[offsetProp];
        }
      } // Normalize "" and auto


      val = parseFloat(val) || 0; // Adjust for the element's box model

      return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
      val) + "px";
    }

    jQuery.extend({
      // Add in style property hooks for overriding the default
      // behavior of getting and setting a style property
      cssHooks: {
        opacity: {
          get: function (elem, computed) {
            if (computed) {
              // We should always get a number back from opacity
              var ret = curCSS(elem, "opacity");
              return ret === "" ? "1" : ret;
            }
          }
        }
      },
      // Don't automatically add "px" to these possibly-unitless properties
      cssNumber: {
        "animationIterationCount": true,
        "columnCount": true,
        "fillOpacity": true,
        "flexGrow": true,
        "flexShrink": true,
        "fontWeight": true,
        "gridArea": true,
        "gridColumn": true,
        "gridColumnEnd": true,
        "gridColumnStart": true,
        "gridRow": true,
        "gridRowEnd": true,
        "gridRowStart": true,
        "lineHeight": true,
        "opacity": true,
        "order": true,
        "orphans": true,
        "widows": true,
        "zIndex": true,
        "zoom": true
      },
      // Add in properties whose names you wish to fix before
      // setting or getting the value
      cssProps: {},
      // Get and set the style property on a DOM Node
      style: function (elem, name, value, extra) {
        // Don't set styles on text and comment nodes
        if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
          return;
        } // Make sure that we're working with the right name


        var ret,
            type,
            hooks,
            origName = camelCase(name),
            isCustomProp = rcustomProp.test(name),
            style = elem.style; // Make sure that we're working with the right name. We don't
        // want to query the value if it is a CSS custom property
        // since they are user-defined.

        if (!isCustomProp) {
          name = finalPropName(origName);
        } // Gets hook for the prefixed version, then unprefixed version


        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

        if (value !== undefined) {
          type = typeof value; // Convert "+=" or "-=" to relative numbers (#7345)

          if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
            value = adjustCSS(elem, name, ret); // Fixes bug #9237

            type = "number";
          } // Make sure that null and NaN values aren't set (#7116)


          if (value == null || value !== value) {
            return;
          } // If a number was passed in, add the unit (except for certain CSS properties)
          // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
          // "px" to a few hardcoded values.


          if (type === "number" && !isCustomProp) {
            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
          } // background-* props affect original clone's values


          if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
            style[name] = "inherit";
          } // If a hook was provided, use that value, otherwise just set the specified value


          if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
            if (isCustomProp) {
              style.setProperty(name, value);
            } else {
              style[name] = value;
            }
          }
        } else {
          // If a hook was provided get the non-computed value from there
          if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
            return ret;
          } // Otherwise just get the value from the style object


          return style[name];
        }
      },
      css: function (elem, name, extra, styles) {
        var val,
            num,
            hooks,
            origName = camelCase(name),
            isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
        // want to modify the value if it is a CSS custom property
        // since they are user-defined.

        if (!isCustomProp) {
          name = finalPropName(origName);
        } // Try prefixed name followed by the unprefixed name


        hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

        if (hooks && "get" in hooks) {
          val = hooks.get(elem, true, extra);
        } // Otherwise, if a way to get the computed value exists, use that


        if (val === undefined) {
          val = curCSS(elem, name, styles);
        } // Convert "normal" to computed value


        if (val === "normal" && name in cssNormalTransform) {
          val = cssNormalTransform[name];
        } // Make numeric if forced or a qualifier was provided and val looks numeric


        if (extra === "" || extra) {
          num = parseFloat(val);
          return extra === true || isFinite(num) ? num || 0 : val;
        }

        return val;
      }
    });
    jQuery.each(["height", "width"], function (_i, dimension) {
      jQuery.cssHooks[dimension] = {
        get: function (elem, computed, extra) {
          if (computed) {
            // Certain elements can have dimension info if we invisibly show them
            // but it must have a current display style that would benefit
            return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
            // Table columns in Safari have non-zero offsetWidth & zero
            // getBoundingClientRect().width unless display is changed.
            // Support: IE <=11 only
            // Running getBoundingClientRect on a disconnected node
            // in IE throws an error.
            !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
              return getWidthOrHeight(elem, dimension, extra);
            }) : getWidthOrHeight(elem, dimension, extra);
          }
        },
        set: function (elem, value, extra) {
          var matches,
              styles = getStyles(elem),
              // Only read styles.position if the test has a chance to fail
          // to avoid forcing a reflow.
          scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
              // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
          boxSizingNeeded = scrollboxSizeBuggy || extra,
              isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
              subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
          // faking a content-box to get border and padding (gh-3699)

          if (isBorderBox && scrollboxSizeBuggy) {
            subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
          } // Convert to pixels if value adjustment is needed


          if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
            elem.style[dimension] = value;
            value = jQuery.css(elem, dimension);
          }

          return setPositiveNumber(elem, value, subtract);
        }
      };
    });
    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
      if (computed) {
        return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
          marginLeft: 0
        }, function () {
          return elem.getBoundingClientRect().left;
        })) + "px";
      }
    }); // These hooks are used by animate to expand properties

    jQuery.each({
      margin: "",
      padding: "",
      border: "Width"
    }, function (prefix, suffix) {
      jQuery.cssHooks[prefix + suffix] = {
        expand: function (value) {
          var i = 0,
              expanded = {},
              // Assumes a single number if not a string
          parts = typeof value === "string" ? value.split(" ") : [value];

          for (; i < 4; i++) {
            expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
          }

          return expanded;
        }
      };

      if (prefix !== "margin") {
        jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
      }
    });
    jQuery.fn.extend({
      css: function (name, value) {
        return access(this, function (elem, name, value) {
          var styles,
              len,
              map = {},
              i = 0;

          if (Array.isArray(name)) {
            styles = getStyles(elem);
            len = name.length;

            for (; i < len; i++) {
              map[name[i]] = jQuery.css(elem, name[i], false, styles);
            }

            return map;
          }

          return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
        }, name, value, arguments.length > 1);
      }
    });

    function Tween(elem, options, prop, end, easing) {
      return new Tween.prototype.init(elem, options, prop, end, easing);
    }

    jQuery.Tween = Tween;
    Tween.prototype = {
      constructor: Tween,
      init: function (elem, options, prop, end, easing, unit) {
        this.elem = elem;
        this.prop = prop;
        this.easing = easing || jQuery.easing._default;
        this.options = options;
        this.start = this.now = this.cur();
        this.end = end;
        this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
      },
      cur: function () {
        var hooks = Tween.propHooks[this.prop];
        return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
      },
      run: function (percent) {
        var eased,
            hooks = Tween.propHooks[this.prop];

        if (this.options.duration) {
          this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
        } else {
          this.pos = eased = percent;
        }

        this.now = (this.end - this.start) * eased + this.start;

        if (this.options.step) {
          this.options.step.call(this.elem, this.now, this);
        }

        if (hooks && hooks.set) {
          hooks.set(this);
        } else {
          Tween.propHooks._default.set(this);
        }

        return this;
      }
    };
    Tween.prototype.init.prototype = Tween.prototype;
    Tween.propHooks = {
      _default: {
        get: function (tween) {
          var result; // Use a property on the element directly when it is not a DOM element,
          // or when there is no matching style property that exists.

          if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
            return tween.elem[tween.prop];
          } // Passing an empty string as a 3rd parameter to .css will automatically
          // attempt a parseFloat and fallback to a string if the parse fails.
          // Simple values such as "10px" are parsed to Float;
          // complex values such as "rotate(1rad)" are returned as-is.


          result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

          return !result || result === "auto" ? 0 : result;
        },
        set: function (tween) {
          // Use step hook for back compat.
          // Use cssHook if its there.
          // Use .style if available and use plain properties where available.
          if (jQuery.fx.step[tween.prop]) {
            jQuery.fx.step[tween.prop](tween);
          } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
          } else {
            tween.elem[tween.prop] = tween.now;
          }
        }
      }
    }; // Support: IE <=9 only
    // Panic based approach to setting things on disconnected nodes

    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
      set: function (tween) {
        if (tween.elem.nodeType && tween.elem.parentNode) {
          tween.elem[tween.prop] = tween.now;
        }
      }
    };
    jQuery.easing = {
      linear: function (p) {
        return p;
      },
      swing: function (p) {
        return 0.5 - Math.cos(p * Math.PI) / 2;
      },
      _default: "swing"
    };
    jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

    jQuery.fx.step = {};
    var fxNow,
        inProgress,
        rfxtypes = /^(?:toggle|show|hide)$/,
        rrun = /queueHooks$/;

    function schedule() {
      if (inProgress) {
        if (document.hidden === false && window.requestAnimationFrame) {
          window.requestAnimationFrame(schedule);
        } else {
          window.setTimeout(schedule, jQuery.fx.interval);
        }

        jQuery.fx.tick();
      }
    } // Animations created synchronously will run synchronously


    function createFxNow() {
      window.setTimeout(function () {
        fxNow = undefined;
      });
      return fxNow = Date.now();
    } // Generate parameters to create a standard animation


    function genFx(type, includeWidth) {
      var which,
          i = 0,
          attrs = {
        height: type
      }; // If we include width, step value is 1 to do all cssExpand values,
      // otherwise step value is 2 to skip over Left and Right

      includeWidth = includeWidth ? 1 : 0;

      for (; i < 4; i += 2 - includeWidth) {
        which = cssExpand[i];
        attrs["margin" + which] = attrs["padding" + which] = type;
      }

      if (includeWidth) {
        attrs.opacity = attrs.width = type;
      }

      return attrs;
    }

    function createTween(value, prop, animation) {
      var tween,
          collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
          index = 0,
          length = collection.length;

      for (; index < length; index++) {
        if (tween = collection[index].call(animation, prop, value)) {
          // We're done with this property
          return tween;
        }
      }
    }

    function defaultPrefilter(elem, props, opts) {
      var prop,
          value,
          toggle,
          hooks,
          oldfire,
          propTween,
          restoreDisplay,
          display,
          isBox = "width" in props || "height" in props,
          anim = this,
          orig = {},
          style = elem.style,
          hidden = elem.nodeType && isHiddenWithinTree(elem),
          dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

      if (!opts.queue) {
        hooks = jQuery._queueHooks(elem, "fx");

        if (hooks.unqueued == null) {
          hooks.unqueued = 0;
          oldfire = hooks.empty.fire;

          hooks.empty.fire = function () {
            if (!hooks.unqueued) {
              oldfire();
            }
          };
        }

        hooks.unqueued++;
        anim.always(function () {
          // Ensure the complete handler is called before this completes
          anim.always(function () {
            hooks.unqueued--;

            if (!jQuery.queue(elem, "fx").length) {
              hooks.empty.fire();
            }
          });
        });
      } // Detect show/hide animations


      for (prop in props) {
        value = props[prop];

        if (rfxtypes.test(value)) {
          delete props[prop];
          toggle = toggle || value === "toggle";

          if (value === (hidden ? "hide" : "show")) {
            // Pretend to be hidden if this is a "show" and
            // there is still data from a stopped show/hide
            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
              hidden = true; // Ignore all other no-op show/hide data
            } else {
              continue;
            }
          }

          orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
      } // Bail out if this is a no-op like .hide().hide()


      propTween = !jQuery.isEmptyObject(props);

      if (!propTween && jQuery.isEmptyObject(orig)) {
        return;
      } // Restrict "overflow" and "display" styles during box animations


      if (isBox && elem.nodeType === 1) {
        // Support: IE <=9 - 11, Edge 12 - 15
        // Record all 3 overflow attributes because IE does not infer the shorthand
        // from identically-valued overflowX and overflowY and Edge just mirrors
        // the overflowX value there.
        opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

        restoreDisplay = dataShow && dataShow.display;

        if (restoreDisplay == null) {
          restoreDisplay = dataPriv.get(elem, "display");
        }

        display = jQuery.css(elem, "display");

        if (display === "none") {
          if (restoreDisplay) {
            display = restoreDisplay;
          } else {
            // Get nonempty value(s) by temporarily forcing visibility
            showHide([elem], true);
            restoreDisplay = elem.style.display || restoreDisplay;
            display = jQuery.css(elem, "display");
            showHide([elem]);
          }
        } // Animate inline elements as inline-block


        if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
          if (jQuery.css(elem, "float") === "none") {
            // Restore the original display value at the end of pure show/hide animations
            if (!propTween) {
              anim.done(function () {
                style.display = restoreDisplay;
              });

              if (restoreDisplay == null) {
                display = style.display;
                restoreDisplay = display === "none" ? "" : display;
              }
            }

            style.display = "inline-block";
          }
        }
      }

      if (opts.overflow) {
        style.overflow = "hidden";
        anim.always(function () {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      } // Implement show/hide animations


      propTween = false;

      for (prop in orig) {
        // General show/hide setup for this element animation
        if (!propTween) {
          if (dataShow) {
            if ("hidden" in dataShow) {
              hidden = dataShow.hidden;
            }
          } else {
            dataShow = dataPriv.access(elem, "fxshow", {
              display: restoreDisplay
            });
          } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


          if (toggle) {
            dataShow.hidden = !hidden;
          } // Show elements before animating them


          if (hidden) {
            showHide([elem], true);
          }
          /* eslint-disable no-loop-func */


          anim.done(function () {
            /* eslint-enable no-loop-func */
            // The final step of a "hide" animation is actually hiding the element
            if (!hidden) {
              showHide([elem]);
            }

            dataPriv.remove(elem, "fxshow");

            for (prop in orig) {
              jQuery.style(elem, prop, orig[prop]);
            }
          });
        } // Per-property setup


        propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

        if (!(prop in dataShow)) {
          dataShow[prop] = propTween.start;

          if (hidden) {
            propTween.end = propTween.start;
            propTween.start = 0;
          }
        }
      }
    }

    function propFilter(props, specialEasing) {
      var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

      for (index in props) {
        name = camelCase(index);
        easing = specialEasing[name];
        value = props[index];

        if (Array.isArray(value)) {
          easing = value[1];
          value = props[index] = value[0];
        }

        if (index !== name) {
          props[name] = value;
          delete props[index];
        }

        hooks = jQuery.cssHooks[name];

        if (hooks && "expand" in hooks) {
          value = hooks.expand(value);
          delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
          // Reusing 'index' because we have the correct "name"

          for (index in value) {
            if (!(index in props)) {
              props[index] = value[index];
              specialEasing[index] = easing;
            }
          }
        } else {
          specialEasing[name] = easing;
        }
      }
    }

    function Animation(elem, properties, options) {
      var result,
          stopped,
          index = 0,
          length = Animation.prefilters.length,
          deferred = jQuery.Deferred().always(function () {
        // Don't match elem in the :animated selector
        delete tick.elem;
      }),
          tick = function () {
        if (stopped) {
          return false;
        }

        var currentTime = fxNow || createFxNow(),
            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
            // Support: Android 2.3 only
        // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
        temp = remaining / animation.duration || 0,
            percent = 1 - temp,
            index = 0,
            length = animation.tweens.length;

        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }

        deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

        if (percent < 1 && length) {
          return remaining;
        } // If this was an empty animation, synthesize a final progress notification


        if (!length) {
          deferred.notifyWith(elem, [animation, 1, 0]);
        } // Resolve the animation and report its conclusion


        deferred.resolveWith(elem, [animation]);
        return false;
      },
          animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, {
          specialEasing: {},
          easing: jQuery.easing._default
        }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0,
              // If we are going to the end, we want to run all the tweens
          // otherwise we skip this part
          length = gotoEnd ? animation.tweens.length : 0;

          if (stopped) {
            return this;
          }

          stopped = true;

          for (; index < length; index++) {
            animation.tweens[index].run(1);
          } // Resolve when we played the last frame; otherwise, reject


          if (gotoEnd) {
            deferred.notifyWith(elem, [animation, 1, 0]);
            deferred.resolveWith(elem, [animation, gotoEnd]);
          } else {
            deferred.rejectWith(elem, [animation, gotoEnd]);
          }

          return this;
        }
      }),
          props = animation.props;

      propFilter(props, animation.opts.specialEasing);

      for (; index < length; index++) {
        result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

        if (result) {
          if (isFunction(result.stop)) {
            jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
          }

          return result;
        }
      }

      jQuery.map(props, createTween, animation);

      if (isFunction(animation.opts.start)) {
        animation.opts.start.call(elem, animation);
      } // Attach callbacks from options


      animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
      jQuery.fx.timer(jQuery.extend(tick, {
        elem: elem,
        anim: animation,
        queue: animation.opts.queue
      }));
      return animation;
    }

    jQuery.Animation = jQuery.extend(Animation, {
      tweeners: {
        "*": [function (prop, value) {
          var tween = this.createTween(prop, value);
          adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
          return tween;
        }]
      },
      tweener: function (props, callback) {
        if (isFunction(props)) {
          callback = props;
          props = ["*"];
        } else {
          props = props.match(rnothtmlwhite);
        }

        var prop,
            index = 0,
            length = props.length;

        for (; index < length; index++) {
          prop = props[index];
          Animation.tweeners[prop] = Animation.tweeners[prop] || [];
          Animation.tweeners[prop].unshift(callback);
        }
      },
      prefilters: [defaultPrefilter],
      prefilter: function (callback, prepend) {
        if (prepend) {
          Animation.prefilters.unshift(callback);
        } else {
          Animation.prefilters.push(callback);
        }
      }
    });

    jQuery.speed = function (speed, easing, fn) {
      var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !isFunction(easing) && easing
      }; // Go to the end state if fx are off

      if (jQuery.fx.off) {
        opt.duration = 0;
      } else {
        if (typeof opt.duration !== "number") {
          if (opt.duration in jQuery.fx.speeds) {
            opt.duration = jQuery.fx.speeds[opt.duration];
          } else {
            opt.duration = jQuery.fx.speeds._default;
          }
        }
      } // Normalize opt.queue - true/undefined/null -> "fx"


      if (opt.queue == null || opt.queue === true) {
        opt.queue = "fx";
      } // Queueing


      opt.old = opt.complete;

      opt.complete = function () {
        if (isFunction(opt.old)) {
          opt.old.call(this);
        }

        if (opt.queue) {
          jQuery.dequeue(this, opt.queue);
        }
      };

      return opt;
    };

    jQuery.fn.extend({
      fadeTo: function (speed, to, easing, callback) {
        // Show any hidden elements after setting opacity to 0
        return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
        .end().animate({
          opacity: to
        }, speed, easing, callback);
      },
      animate: function (prop, speed, easing, callback) {
        var empty = jQuery.isEmptyObject(prop),
            optall = jQuery.speed(speed, easing, callback),
            doAnimation = function () {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

          if (empty || dataPriv.get(this, "finish")) {
            anim.stop(true);
          }
        };

        doAnimation.finish = doAnimation;
        return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
      },
      stop: function (type, clearQueue, gotoEnd) {
        var stopQueue = function (hooks) {
          var stop = hooks.stop;
          delete hooks.stop;
          stop(gotoEnd);
        };

        if (typeof type !== "string") {
          gotoEnd = clearQueue;
          clearQueue = type;
          type = undefined;
        }

        if (clearQueue) {
          this.queue(type || "fx", []);
        }

        return this.each(function () {
          var dequeue = true,
              index = type != null && type + "queueHooks",
              timers = jQuery.timers,
              data = dataPriv.get(this);

          if (index) {
            if (data[index] && data[index].stop) {
              stopQueue(data[index]);
            }
          } else {
            for (index in data) {
              if (data[index] && data[index].stop && rrun.test(index)) {
                stopQueue(data[index]);
              }
            }
          }

          for (index = timers.length; index--;) {
            if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
              timers[index].anim.stop(gotoEnd);
              dequeue = false;
              timers.splice(index, 1);
            }
          } // Start the next in the queue if the last step wasn't forced.
          // Timers currently will call their complete callbacks, which
          // will dequeue but only if they were gotoEnd.


          if (dequeue || !gotoEnd) {
            jQuery.dequeue(this, type);
          }
        });
      },
      finish: function (type) {
        if (type !== false) {
          type = type || "fx";
        }

        return this.each(function () {
          var index,
              data = dataPriv.get(this),
              queue = data[type + "queue"],
              hooks = data[type + "queueHooks"],
              timers = jQuery.timers,
              length = queue ? queue.length : 0; // Enable finishing flag on private data

          data.finish = true; // Empty the queue first

          jQuery.queue(this, type, []);

          if (hooks && hooks.stop) {
            hooks.stop.call(this, true);
          } // Look for any active animations, and finish them


          for (index = timers.length; index--;) {
            if (timers[index].elem === this && timers[index].queue === type) {
              timers[index].anim.stop(true);
              timers.splice(index, 1);
            }
          } // Look for any animations in the old queue and finish them


          for (index = 0; index < length; index++) {
            if (queue[index] && queue[index].finish) {
              queue[index].finish.call(this);
            }
          } // Turn off finishing flag


          delete data.finish;
        });
      }
    });
    jQuery.each(["toggle", "show", "hide"], function (_i, name) {
      var cssFn = jQuery.fn[name];

      jQuery.fn[name] = function (speed, easing, callback) {
        return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
      };
    }); // Generate shortcuts for custom animations

    jQuery.each({
      slideDown: genFx("show"),
      slideUp: genFx("hide"),
      slideToggle: genFx("toggle"),
      fadeIn: {
        opacity: "show"
      },
      fadeOut: {
        opacity: "hide"
      },
      fadeToggle: {
        opacity: "toggle"
      }
    }, function (name, props) {
      jQuery.fn[name] = function (speed, easing, callback) {
        return this.animate(props, speed, easing, callback);
      };
    });
    jQuery.timers = [];

    jQuery.fx.tick = function () {
      var timer,
          i = 0,
          timers = jQuery.timers;
      fxNow = Date.now();

      for (; i < timers.length; i++) {
        timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

        if (!timer() && timers[i] === timer) {
          timers.splice(i--, 1);
        }
      }

      if (!timers.length) {
        jQuery.fx.stop();
      }

      fxNow = undefined;
    };

    jQuery.fx.timer = function (timer) {
      jQuery.timers.push(timer);
      jQuery.fx.start();
    };

    jQuery.fx.interval = 13;

    jQuery.fx.start = function () {
      if (inProgress) {
        return;
      }

      inProgress = true;
      schedule();
    };

    jQuery.fx.stop = function () {
      inProgress = null;
    };

    jQuery.fx.speeds = {
      slow: 600,
      fast: 200,
      // Default speed
      _default: 400
    }; // Based off of the plugin by Clint Helfers, with permission.
    // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

    jQuery.fn.delay = function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || "fx";
      return this.queue(type, function (next, hooks) {
        var timeout = window.setTimeout(next, time);

        hooks.stop = function () {
          window.clearTimeout(timeout);
        };
      });
    };

    (function () {
      var input = document.createElement("input"),
          select = document.createElement("select"),
          opt = select.appendChild(document.createElement("option"));
      input.type = "checkbox"; // Support: Android <=4.3 only
      // Default value for a checkbox should be "on"

      support.checkOn = input.value !== ""; // Support: IE <=11 only
      // Must access selectedIndex to make default options select

      support.optSelected = opt.selected; // Support: IE <=11 only
      // An input loses its value after becoming a radio

      input = document.createElement("input");
      input.value = "t";
      input.type = "radio";
      support.radioValue = input.value === "t";
    })();

    var boolHook,
        attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
      attr: function (name, value) {
        return access(this, jQuery.attr, name, value, arguments.length > 1);
      },
      removeAttr: function (name) {
        return this.each(function () {
          jQuery.removeAttr(this, name);
        });
      }
    });
    jQuery.extend({
      attr: function (elem, name, value) {
        var ret,
            hooks,
            nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        } // Fallback to prop when attributes are not supported


        if (typeof elem.getAttribute === "undefined") {
          return jQuery.prop(elem, name, value);
        } // Attribute hooks are determined by the lowercase version
        // Grab necessary hook if one is defined


        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
        }

        if (value !== undefined) {
          if (value === null) {
            jQuery.removeAttr(elem, name);
            return;
          }

          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          elem.setAttribute(name, value + "");
          return value;
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

        return ret == null ? undefined : ret;
      },
      attrHooks: {
        type: {
          set: function (elem, value) {
            if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
              var val = elem.value;
              elem.setAttribute("type", value);

              if (val) {
                elem.value = val;
              }

              return value;
            }
          }
        }
      },
      removeAttr: function (elem, value) {
        var name,
            i = 0,
            // Attribute names can contain non-HTML whitespace characters
        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
        attrNames = value && value.match(rnothtmlwhite);

        if (attrNames && elem.nodeType === 1) {
          while (name = attrNames[i++]) {
            elem.removeAttribute(name);
          }
        }
      }
    }); // Hooks for boolean attributes

    boolHook = {
      set: function (elem, value, name) {
        if (value === false) {
          // Remove boolean attributes when set to false
          jQuery.removeAttr(elem, name);
        } else {
          elem.setAttribute(name, name);
        }

        return name;
      }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
      var getter = attrHandle[name] || jQuery.find.attr;

      attrHandle[name] = function (elem, name, isXML) {
        var ret,
            handle,
            lowercaseName = name.toLowerCase();

        if (!isXML) {
          // Avoid an infinite loop by temporarily removing this function from the getter
          handle = attrHandle[lowercaseName];
          attrHandle[lowercaseName] = ret;
          ret = getter(elem, name, isXML) != null ? lowercaseName : null;
          attrHandle[lowercaseName] = handle;
        }

        return ret;
      };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i,
        rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
      prop: function (name, value) {
        return access(this, jQuery.prop, name, value, arguments.length > 1);
      },
      removeProp: function (name) {
        return this.each(function () {
          delete this[jQuery.propFix[name] || name];
        });
      }
    });
    jQuery.extend({
      prop: function (elem, name, value) {
        var ret,
            hooks,
            nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

        if (nType === 3 || nType === 8 || nType === 2) {
          return;
        }

        if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
          // Fix name and attach hooks
          name = jQuery.propFix[name] || name;
          hooks = jQuery.propHooks[name];
        }

        if (value !== undefined) {
          if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
            return ret;
          }

          return elem[name] = value;
        }

        if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
          return ret;
        }

        return elem[name];
      },
      propHooks: {
        tabIndex: {
          get: function (elem) {
            // Support: IE <=9 - 11 only
            // elem.tabIndex doesn't always return the
            // correct value when it hasn't been explicitly set
            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
            // Use proper attribute retrieval(#12072)
            var tabindex = jQuery.find.attr(elem, "tabindex");

            if (tabindex) {
              return parseInt(tabindex, 10);
            }

            if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
              return 0;
            }

            return -1;
          }
        }
      },
      propFix: {
        "for": "htmlFor",
        "class": "className"
      }
    }); // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    // eslint rule "no-unused-expressions" is disabled for this code
    // since it considers such accessions noop

    if (!support.optSelected) {
      jQuery.propHooks.selected = {
        get: function (elem) {
          /* eslint no-unused-expressions: "off" */
          var parent = elem.parentNode;

          if (parent && parent.parentNode) {
            parent.parentNode.selectedIndex;
          }

          return null;
        },
        set: function (elem) {
          /* eslint no-unused-expressions: "off" */
          var parent = elem.parentNode;

          if (parent) {
            parent.selectedIndex;

            if (parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
          }
        }
      };
    }

    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
      jQuery.propFix[this.toLowerCase()] = this;
    }); // Strip and collapse whitespace according to HTML spec
    // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

    function stripAndCollapse(value) {
      var tokens = value.match(rnothtmlwhite) || [];
      return tokens.join(" ");
    }

    function getClass(elem) {
      return elem.getAttribute && elem.getAttribute("class") || "";
    }

    function classesToArray(value) {
      if (Array.isArray(value)) {
        return value;
      }

      if (typeof value === "string") {
        return value.match(rnothtmlwhite) || [];
      }

      return [];
    }

    jQuery.fn.extend({
      addClass: function (value) {
        var classes,
            elem,
            cur,
            curValue,
            clazz,
            j,
            finalValue,
            i = 0;

        if (isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).addClass(value.call(this, j, getClass(this)));
          });
        }

        classes = classesToArray(value);

        if (classes.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem);
            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

            if (cur) {
              j = 0;

              while (clazz = classes[j++]) {
                if (cur.indexOf(" " + clazz + " ") < 0) {
                  cur += clazz + " ";
                }
              } // Only assign if different to avoid unneeded rendering.


              finalValue = stripAndCollapse(cur);

              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }

        return this;
      },
      removeClass: function (value) {
        var classes,
            elem,
            cur,
            curValue,
            clazz,
            j,
            finalValue,
            i = 0;

        if (isFunction(value)) {
          return this.each(function (j) {
            jQuery(this).removeClass(value.call(this, j, getClass(this)));
          });
        }

        if (!arguments.length) {
          return this.attr("class", "");
        }

        classes = classesToArray(value);

        if (classes.length) {
          while (elem = this[i++]) {
            curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

            cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

            if (cur) {
              j = 0;

              while (clazz = classes[j++]) {
                // Remove *all* instances
                while (cur.indexOf(" " + clazz + " ") > -1) {
                  cur = cur.replace(" " + clazz + " ", " ");
                }
              } // Only assign if different to avoid unneeded rendering.


              finalValue = stripAndCollapse(cur);

              if (curValue !== finalValue) {
                elem.setAttribute("class", finalValue);
              }
            }
          }
        }

        return this;
      },
      toggleClass: function (value, stateVal) {
        var type = typeof value,
            isValidValue = type === "string" || Array.isArray(value);

        if (typeof stateVal === "boolean" && isValidValue) {
          return stateVal ? this.addClass(value) : this.removeClass(value);
        }

        if (isFunction(value)) {
          return this.each(function (i) {
            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
          });
        }

        return this.each(function () {
          var className, i, self, classNames;

          if (isValidValue) {
            // Toggle individual class names
            i = 0;
            self = jQuery(this);
            classNames = classesToArray(value);

            while (className = classNames[i++]) {
              // Check each className given, space separated list
              if (self.hasClass(className)) {
                self.removeClass(className);
              } else {
                self.addClass(className);
              }
            } // Toggle whole class name

          } else if (value === undefined || type === "boolean") {
            className = getClass(this);

            if (className) {
              // Store className if set
              dataPriv.set(this, "__className__", className);
            } // If the element has a class name or if we're passed `false`,
            // then remove the whole classname (if there was one, the above saved it).
            // Otherwise bring back whatever was previously saved (if anything),
            // falling back to the empty string if nothing was stored.


            if (this.setAttribute) {
              this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
            }
          }
        });
      },
      hasClass: function (selector) {
        var className,
            elem,
            i = 0;
        className = " " + selector + " ";

        while (elem = this[i++]) {
          if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
            return true;
          }
        }

        return false;
      }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
      val: function (value) {
        var hooks,
            ret,
            valueIsFunction,
            elem = this[0];

        if (!arguments.length) {
          if (elem) {
            hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

            if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
              return ret;
            }

            ret = elem.value; // Handle most common string cases

            if (typeof ret === "string") {
              return ret.replace(rreturn, "");
            } // Handle cases where value is null/undef or number


            return ret == null ? "" : ret;
          }

          return;
        }

        valueIsFunction = isFunction(value);
        return this.each(function (i) {
          var val;

          if (this.nodeType !== 1) {
            return;
          }

          if (valueIsFunction) {
            val = value.call(this, i, jQuery(this).val());
          } else {
            val = value;
          } // Treat null/undefined as ""; convert numbers to string


          if (val == null) {
            val = "";
          } else if (typeof val === "number") {
            val += "";
          } else if (Array.isArray(val)) {
            val = jQuery.map(val, function (value) {
              return value == null ? "" : value + "";
            });
          }

          hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

          if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
            this.value = val;
          }
        });
      }
    });
    jQuery.extend({
      valHooks: {
        option: {
          get: function (elem) {
            var val = jQuery.find.attr(elem, "value");
            return val != null ? val : // Support: IE <=10 - 11 only
            // option.text throws exceptions (#14686, #14858)
            // Strip and collapse whitespace
            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
            stripAndCollapse(jQuery.text(elem));
          }
        },
        select: {
          get: function (elem) {
            var value,
                option,
                i,
                options = elem.options,
                index = elem.selectedIndex,
                one = elem.type === "select-one",
                values = one ? null : [],
                max = one ? index + 1 : options.length;

            if (index < 0) {
              i = max;
            } else {
              i = one ? index : 0;
            } // Loop through all the selected options


            for (; i < max; i++) {
              option = options[i]; // Support: IE <=9 only
              // IE8-9 doesn't update selected after form reset (#2551)

              if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
              !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                // Get the specific value for the option
                value = jQuery(option).val(); // We don't need an array for one selects

                if (one) {
                  return value;
                } // Multi-Selects return an array


                values.push(value);
              }
            }

            return values;
          },
          set: function (elem, value) {
            var optionSet,
                option,
                options = elem.options,
                values = jQuery.makeArray(value),
                i = options.length;

            while (i--) {
              option = options[i];
              /* eslint-disable no-cond-assign */

              if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                optionSet = true;
              }
              /* eslint-enable no-cond-assign */

            } // Force browsers to behave consistently when non-matching value is set


            if (!optionSet) {
              elem.selectedIndex = -1;
            }

            return values;
          }
        }
      }
    }); // Radios and checkboxes getter/setter

    jQuery.each(["radio", "checkbox"], function () {
      jQuery.valHooks[this] = {
        set: function (elem, value) {
          if (Array.isArray(value)) {
            return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
          }
        }
      };

      if (!support.checkOn) {
        jQuery.valHooks[this].get = function (elem) {
          return elem.getAttribute("value") === null ? "on" : elem.value;
        };
      }
    }); // Return jQuery for attributes-only inclusion

    support.focusin = "onfocusin" in window;

    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
        stopPropagationCallback = function (e) {
      e.stopPropagation();
    };

    jQuery.extend(jQuery.event, {
      trigger: function (event, data, elem, onlyHandlers) {
        var i,
            cur,
            tmp,
            bubbleType,
            ontype,
            handle,
            special,
            lastElement,
            eventPath = [elem || document],
            type = hasOwn.call(event, "type") ? event.type : event,
            namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
        cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

        if (elem.nodeType === 3 || elem.nodeType === 8) {
          return;
        } // focus/blur morphs to focusin/out; ensure we're not firing them right now


        if (rfocusMorph.test(type + jQuery.event.triggered)) {
          return;
        }

        if (type.indexOf(".") > -1) {
          // Namespaced trigger; create a regexp to match event type in handle()
          namespaces = type.split(".");
          type = namespaces.shift();
          namespaces.sort();
        }

        ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

        event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

        event.isTrigger = onlyHandlers ? 2 : 3;
        event.namespace = namespaces.join(".");
        event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

        event.result = undefined;

        if (!event.target) {
          event.target = elem;
        } // Clone any incoming data and prepend the event, creating the handler arg list


        data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

        special = jQuery.event.special[type] || {};

        if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
          return;
        } // Determine event propagation path in advance, per W3C events spec (#9951)
        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


        if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
          bubbleType = special.delegateType || type;

          if (!rfocusMorph.test(bubbleType + type)) {
            cur = cur.parentNode;
          }

          for (; cur; cur = cur.parentNode) {
            eventPath.push(cur);
            tmp = cur;
          } // Only add window if we got to document (e.g., not plain obj or detached DOM)


          if (tmp === (elem.ownerDocument || document)) {
            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
          }
        } // Fire handlers on the event path


        i = 0;

        while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
          lastElement = cur;
          event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

          handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

          if (handle) {
            handle.apply(cur, data);
          } // Native handler


          handle = ontype && cur[ontype];

          if (handle && handle.apply && acceptData(cur)) {
            event.result = handle.apply(cur, data);

            if (event.result === false) {
              event.preventDefault();
            }
          }
        }

        event.type = type; // If nobody prevented the default action, do it now

        if (!onlyHandlers && !event.isDefaultPrevented()) {
          if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
            // Call a native DOM method on the target with the same name as the event.
            // Don't do default actions on window, that's where global variables be (#6170)
            if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
              // Don't re-trigger an onFOO event when we call its FOO() method
              tmp = elem[ontype];

              if (tmp) {
                elem[ontype] = null;
              } // Prevent re-triggering of the same event, since we already bubbled it above


              jQuery.event.triggered = type;

              if (event.isPropagationStopped()) {
                lastElement.addEventListener(type, stopPropagationCallback);
              }

              elem[type]();

              if (event.isPropagationStopped()) {
                lastElement.removeEventListener(type, stopPropagationCallback);
              }

              jQuery.event.triggered = undefined;

              if (tmp) {
                elem[ontype] = tmp;
              }
            }
          }
        }

        return event.result;
      },
      // Piggyback on a donor event to simulate a different one
      // Used only for `focus(in | out)` events
      simulate: function (type, elem, event) {
        var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true
        });
        jQuery.event.trigger(e, null, elem);
      }
    });
    jQuery.fn.extend({
      trigger: function (type, data) {
        return this.each(function () {
          jQuery.event.trigger(type, data, this);
        });
      },
      triggerHandler: function (type, data) {
        var elem = this[0];

        if (elem) {
          return jQuery.event.trigger(type, data, elem, true);
        }
      }
    }); // Support: Firefox <=44
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

    if (!support.focusin) {
      jQuery.each({
        focus: "focusin",
        blur: "focusout"
      }, function (orig, fix) {
        // Attach a single capturing handler on the document while someone wants focusin/focusout
        var handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };

        jQuery.event.special[fix] = {
          setup: function () {
            // Handle: regular nodes (via `this.ownerDocument`), window
            // (via `this.document`) & document (via `this`).
            var doc = this.ownerDocument || this.document || this,
                attaches = dataPriv.access(doc, fix);

            if (!attaches) {
              doc.addEventListener(orig, handler, true);
            }

            dataPriv.access(doc, fix, (attaches || 0) + 1);
          },
          teardown: function () {
            var doc = this.ownerDocument || this.document || this,
                attaches = dataPriv.access(doc, fix) - 1;

            if (!attaches) {
              doc.removeEventListener(orig, handler, true);
              dataPriv.remove(doc, fix);
            } else {
              dataPriv.access(doc, fix, attaches);
            }
          }
        };
      });
    }

    var location = window.location;
    var nonce = {
      guid: Date.now()
    };
    var rquery = /\?/; // Cross-browser xml parsing

    jQuery.parseXML = function (data) {
      var xml, parserErrorElem;

      if (!data || typeof data !== "string") {
        return null;
      } // Support: IE 9 - 11 only
      // IE throws on parseFromString with invalid input.


      try {
        xml = new window.DOMParser().parseFromString(data, "text/xml");
      } catch (e) {}

      parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

      if (!xml || parserErrorElem) {
        jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
          return el.textContent;
        }).join("\n") : data));
      }

      return xml;
    };

    var rbracket = /\[\]$/,
        rCRLF = /\r?\n/g,
        rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
        rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
      var name;

      if (Array.isArray(obj)) {
        // Serialize array item.
        jQuery.each(obj, function (i, v) {
          if (traditional || rbracket.test(prefix)) {
            // Treat each array item as a scalar.
            add(prefix, v);
          } else {
            // Item is non-scalar (array or object), encode its numeric index.
            buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
          }
        });
      } else if (!traditional && toType(obj) === "object") {
        // Serialize object item.
        for (name in obj) {
          buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
        }
      } else {
        // Serialize scalar item.
        add(prefix, obj);
      }
    } // Serialize an array of form elements or a set of
    // key/values into a query string


    jQuery.param = function (a, traditional) {
      var prefix,
          s = [],
          add = function (key, valueOrFunction) {
        // If value is a function, invoke it and use its return value
        var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
        s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
      };

      if (a == null) {
        return "";
      } // If an array was passed in, assume that it is an array of form elements.


      if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
        // Serialize the form elements
        jQuery.each(a, function () {
          add(this.name, this.value);
        });
      } else {
        // If traditional, encode the "old" way (the way 1.3.2 or older
        // did it), otherwise encode params recursively.
        for (prefix in a) {
          buildParams(prefix, a[prefix], traditional, add);
        }
      } // Return the resulting serialization


      return s.join("&");
    };

    jQuery.fn.extend({
      serialize: function () {
        return jQuery.param(this.serializeArray());
      },
      serializeArray: function () {
        return this.map(function () {
          // Can add propHook for "elements" to filter or add form elements
          var elements = jQuery.prop(this, "elements");
          return elements ? jQuery.makeArray(elements) : this;
        }).filter(function () {
          var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

          return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
        }).map(function (_i, elem) {
          var val = jQuery(this).val();

          if (val == null) {
            return null;
          }

          if (Array.isArray(val)) {
            return jQuery.map(val, function (val) {
              return {
                name: elem.name,
                value: val.replace(rCRLF, "\r\n")
              };
            });
          }

          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }).get();
      }
    });
    var r20 = /%20/g,
        rhash = /#.*$/,
        rantiCache = /([?&])_=[^&]*/,
        rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
        // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
        rnoContent = /^(?:GET|HEAD)$/,
        rprotocol = /^\/\//,

    /* Prefilters
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
     * 2) These are called:
     *    - BEFORE asking for a transport
     *    - AFTER param serialization (s.data is a string if s.processData is true)
     * 3) key is the dataType
     * 4) the catchall symbol "*" can be used
     * 5) execution will start with transport dataType and THEN continue down to "*" if needed
     */
    prefilters = {},

    /* Transports bindings
     * 1) key is the dataType
     * 2) the catchall symbol "*" can be used
     * 3) selection will start with transport dataType and THEN go to "*" if needed
     */
    transports = {},
        // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*"),
        // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
    originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

    function addToPrefiltersOrTransports(structure) {
      // dataTypeExpression is optional and defaults to "*"
      return function (dataTypeExpression, func) {
        if (typeof dataTypeExpression !== "string") {
          func = dataTypeExpression;
          dataTypeExpression = "*";
        }

        var dataType,
            i = 0,
            dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

        if (isFunction(func)) {
          // For each dataType in the dataTypeExpression
          while (dataType = dataTypes[i++]) {
            // Prepend if requested
            if (dataType[0] === "+") {
              dataType = dataType.slice(1) || "*";
              (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
            } else {
              (structure[dataType] = structure[dataType] || []).push(func);
            }
          }
        }
      };
    } // Base inspection function for prefilters and transports


    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
      var inspected = {},
          seekingTransport = structure === transports;

      function inspect(dataType) {
        var selected;
        inspected[dataType] = true;
        jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
          var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

          if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
            options.dataTypes.unshift(dataTypeOrTransport);
            inspect(dataTypeOrTransport);
            return false;
          } else if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        });
        return selected;
      }

      return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    } // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887


    function ajaxExtend(target, src) {
      var key,
          deep,
          flatOptions = jQuery.ajaxSettings.flatOptions || {};

      for (key in src) {
        if (src[key] !== undefined) {
          (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
        }
      }

      if (deep) {
        jQuery.extend(true, target, deep);
      }

      return target;
    }
    /* Handles responses to an ajax request:
     * - finds the right dataType (mediates between content-type and expected dataType)
     * - returns the corresponding response
     */


    function ajaxHandleResponses(s, jqXHR, responses) {
      var ct,
          type,
          finalDataType,
          firstDataType,
          contents = s.contents,
          dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

      while (dataTypes[0] === "*") {
        dataTypes.shift();

        if (ct === undefined) {
          ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
        }
      } // Check if we're dealing with a known content-type


      if (ct) {
        for (type in contents) {
          if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
          }
        }
      } // Check to see if we have a response for the expected dataType


      if (dataTypes[0] in responses) {
        finalDataType = dataTypes[0];
      } else {
        // Try convertible dataTypes
        for (type in responses) {
          if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
            finalDataType = type;
            break;
          }

          if (!firstDataType) {
            firstDataType = type;
          }
        } // Or just use first one


        finalDataType = finalDataType || firstDataType;
      } // If we found a dataType
      // We add the dataType to the list if needed
      // and return the corresponding response


      if (finalDataType) {
        if (finalDataType !== dataTypes[0]) {
          dataTypes.unshift(finalDataType);
        }

        return responses[finalDataType];
      }
    }
    /* Chain conversions given the request and the original response
     * Also sets the responseXXX fields on the jqXHR instance
     */


    function ajaxConvert(s, response, jqXHR, isSuccess) {
      var conv2,
          current,
          conv,
          tmp,
          prev,
          converters = {},
          // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

      if (dataTypes[1]) {
        for (conv in s.converters) {
          converters[conv.toLowerCase()] = s.converters[conv];
        }
      }

      current = dataTypes.shift(); // Convert to each sequential dataType

      while (current) {
        if (s.responseFields[current]) {
          jqXHR[s.responseFields[current]] = response;
        } // Apply the dataFilter if provided


        if (!prev && isSuccess && s.dataFilter) {
          response = s.dataFilter(response, s.dataType);
        }

        prev = current;
        current = dataTypes.shift();

        if (current) {
          // There's only work to do if current dataType is non-auto
          if (current === "*") {
            current = prev; // Convert response if prev dataType is non-auto and differs from current
          } else if (prev !== "*" && prev !== current) {
            // Seek a direct converter
            conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

            if (!conv) {
              for (conv2 in converters) {
                // If conv2 outputs current
                tmp = conv2.split(" ");

                if (tmp[1] === current) {
                  // If prev can be converted to accepted input
                  conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                  if (conv) {
                    // Condense equivalence converters
                    if (conv === true) {
                      conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                    } else if (converters[conv2] !== true) {
                      current = tmp[0];
                      dataTypes.unshift(tmp[1]);
                    }

                    break;
                  }
                }
              }
            } // Apply converter (if not an equivalence)


            if (conv !== true) {
              // Unless errors are allowed to bubble, catch and return them
              if (conv && s.throws) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e) {
                  return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                  };
                }
              }
            }
          }
        }
      }

      return {
        state: "success",
        data: response
      };
    }

    jQuery.extend({
      // Counter for holding the number of active queries
      active: 0,
      // Last-Modified header cache for next request
      lastModified: {},
      etag: {},
      ajaxSettings: {
        url: location.href,
        type: "GET",
        isLocal: rlocalProtocol.test(location.protocol),
        global: true,
        processData: true,
        async: true,
        contentType: "application/x-www-form-urlencoded; charset=UTF-8",

        /*
        timeout: 0,
        data: null,
        dataType: null,
        username: null,
        password: null,
        cache: null,
        throws: false,
        traditional: false,
        headers: {},
        */
        accepts: {
          "*": allTypes,
          text: "text/plain",
          html: "text/html",
          xml: "application/xml, text/xml",
          json: "application/json, text/javascript"
        },
        contents: {
          xml: /\bxml\b/,
          html: /\bhtml/,
          json: /\bjson\b/
        },
        responseFields: {
          xml: "responseXML",
          text: "responseText",
          json: "responseJSON"
        },
        // Data converters
        // Keys separate source (or catchall "*") and destination types with a single space
        converters: {
          // Convert anything to text
          "* text": String,
          // Text to html (true = no transformation)
          "text html": true,
          // Evaluate text as a json expression
          "text json": JSON.parse,
          // Parse text as xml
          "text xml": jQuery.parseXML
        },
        // For options that shouldn't be deep extended:
        // you can add your own custom options here if
        // and when you create one that shouldn't be
        // deep extended (see ajaxExtend)
        flatOptions: {
          url: true,
          context: true
        }
      },
      // Creates a full fledged settings object into target
      // with both ajaxSettings and settings fields.
      // If target is omitted, writes into ajaxSettings.
      ajaxSetup: function (target, settings) {
        return settings ? // Building a settings object
        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
        ajaxExtend(jQuery.ajaxSettings, target);
      },
      ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
      ajaxTransport: addToPrefiltersOrTransports(transports),
      // Main method
      ajax: function (url, options) {
        // If url is an object, simulate pre-1.5 signature
        if (typeof url === "object") {
          options = url;
          url = undefined;
        } // Force options to be an object


        options = options || {};
        var transport,
            // URL without anti-cache param
        cacheURL,
            // Response headers
        responseHeadersString,
            responseHeaders,
            // timeout handle
        timeoutTimer,
            // Url cleanup var
        urlAnchor,
            // Request state (becomes false upon send and true upon completion)
        completed,
            // To know if global events are to be dispatched
        fireGlobals,
            // Loop variable
        i,
            // uncached part of the url
        uncached,
            // Create the final options object
        s = jQuery.ajaxSetup({}, options),
            // Callbacks context
        callbackContext = s.context || s,
            // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
            // Deferreds
        deferred = jQuery.Deferred(),
            completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
        statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
        requestHeaders = {},
            requestHeadersNames = {},
            // Default abort message
        strAbort = "canceled",
            // Fake xhr
        jqXHR = {
          readyState: 0,
          // Builds headers hashtable if needed
          getResponseHeader: function (key) {
            var match;

            if (completed) {
              if (!responseHeaders) {
                responseHeaders = {};

                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                }
              }

              match = responseHeaders[key.toLowerCase() + " "];
            }

            return match == null ? null : match.join(", ");
          },
          // Raw string
          getAllResponseHeaders: function () {
            return completed ? responseHeadersString : null;
          },
          // Caches the header
          setRequestHeader: function (name, value) {
            if (completed == null) {
              name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
              requestHeaders[name] = value;
            }

            return this;
          },
          // Overrides response content-type header
          overrideMimeType: function (type) {
            if (completed == null) {
              s.mimeType = type;
            }

            return this;
          },
          // Status-dependent callbacks
          statusCode: function (map) {
            var code;

            if (map) {
              if (completed) {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              } else {
                // Lazy-add the new callbacks in a way that preserves old ones
                for (code in map) {
                  statusCode[code] = [statusCode[code], map[code]];
                }
              }
            }

            return this;
          },
          // Cancel the request
          abort: function (statusText) {
            var finalText = statusText || strAbort;

            if (transport) {
              transport.abort(finalText);
            }

            done(0, finalText);
            return this;
          }
        }; // Attach deferreds

        deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
        // Handle falsy url in the settings object (#10093: consistency with old signature)
        // We also use the url parameter if available

        s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

        s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

        s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

        if (s.crossDomain == null) {
          urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
          // IE throws exception on accessing the href property if url is malformed,
          // e.g. http://example.com:80x/

          try {
            urlAnchor.href = s.url; // Support: IE <=8 - 11 only
            // Anchor's host property isn't correctly set when s.url is relative

            urlAnchor.href = urlAnchor.href;
            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
          } catch (e) {
            // If there is an error parsing the URL, assume it is crossDomain,
            // it can be rejected by the transport if it is invalid
            s.crossDomain = true;
          }
        } // Convert data if not already a string


        if (s.data && s.processData && typeof s.data !== "string") {
          s.data = jQuery.param(s.data, s.traditional);
        } // Apply prefilters


        inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

        if (completed) {
          return jqXHR;
        } // We can fire global events as of now if asked to
        // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


        fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

        if (fireGlobals && jQuery.active++ === 0) {
          jQuery.event.trigger("ajaxStart");
        } // Uppercase the type


        s.type = s.type.toUpperCase(); // Determine if request has content

        s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
        // and/or If-None-Match header later on
        // Remove hash to simplify url manipulation

        cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

        if (!s.hasContent) {
          // Remember the hash so we can put it back
          uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

          if (s.data && (s.processData || typeof s.data === "string")) {
            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

            delete s.data;
          } // Add or update anti-cache param if needed


          if (s.cache === false) {
            cacheURL = cacheURL.replace(rantiCache, "$1");
            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
          } // Put hash and anti-cache on the URL that will be requested (gh-1732)


          s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
        } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
          s.data = s.data.replace(r20, "+");
        } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


        if (s.ifModified) {
          if (jQuery.lastModified[cacheURL]) {
            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
          }

          if (jQuery.etag[cacheURL]) {
            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
          }
        } // Set the correct header, if data is being sent


        if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
          jqXHR.setRequestHeader("Content-Type", s.contentType);
        } // Set the Accepts header for the server, depending on the dataType


        jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

        for (i in s.headers) {
          jqXHR.setRequestHeader(i, s.headers[i]);
        } // Allow custom headers/mimetypes and early abort


        if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
          // Abort if not done already and return
          return jqXHR.abort();
        } // Aborting is no longer a cancellation


        strAbort = "abort"; // Install callbacks on deferreds

        completeDeferred.add(s.complete);
        jqXHR.done(s.success);
        jqXHR.fail(s.error); // Get transport

        transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

        if (!transport) {
          done(-1, "No Transport");
        } else {
          jqXHR.readyState = 1; // Send global event

          if (fireGlobals) {
            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
          } // If request was aborted inside ajaxSend, stop there


          if (completed) {
            return jqXHR;
          } // Timeout


          if (s.async && s.timeout > 0) {
            timeoutTimer = window.setTimeout(function () {
              jqXHR.abort("timeout");
            }, s.timeout);
          }

          try {
            completed = false;
            transport.send(requestHeaders, done);
          } catch (e) {
            // Rethrow post-completion exceptions
            if (completed) {
              throw e;
            } // Propagate others as results


            done(-1, e);
          }
        } // Callback for when everything is done


        function done(status, nativeStatusText, responses, headers) {
          var isSuccess,
              success,
              error,
              response,
              modified,
              statusText = nativeStatusText; // Ignore repeat invocations

          if (completed) {
            return;
          }

          completed = true; // Clear timeout if it exists

          if (timeoutTimer) {
            window.clearTimeout(timeoutTimer);
          } // Dereference transport for early garbage collection
          // (no matter how long the jqXHR object will be used)


          transport = undefined; // Cache response headers

          responseHeadersString = headers || ""; // Set readyState

          jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

          isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

          if (responses) {
            response = ajaxHandleResponses(s, jqXHR, responses);
          } // Use a noop converter for missing script but not if jsonp


          if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
            s.converters["text script"] = function () {};
          } // Convert no matter what (that way responseXXX fields are always set)


          response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

          if (isSuccess) {
            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
              modified = jqXHR.getResponseHeader("Last-Modified");

              if (modified) {
                jQuery.lastModified[cacheURL] = modified;
              }

              modified = jqXHR.getResponseHeader("etag");

              if (modified) {
                jQuery.etag[cacheURL] = modified;
              }
            } // if no content


            if (status === 204 || s.type === "HEAD") {
              statusText = "nocontent"; // if not modified
            } else if (status === 304) {
              statusText = "notmodified"; // If we have data, let's convert it
            } else {
              statusText = response.state;
              success = response.data;
              error = response.error;
              isSuccess = !error;
            }
          } else {
            // Extract error from statusText and normalize for non-aborts
            error = statusText;

            if (status || !statusText) {
              statusText = "error";

              if (status < 0) {
                status = 0;
              }
            }
          } // Set data for the fake xhr object


          jqXHR.status = status;
          jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

          if (isSuccess) {
            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
          } else {
            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
          } // Status-dependent callbacks


          jqXHR.statusCode(statusCode);
          statusCode = undefined;

          if (fireGlobals) {
            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
          } // Complete


          completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

          if (fireGlobals) {
            globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

            if (! --jQuery.active) {
              jQuery.event.trigger("ajaxStop");
            }
          }
        }

        return jqXHR;
      },
      getJSON: function (url, data, callback) {
        return jQuery.get(url, data, callback, "json");
      },
      getScript: function (url, callback) {
        return jQuery.get(url, undefined, callback, "script");
      }
    });
    jQuery.each(["get", "post"], function (_i, method) {
      jQuery[method] = function (url, data, callback, type) {
        // Shift arguments if data argument was omitted
        if (isFunction(data)) {
          type = type || callback;
          callback = data;
          data = undefined;
        } // The url can be an options object (which then must have .url)


        return jQuery.ajax(jQuery.extend({
          url: url,
          type: method,
          dataType: type,
          data: data,
          success: callback
        }, jQuery.isPlainObject(url) && url));
      };
    });
    jQuery.ajaxPrefilter(function (s) {
      var i;

      for (i in s.headers) {
        if (i.toLowerCase() === "content-type") {
          s.contentType = s.headers[i] || "";
        }
      }
    });

    jQuery._evalUrl = function (url, options, doc) {
      return jQuery.ajax({
        url: url,
        // Make this explicit, since user can override this through ajaxSetup (#11264)
        type: "GET",
        dataType: "script",
        cache: true,
        async: false,
        global: false,
        // Only evaluate the response if it is successful (gh-4126)
        // dataFilter is not invoked for failure responses, so using it instead
        // of the default converter is kludgy but it works.
        converters: {
          "text script": function () {}
        },
        dataFilter: function (response) {
          jQuery.globalEval(response, options, doc);
        }
      });
    };

    jQuery.fn.extend({
      wrapAll: function (html) {
        var wrap;

        if (this[0]) {
          if (isFunction(html)) {
            html = html.call(this[0]);
          } // The elements to wrap the target around


          wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

          if (this[0].parentNode) {
            wrap.insertBefore(this[0]);
          }

          wrap.map(function () {
            var elem = this;

            while (elem.firstElementChild) {
              elem = elem.firstElementChild;
            }

            return elem;
          }).append(this);
        }

        return this;
      },
      wrapInner: function (html) {
        if (isFunction(html)) {
          return this.each(function (i) {
            jQuery(this).wrapInner(html.call(this, i));
          });
        }

        return this.each(function () {
          var self = jQuery(this),
              contents = self.contents();

          if (contents.length) {
            contents.wrapAll(html);
          } else {
            self.append(html);
          }
        });
      },
      wrap: function (html) {
        var htmlIsFunction = isFunction(html);
        return this.each(function (i) {
          jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
        });
      },
      unwrap: function (selector) {
        this.parent(selector).not("body").each(function () {
          jQuery(this).replaceWith(this.childNodes);
        });
        return this;
      }
    });

    jQuery.expr.pseudos.hidden = function (elem) {
      return !jQuery.expr.pseudos.visible(elem);
    };

    jQuery.expr.pseudos.visible = function (elem) {
      return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    };

    jQuery.ajaxSettings.xhr = function () {
      try {
        return new window.XMLHttpRequest();
      } catch (e) {}
    };

    var xhrSuccessStatus = {
      // File protocol always yields status code 0, assume 200
      0: 200,
      // Support: IE <=9 only
      // #1450: sometimes IE returns 1223 when it should be 204
      1223: 204
    },
        xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
    support.ajax = xhrSupported = !!xhrSupported;
    jQuery.ajaxTransport(function (options) {
      var callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest

      if (support.cors || xhrSupported && !options.crossDomain) {
        return {
          send: function (headers, complete) {
            var i,
                xhr = options.xhr();
            xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

            if (options.xhrFields) {
              for (i in options.xhrFields) {
                xhr[i] = options.xhrFields[i];
              }
            } // Override mime type if needed


            if (options.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(options.mimeType);
            } // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.


            if (!options.crossDomain && !headers["X-Requested-With"]) {
              headers["X-Requested-With"] = "XMLHttpRequest";
            } // Set headers


            for (i in headers) {
              xhr.setRequestHeader(i, headers[i]);
            } // Callback


            callback = function (type) {
              return function () {
                if (callback) {
                  callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                  if (type === "abort") {
                    xhr.abort();
                  } else if (type === "error") {
                    // Support: IE <=9 only
                    // On a manual native abort, IE9 throws
                    // errors on any property access that is not readyState
                    if (typeof xhr.status !== "number") {
                      complete(0, "error");
                    } else {
                      complete( // File: protocol always yields status 0; see #8605, #14207
                      xhr.status, xhr.statusText);
                    }
                  } else {
                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                    // IE9 has no XHR2 but throws on binary (trac-11426)
                    // For XHR2 non-text, let the caller handle it (gh-2498)
                    (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                      binary: xhr.response
                    } : {
                      text: xhr.responseText
                    }, xhr.getAllResponseHeaders());
                  }
                }
              };
            }; // Listen to events


            xhr.onload = callback();
            errorCallback = xhr.onerror = xhr.ontimeout = callback("error"); // Support: IE 9 only
            // Use onreadystatechange to replace onabort
            // to handle uncaught aborts

            if (xhr.onabort !== undefined) {
              xhr.onabort = errorCallback;
            } else {
              xhr.onreadystatechange = function () {
                // Check readyState before timeout as it changes
                if (xhr.readyState === 4) {
                  // Allow onerror to be called first,
                  // but that will not handle a native abort
                  // Also, save errorCallback to a variable
                  // as xhr.onerror cannot be accessed
                  window.setTimeout(function () {
                    if (callback) {
                      errorCallback();
                    }
                  });
                }
              };
            } // Create the abort callback


            callback = callback("abort");

            try {
              // Do send the request (this may raise an exception)
              xhr.send(options.hasContent && options.data || null);
            } catch (e) {
              // #14683: Only rethrow if this hasn't been notified as an error yet
              if (callback) {
                throw e;
              }
            }
          },
          abort: function () {
            if (callback) {
              callback();
            }
          }
        };
      }
    }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

    jQuery.ajaxPrefilter(function (s) {
      if (s.crossDomain) {
        s.contents.script = false;
      }
    }); // Install script dataType

    jQuery.ajaxSetup({
      accepts: {
        script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
      },
      contents: {
        script: /\b(?:java|ecma)script\b/
      },
      converters: {
        "text script": function (text) {
          jQuery.globalEval(text);
          return text;
        }
      }
    }); // Handle cache's special case and crossDomain

    jQuery.ajaxPrefilter("script", function (s) {
      if (s.cache === undefined) {
        s.cache = false;
      }

      if (s.crossDomain) {
        s.type = "GET";
      }
    }); // Bind script tag hack transport

    jQuery.ajaxTransport("script", function (s) {
      // This transport only deals with cross domain or forced-by-attrs requests
      if (s.crossDomain || s.scriptAttrs) {
        var script, callback;
        return {
          send: function (_, complete) {
            script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
              charset: s.scriptCharset,
              src: s.url
            }).on("load error", callback = function (evt) {
              script.remove();
              callback = null;

              if (evt) {
                complete(evt.type === "error" ? 404 : 200, evt.type);
              }
            }); // Use native DOM manipulation to avoid our domManip AJAX trickery

            document.head.appendChild(script[0]);
          },
          abort: function () {
            if (callback) {
              callback();
            }
          }
        };
      }
    });
    var oldCallbacks = [],
        rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

    jQuery.ajaxSetup({
      jsonp: "callback",
      jsonpCallback: function () {
        var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
        this[callback] = true;
        return callback;
      }
    }); // Detect, normalize options and install callbacks for jsonp requests

    jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
      var callbackName,
          overwritten,
          responseContainer,
          jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

      if (jsonProp || s.dataTypes[0] === "jsonp") {
        // Get callback name, remembering preexisting value associated with it
        callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

        if (jsonProp) {
          s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
        } else if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
        } // Use data converter to retrieve json after script execution


        s.converters["script json"] = function () {
          if (!responseContainer) {
            jQuery.error(callbackName + " was not called");
          }

          return responseContainer[0];
        }; // Force json dataType


        s.dataTypes[0] = "json"; // Install callback

        overwritten = window[callbackName];

        window[callbackName] = function () {
          responseContainer = arguments;
        }; // Clean-up function (fires after converters)


        jqXHR.always(function () {
          // If previous value didn't exist - remove it
          if (overwritten === undefined) {
            jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
          } else {
            window[callbackName] = overwritten;
          } // Save back as free


          if (s[callbackName]) {
            // Make sure that re-using the options doesn't screw things around
            s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

            oldCallbacks.push(callbackName);
          } // Call if it was a function and we have a response


          if (responseContainer && isFunction(overwritten)) {
            overwritten(responseContainer[0]);
          }

          responseContainer = overwritten = undefined;
        }); // Delegate to script

        return "script";
      }
    }); // Support: Safari 8 only
    // In Safari 8 documents created via document.implementation.createHTMLDocument
    // collapse sibling forms: the second one becomes a child of the first one.
    // Because of that, this security measure has to be disabled in Safari 8.
    // https://bugs.webkit.org/show_bug.cgi?id=137337

    support.createHTMLDocument = function () {
      var body = document.implementation.createHTMLDocument("").body;
      body.innerHTML = "<form></form><form></form>";
      return body.childNodes.length === 2;
    }(); // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string


    jQuery.parseHTML = function (data, context, keepScripts) {
      if (typeof data !== "string") {
        return [];
      }

      if (typeof context === "boolean") {
        keepScripts = context;
        context = false;
      }

      var base, parsed, scripts;

      if (!context) {
        // Stop scripts or inline event handlers from being executed immediately
        // by using document.implementation
        if (support.createHTMLDocument) {
          context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
          // so any parsed elements with URLs
          // are based on the document's URL (gh-2965)

          base = context.createElement("base");
          base.href = document.location.href;
          context.head.appendChild(base);
        } else {
          context = document;
        }
      }

      parsed = rsingleTag.exec(data);
      scripts = !keepScripts && []; // Single tag

      if (parsed) {
        return [context.createElement(parsed[1])];
      }

      parsed = buildFragment([data], context, scripts);

      if (scripts && scripts.length) {
        jQuery(scripts).remove();
      }

      return jQuery.merge([], parsed.childNodes);
    };
    /**
     * Load a url into a page
     */


    jQuery.fn.load = function (url, params, callback) {
      var selector,
          type,
          response,
          self = this,
          off = url.indexOf(" ");

      if (off > -1) {
        selector = stripAndCollapse(url.slice(off));
        url = url.slice(0, off);
      } // If it's a function


      if (isFunction(params)) {
        // We assume that it's the callback
        callback = params;
        params = undefined; // Otherwise, build a param string
      } else if (params && typeof params === "object") {
        type = "POST";
      } // If we have elements to modify, make the request


      if (self.length > 0) {
        jQuery.ajax({
          url: url,
          // If "type" variable is undefined, then "GET" method will be used.
          // Make value of this field explicit since
          // user can override it through ajaxSetup method
          type: type || "GET",
          dataType: "html",
          data: params
        }).done(function (responseText) {
          // Save response for use in complete callback
          response = arguments;
          self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
          // Exclude scripts to avoid IE 'Permission Denied' errors
          jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
          responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
          // but they are ignored because response was set above.
          // If it fails, this function gets "jqXHR", "status", "error"
        }).always(callback && function (jqXHR, status) {
          self.each(function () {
            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
          });
        });
      }

      return this;
    };

    jQuery.expr.pseudos.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };

    jQuery.offset = {
      setOffset: function (elem, options, i) {
        var curPosition,
            curLeft,
            curCSSTop,
            curTop,
            curOffset,
            curCSSLeft,
            calculatePosition,
            position = jQuery.css(elem, "position"),
            curElem = jQuery(elem),
            props = {}; // Set position first, in-case top/left are set even on static elem

        if (position === "static") {
          elem.style.position = "relative";
        }

        curOffset = curElem.offset();
        curCSSTop = jQuery.css(elem, "top");
        curCSSLeft = jQuery.css(elem, "left");
        calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
        // top or left is auto and position is either absolute or fixed

        if (calculatePosition) {
          curPosition = curElem.position();
          curTop = curPosition.top;
          curLeft = curPosition.left;
        } else {
          curTop = parseFloat(curCSSTop) || 0;
          curLeft = parseFloat(curCSSLeft) || 0;
        }

        if (isFunction(options)) {
          // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
          options = options.call(elem, i, jQuery.extend({}, curOffset));
        }

        if (options.top != null) {
          props.top = options.top - curOffset.top + curTop;
        }

        if (options.left != null) {
          props.left = options.left - curOffset.left + curLeft;
        }

        if ("using" in options) {
          options.using.call(elem, props);
        } else {
          curElem.css(props);
        }
      }
    };
    jQuery.fn.extend({
      // offset() relates an element's border box to the document origin
      offset: function (options) {
        // Preserve chaining for setter
        if (arguments.length) {
          return options === undefined ? this : this.each(function (i) {
            jQuery.offset.setOffset(this, options, i);
          });
        }

        var rect,
            win,
            elem = this[0];

        if (!elem) {
          return;
        } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
        // Support: IE <=11 only
        // Running getBoundingClientRect on a
        // disconnected node in IE throws an error


        if (!elem.getClientRects().length) {
          return {
            top: 0,
            left: 0
          };
        } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


        rect = elem.getBoundingClientRect();
        win = elem.ownerDocument.defaultView;
        return {
          top: rect.top + win.pageYOffset,
          left: rect.left + win.pageXOffset
        };
      },
      // position() relates an element's margin box to its offset parent's padding box
      // This corresponds to the behavior of CSS absolute positioning
      position: function () {
        if (!this[0]) {
          return;
        }

        var offsetParent,
            offset,
            doc,
            elem = this[0],
            parentOffset = {
          top: 0,
          left: 0
        }; // position:fixed elements are offset from the viewport, which itself always has zero offset

        if (jQuery.css(elem, "position") === "fixed") {
          // Assume position:fixed implies availability of getBoundingClientRect
          offset = elem.getBoundingClientRect();
        } else {
          offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
          // when a statically positioned element is identified

          doc = elem.ownerDocument;
          offsetParent = elem.offsetParent || doc.documentElement;

          while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.parentNode;
          }

          if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
            // Incorporate borders into its offset, since they are outside its content origin
            parentOffset = jQuery(offsetParent).offset();
            parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
            parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
          }
        } // Subtract parent offsets and element margins


        return {
          top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
          left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
        };
      },
      // This method will return documentElement in the following cases:
      // 1) For the element inside the iframe without offsetParent, this method will return
      //    documentElement of the parent window
      // 2) For the hidden or detached element
      // 3) For body or html element, i.e. in case of the html node - it will return itself
      //
      // but those exceptions were never presented as a real life use-cases
      // and might be considered as more preferable results.
      //
      // This logic, however, is not guaranteed and can change at any point in the future
      offsetParent: function () {
        return this.map(function () {
          var offsetParent = this.offsetParent;

          while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
            offsetParent = offsetParent.offsetParent;
          }

          return offsetParent || documentElement;
        });
      }
    }); // Create scrollLeft and scrollTop methods

    jQuery.each({
      scrollLeft: "pageXOffset",
      scrollTop: "pageYOffset"
    }, function (method, prop) {
      var top = "pageYOffset" === prop;

      jQuery.fn[method] = function (val) {
        return access(this, function (elem, method, val) {
          // Coalesce documents and windows
          var win;

          if (isWindow(elem)) {
            win = elem;
          } else if (elem.nodeType === 9) {
            win = elem.defaultView;
          }

          if (val === undefined) {
            return win ? win[prop] : elem[method];
          }

          if (win) {
            win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
          } else {
            elem[method] = val;
          }
        }, method, val, arguments.length);
      };
    }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here

    jQuery.each(["top", "left"], function (_i, prop) {
      jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
        if (computed) {
          computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

          return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
        }
      });
    }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

    jQuery.each({
      Height: "height",
      Width: "width"
    }, function (name, type) {
      jQuery.each({
        padding: "inner" + name,
        content: type,
        "": "outer" + name
      }, function (defaultExtra, funcName) {
        // Margin is only for outerHeight, outerWidth
        jQuery.fn[funcName] = function (margin, value) {
          var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
              extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
          return access(this, function (elem, type, value) {
            var doc;

            if (isWindow(elem)) {
              // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
              return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
            } // Get document width or height


            if (elem.nodeType === 9) {
              doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
              // whichever is greatest

              return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
            }

            return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
            jQuery.css(elem, type, extra) : // Set width or height on the element
            jQuery.style(elem, type, value, extra);
          }, type, chainable ? margin : undefined, chainable);
        };
      });
    });
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
      jQuery.fn[type] = function (fn) {
        return this.on(type, fn);
      };
    });
    jQuery.fn.extend({
      bind: function (types, data, fn) {
        return this.on(types, null, data, fn);
      },
      unbind: function (types, fn) {
        return this.off(types, null, fn);
      },
      delegate: function (selector, types, data, fn) {
        return this.on(types, selector, data, fn);
      },
      undelegate: function (selector, types, fn) {
        // ( namespace ) or ( selector, types [, fn] )
        return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
      },
      hover: function (fnOver, fnOut) {
        return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
      }
    });
    jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
      // Handle event binding
      jQuery.fn[name] = function (data, fn) {
        return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
      };
    }); // Support: Android <=4.0 only
    // Make sure we trim BOM and NBSP

    var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
    // arguments.
    // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
    // However, it is not slated for removal any time soon

    jQuery.proxy = function (fn, context) {
      var tmp, args, proxy;

      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      } // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.


      if (!isFunction(fn)) {
        return undefined;
      } // Simulated bind


      args = slice.call(arguments, 2);

      proxy = function () {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      }; // Set the guid of unique handler to the same of original handler, so it can be removed


      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    };

    jQuery.holdReady = function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    };

    jQuery.isArray = Array.isArray;
    jQuery.parseJSON = JSON.parse;
    jQuery.nodeName = nodeName;
    jQuery.isFunction = isFunction;
    jQuery.isWindow = isWindow;
    jQuery.camelCase = camelCase;
    jQuery.type = toType;
    jQuery.now = Date.now;

    jQuery.isNumeric = function (obj) {
      // As of jQuery 3.0, isNumeric is limited to
      // strings and numbers (primitives or objects)
      // that can be coerced to finite numbers (gh-2662)
      var type = jQuery.type(obj);
      return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
      // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
      // subtraction forces infinities to NaN
      !isNaN(obj - parseFloat(obj));
    };

    jQuery.trim = function (text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    }; // Register as a named AMD module, since jQuery can be concatenated with other

    var // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
        // Map over the $ in case of overwrite
    _$ = window.$;

    jQuery.noConflict = function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }

      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }

      return jQuery;
    }; // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)


    if (typeof noGlobal === "undefined") {
      window.jQuery = window.$ = jQuery;
    }

    return jQuery;
  });
  }(jquery));

  var $ = jquery.exports;

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var extendStatics$2 = function (d, b) {
    extendStatics$2 = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics$2(d, b);
  };

  function __extends$3(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$2(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign$1 = function () {
    __assign$1 = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };

    return __assign$1.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};

    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      });
    }

    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator,
        m = s && o[s],
        i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
      next: function () {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;

    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }

    return ar;
  }
  function __spreadArray$1(to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

    return to;
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i;

    function verb(n) {
      if (g[n]) i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }

    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }

    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }

    function fulfill(value) {
      resume("next", value);
    }

    function reject(value) {
      resume("throw", value);
    }

    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);

    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }

    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  }

  function isFunction(value) {
    return typeof value === 'function';
  }

  function createErrorClass(createImpl) {
    var _super = function (instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };

    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  var UnsubscriptionError = createErrorClass(function (_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);

      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) {
        return i + 1 + ") " + err.toString();
      }).join('\n  ') : '';
      this.name = 'UnsubscriptionError';
      this.errors = errors;
    };
  });

  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  var Subscription = function () {
    function Subscription(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._teardowns = null;
    }

    Subscription.prototype.unsubscribe = function () {
      var e_1, _a, e_2, _b;

      var errors;

      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;

        if (_parentage) {
          this._parentage = null;

          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = {
                error: e_1_1
              };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a = _parentage_1.return)) _a.call(_parentage_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }

        var initialTeardown = this.initialTeardown;

        if (isFunction(initialTeardown)) {
          try {
            initialTeardown();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }

        var _teardowns = this._teardowns;

        if (_teardowns) {
          this._teardowns = null;

          try {
            for (var _teardowns_1 = __values(_teardowns), _teardowns_1_1 = _teardowns_1.next(); !_teardowns_1_1.done; _teardowns_1_1 = _teardowns_1.next()) {
              var teardown_1 = _teardowns_1_1.value;

              try {
                execTeardown(teardown_1);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];

                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray$1(__spreadArray$1([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = {
              error: e_2_1
            };
          } finally {
            try {
              if (_teardowns_1_1 && !_teardowns_1_1.done && (_b = _teardowns_1.return)) _b.call(_teardowns_1);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }

        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };

    Subscription.prototype.add = function (teardown) {
      var _a;

      if (teardown && teardown !== this) {
        if (this.closed) {
          execTeardown(teardown);
        } else {
          if (teardown instanceof Subscription) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }

            teardown._addParent(this);
          }

          (this._teardowns = (_a = this._teardowns) !== null && _a !== void 0 ? _a : []).push(teardown);
        }
      }
    };

    Subscription.prototype._hasParent = function (parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };

    Subscription.prototype._addParent = function (parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };

    Subscription.prototype._removeParent = function (parent) {
      var _parentage = this._parentage;

      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };

    Subscription.prototype.remove = function (teardown) {
      var _teardowns = this._teardowns;
      _teardowns && arrRemove(_teardowns, teardown);

      if (teardown instanceof Subscription) {
        teardown._removeParent(this);
      }
    };

    Subscription.EMPTY = function () {
      var empty = new Subscription();
      empty.closed = true;
      return empty;
    }();

    return Subscription;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }

  function execTeardown(teardown) {
    if (isFunction(teardown)) {
      teardown();
    } else {
      teardown.unsubscribe();
    }
  }

  var config$1 = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: undefined,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  var timeoutProvider = {
    setTimeout: function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) || setTimeout).apply(void 0, __spreadArray$1([], __read(args)));
    },
    clearTimeout: function (handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: undefined
  };

  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function () {

      {
        throw err;
      }
    });
  }

  function noop$1() {}

  var COMPLETE_NOTIFICATION = function () {
    return createNotification('C', undefined, undefined);
  }();
  function errorNotification(error) {
    return createNotification('E', undefined, error);
  }
  function nextNotification(value) {
    return createNotification('N', value, undefined);
  }
  function createNotification(kind, value, error) {
    return {
      kind: kind,
      value: value,
      error: error
    };
  }

  var context = null;
  function errorContext(cb) {
    if (config$1.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;

      if (isRoot) {
        context = {
          errorThrown: false,
          error: null
        };
      }

      cb();

      if (isRoot) {
        var _a = context,
            errorThrown = _a.errorThrown,
            error = _a.error;
        context = null;

        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }

  var Subscriber = function (_super) {
    __extends$3(Subscriber, _super);

    function Subscriber(destination) {
      var _this = _super.call(this) || this;

      _this.isStopped = false;

      if (destination) {
        _this.destination = destination;

        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }

      return _this;
    }

    Subscriber.create = function (next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };

    Subscriber.prototype.next = function (value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };

    Subscriber.prototype.error = function (err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;

        this._error(err);
      }
    };

    Subscriber.prototype.complete = function () {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;

        this._complete();
      }
    };

    Subscriber.prototype.unsubscribe = function () {
      if (!this.closed) {
        this.isStopped = true;

        _super.prototype.unsubscribe.call(this);

        this.destination = null;
      }
    };

    Subscriber.prototype._next = function (value) {
      this.destination.next(value);
    };

    Subscriber.prototype._error = function (err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };

    Subscriber.prototype._complete = function () {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };

    return Subscriber;
  }(Subscription);

  var SafeSubscriber = function (_super) {
    __extends$3(SafeSubscriber, _super);

    function SafeSubscriber(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;

      var next;

      if (isFunction(observerOrNext)) {
        next = observerOrNext;
      } else if (observerOrNext) {
        next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete;
        var context_1;

        if (_this && config$1.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);

          context_1.unsubscribe = function () {
            return _this.unsubscribe();
          };
        } else {
          context_1 = observerOrNext;
        }

        next = next === null || next === void 0 ? void 0 : next.bind(context_1);
        error = error === null || error === void 0 ? void 0 : error.bind(context_1);
        complete = complete === null || complete === void 0 ? void 0 : complete.bind(context_1);
      }

      _this.destination = {
        next: next ? wrapForErrorHandling(next) : noop$1,
        error: wrapForErrorHandling(error !== null && error !== void 0 ? error : defaultErrorHandler),
        complete: complete ? wrapForErrorHandling(complete) : noop$1
      };
      return _this;
    }

    return SafeSubscriber;
  }(Subscriber);

  function wrapForErrorHandling(handler, instance) {
    return function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      try {
        handler.apply(void 0, __spreadArray$1([], __read(args)));
      } catch (err) {
        {
          reportUnhandledError(err);
        }
      }
    };
  }

  function defaultErrorHandler(err) {
    throw err;
  }

  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config$1.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function () {
      return onStoppedNotification(notification, subscriber);
    });
  }

  var EMPTY_OBSERVER = {
    closed: true,
    next: noop$1,
    error: defaultErrorHandler,
    complete: noop$1
  };

  var observable = function () {
    return typeof Symbol === 'function' && Symbol.observable || '@@observable';
  }();

  function identity(x) {
    return x;
  }

  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }

    if (fns.length === 1) {
      return fns[0];
    }

    return function piped(input) {
      return fns.reduce(function (prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  var Observable = function () {
    function Observable(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }

    Observable.prototype.lift = function (operator) {
      var observable = new Observable();
      observable.source = this;
      observable.operator = operator;
      return observable;
    };

    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
      var _this = this;

      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function () {
        var _a = _this,
            operator = _a.operator,
            source = _a.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };

    Observable.prototype._trySubscribe = function (sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };

    Observable.prototype.forEach = function (next, promiseCtor) {
      var _this = this;

      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function (resolve, reject) {
        var subscription;
        subscription = _this.subscribe(function (value) {
          try {
            next(value);
          } catch (err) {
            reject(err);
            subscription === null || subscription === void 0 ? void 0 : subscription.unsubscribe();
          }
        }, reject, resolve);
      });
    };

    Observable.prototype._subscribe = function (subscriber) {
      var _a;

      return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);
    };

    Observable.prototype[observable] = function () {
      return this;
    };

    Observable.prototype.pipe = function () {
      var operations = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }

      return pipeFromArray(operations)(this);
    };

    Observable.prototype.toPromise = function (promiseCtor) {
      var _this = this;

      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function (resolve, reject) {
        var value;

        _this.subscribe(function (x) {
          return value = x;
        }, function (err) {
          return reject(err);
        }, function () {
          return resolve(value);
        });
      });
    };

    Observable.create = function (subscribe) {
      return new Observable(subscribe);
    };

    return Observable;
  }();

  function getPromiseCtor(promiseCtor) {
    var _a;

    return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config$1.Promise) !== null && _a !== void 0 ? _a : Promise;
  }

  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }

  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
    return function (source) {
      if (hasLift(source)) {
        return source.lift(function (liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }

      throw new TypeError('Unable to lift unknown Observable type');
    };
  }

  var OperatorSubscriber = function (_super) {
    __extends$3(OperatorSubscriber, _super);

    function OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
      var _this = _super.call(this, destination) || this;

      _this.onFinalize = onFinalize;
      _this._next = onNext ? function (value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function (err) {
        try {
          onError(err);
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function () {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }

    OperatorSubscriber.prototype.unsubscribe = function () {
      var _a;

      var closed = this.closed;

      _super.prototype.unsubscribe.call(this);

      !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));
    };

    return OperatorSubscriber;
  }(Subscriber);

  var ObjectUnsubscribedError = createErrorClass(function (_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);

      this.name = 'ObjectUnsubscribedError';
      this.message = 'object unsubscribed';
    };
  });

  var Subject = function (_super) {
    __extends$3(Subject, _super);

    function Subject() {
      var _this = _super.call(this) || this;

      _this.closed = false;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }

    Subject.prototype.lift = function (operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };

    Subject.prototype._throwIfClosed = function () {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };

    Subject.prototype.next = function (value) {
      var _this = this;

      errorContext(function () {
        var e_1, _a;

        _this._throwIfClosed();

        if (!_this.isStopped) {
          var copy = _this.observers.slice();

          try {
            for (var copy_1 = __values(copy), copy_1_1 = copy_1.next(); !copy_1_1.done; copy_1_1 = copy_1.next()) {
              var observer = copy_1_1.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = {
              error: e_1_1
            };
          } finally {
            try {
              if (copy_1_1 && !copy_1_1.done && (_a = copy_1.return)) _a.call(copy_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
      });
    };

    Subject.prototype.error = function (err) {
      var _this = this;

      errorContext(function () {
        _this._throwIfClosed();

        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;

          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };

    Subject.prototype.complete = function () {
      var _this = this;

      errorContext(function () {
        _this._throwIfClosed();

        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;

          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };

    Subject.prototype.unsubscribe = function () {
      this.isStopped = this.closed = true;
      this.observers = null;
    };

    Object.defineProperty(Subject.prototype, "observed", {
      get: function () {
        var _a;

        return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;
      },
      enumerable: false,
      configurable: true
    });

    Subject.prototype._trySubscribe = function (subscriber) {
      this._throwIfClosed();

      return _super.prototype._trySubscribe.call(this, subscriber);
    };

    Subject.prototype._subscribe = function (subscriber) {
      this._throwIfClosed();

      this._checkFinalizedStatuses(subscriber);

      return this._innerSubscribe(subscriber);
    };

    Subject.prototype._innerSubscribe = function (subscriber) {
      var _a = this,
          hasError = _a.hasError,
          isStopped = _a.isStopped,
          observers = _a.observers;

      return hasError || isStopped ? EMPTY_SUBSCRIPTION : (observers.push(subscriber), new Subscription(function () {
        return arrRemove(observers, subscriber);
      }));
    };

    Subject.prototype._checkFinalizedStatuses = function (subscriber) {
      var _a = this,
          hasError = _a.hasError,
          thrownError = _a.thrownError,
          isStopped = _a.isStopped;

      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };

    Subject.prototype.asObservable = function () {
      var observable = new Observable();
      observable.source = this;
      return observable;
    };

    Subject.create = function (destination, source) {
      return new AnonymousSubject(destination, source);
    };

    return Subject;
  }(Observable);

  var AnonymousSubject = function (_super) {
    __extends$3(AnonymousSubject, _super);

    function AnonymousSubject(destination, source) {
      var _this = _super.call(this) || this;

      _this.destination = destination;
      _this.source = source;
      return _this;
    }

    AnonymousSubject.prototype.next = function (value) {
      var _a, _b;

      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);
    };

    AnonymousSubject.prototype.error = function (err) {
      var _a, _b;

      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);
    };

    AnonymousSubject.prototype.complete = function () {
      var _a, _b;

      (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);
    };

    AnonymousSubject.prototype._subscribe = function (subscriber) {
      var _a, _b;

      return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;
    };

    return AnonymousSubject;
  }(Subject);

  var BehaviorSubject = function (_super) {
    __extends$3(BehaviorSubject, _super);

    function BehaviorSubject(_value) {
      var _this = _super.call(this) || this;

      _this._value = _value;
      return _this;
    }

    Object.defineProperty(BehaviorSubject.prototype, "value", {
      get: function () {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });

    BehaviorSubject.prototype._subscribe = function (subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);

      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };

    BehaviorSubject.prototype.getValue = function () {
      var _a = this,
          hasError = _a.hasError,
          thrownError = _a.thrownError,
          _value = _a._value;

      if (hasError) {
        throw thrownError;
      }

      this._throwIfClosed();

      return _value;
    };

    BehaviorSubject.prototype.next = function (value) {
      _super.prototype.next.call(this, this._value = value);
    };

    return BehaviorSubject;
  }(Subject);

  var dateTimestampProvider = {
    now: function () {
      return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: undefined
  };

  var Action = function (_super) {
    __extends$3(Action, _super);

    function Action(scheduler, work) {
      return _super.call(this) || this;
    }

    Action.prototype.schedule = function (state, delay) {

      return this;
    };

    return Action;
  }(Subscription);

  var intervalProvider = {
    setInterval: function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var delegate = intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) || setInterval).apply(void 0, __spreadArray$1([], __read(args)));
    },
    clearInterval: function (handle) {
      var delegate = intervalProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);
    },
    delegate: undefined
  };

  var AsyncAction = function (_super) {
    __extends$3(AsyncAction, _super);

    function AsyncAction(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;

      _this.scheduler = scheduler;
      _this.work = work;
      _this.pending = false;
      return _this;
    }

    AsyncAction.prototype.schedule = function (state, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      if (this.closed) {
        return this;
      }

      this.state = state;
      var id = this.id;
      var scheduler = this.scheduler;

      if (id != null) {
        this.id = this.recycleAsyncId(scheduler, id, delay);
      }

      this.pending = true;
      this.delay = delay;
      this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
      return this;
    };

    AsyncAction.prototype.requestAsyncId = function (scheduler, _id, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);
    };

    AsyncAction.prototype.recycleAsyncId = function (_scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      if (delay != null && this.delay === delay && this.pending === false) {
        return id;
      }

      intervalProvider.clearInterval(id);
      return undefined;
    };

    AsyncAction.prototype.execute = function (state, delay) {
      if (this.closed) {
        return new Error('executing a cancelled action');
      }

      this.pending = false;

      var error = this._execute(state, delay);

      if (error) {
        return error;
      } else if (this.pending === false && this.id != null) {
        this.id = this.recycleAsyncId(this.scheduler, this.id, null);
      }
    };

    AsyncAction.prototype._execute = function (state, _delay) {
      var errored = false;
      var errorValue;

      try {
        this.work(state);
      } catch (e) {
        errored = true;
        errorValue = e ? e : new Error('Scheduled action threw falsy error');
      }

      if (errored) {
        this.unsubscribe();
        return errorValue;
      }
    };

    AsyncAction.prototype.unsubscribe = function () {
      if (!this.closed) {
        var _a = this,
            id = _a.id,
            scheduler = _a.scheduler;

        var actions = scheduler.actions;
        this.work = this.state = this.scheduler = null;
        this.pending = false;
        arrRemove(actions, this);

        if (id != null) {
          this.id = this.recycleAsyncId(scheduler, id, null);
        }

        this.delay = null;

        _super.prototype.unsubscribe.call(this);
      }
    };

    return AsyncAction;
  }(Action);

  var Scheduler = function () {
    function Scheduler(schedulerActionCtor, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }

      this.schedulerActionCtor = schedulerActionCtor;
      this.now = now;
    }

    Scheduler.prototype.schedule = function (work, delay, state) {
      if (delay === void 0) {
        delay = 0;
      }

      return new this.schedulerActionCtor(this, work).schedule(state, delay);
    };

    Scheduler.now = dateTimestampProvider.now;
    return Scheduler;
  }();

  var AsyncScheduler = function (_super) {
    __extends$3(AsyncScheduler, _super);

    function AsyncScheduler(SchedulerAction, now) {
      if (now === void 0) {
        now = Scheduler.now;
      }

      var _this = _super.call(this, SchedulerAction, now) || this;

      _this.actions = [];
      _this._active = false;
      _this._scheduled = undefined;
      return _this;
    }

    AsyncScheduler.prototype.flush = function (action) {
      var actions = this.actions;

      if (this._active) {
        actions.push(action);
        return;
      }

      var error;
      this._active = true;

      do {
        if (error = action.execute(action.state, action.delay)) {
          break;
        }
      } while (action = actions.shift());

      this._active = false;

      if (error) {
        while (action = actions.shift()) {
          action.unsubscribe();
        }

        throw error;
      }
    };

    return AsyncScheduler;
  }(Scheduler);

  var asyncScheduler = new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;

  var QueueAction = function (_super) {
    __extends$3(QueueAction, _super);

    function QueueAction(scheduler, work) {
      var _this = _super.call(this, scheduler, work) || this;

      _this.scheduler = scheduler;
      _this.work = work;
      return _this;
    }

    QueueAction.prototype.schedule = function (state, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      if (delay > 0) {
        return _super.prototype.schedule.call(this, state, delay);
      }

      this.delay = delay;
      this.state = state;
      this.scheduler.flush(this);
      return this;
    };

    QueueAction.prototype.execute = function (state, delay) {
      return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);
    };

    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      if (delay != null && delay > 0 || delay == null && this.delay > 0) {
        return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
      }

      return scheduler.flush(this);
    };

    return QueueAction;
  }(AsyncAction);

  var QueueScheduler = function (_super) {
    __extends$3(QueueScheduler, _super);

    function QueueScheduler() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    return QueueScheduler;
  }(AsyncScheduler);

  var queueScheduler = new QueueScheduler(QueueAction);

  var EMPTY = new Observable(function (subscriber) {
    return subscriber.complete();
  });

  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }

  function last(arr) {
    return arr[arr.length - 1];
  }

  function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : undefined;
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : undefined;
  }
  function popNumber(args, defaultValue) {
    return typeof last(args) === 'number' ? args.pop() : defaultValue;
  }

  var isArrayLike = function (x) {
    return x && typeof x.length === 'number' && typeof x !== 'function';
  };

  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }

  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }

  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === 'object' ? 'an invalid object' : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
      return '@@iterator';
    }

    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a, value, done;

      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            reader = readableStream.getReader();
            _b.label = 1;

          case 1:
            _b.trys.push([1,, 9, 10]);

            _b.label = 2;

          case 2:
            return [4, __await(reader.read())];

          case 3:
            _a = _b.sent(), value = _a.value, done = _a.done;
            if (!done) return [3, 5];
            return [4, __await(void 0)];

          case 4:
            return [2, _b.sent()];

          case 5:
            return [4, __await(value)];

          case 6:
            return [4, _b.sent()];

          case 7:
            _b.sent();

            return [3, 2];

          case 8:
            return [3, 10];

          case 9:
            reader.releaseLock();
            return [7];

          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }

    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }

      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }

      if (isPromise(input)) {
        return fromPromise(input);
      }

      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }

      if (isIterable(input)) {
        return fromIterable(input);
      }

      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }

    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function (subscriber) {
      var obs = obj[observable]();

      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }

      throw new TypeError('Provided object does not correctly implement Symbol.observable');
    });
  }
  function fromArrayLike(array) {
    return new Observable(function (subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }

      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function (subscriber) {
      promise.then(function (value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function (err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function (subscriber) {
      var e_1, _a;

      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);

          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
        } finally {
          if (e_1) throw e_1.error;
        }
      }

      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function (subscriber) {
      process(asyncIterable, subscriber).catch(function (err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }

  function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;

    var e_2, _a;

    return __awaiter(this, void 0, void 0, function () {
      var value, e_2_1;
      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            _b.trys.push([0, 5, 6, 11]);

            asyncIterable_1 = __asyncValues(asyncIterable);
            _b.label = 1;

          case 1:
            return [4, asyncIterable_1.next()];

          case 2:
            if (!(asyncIterable_1_1 = _b.sent(), !asyncIterable_1_1.done)) return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);

            if (subscriber.closed) {
              return [2];
            }

            _b.label = 3;

          case 3:
            return [3, 1];

          case 4:
            return [3, 11];

          case 5:
            e_2_1 = _b.sent();
            e_2 = {
              error: e_2_1
            };
            return [3, 11];

          case 6:
            _b.trys.push([6,, 9, 10]);

            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return))) return [3, 8];
            return [4, _a.call(asyncIterable_1)];

          case 7:
            _b.sent();

            _b.label = 8;

          case 8:
            return [3, 10];

          case 9:
            if (e_2) throw e_2.error;
            return [7];

          case 10:
            return [7];

          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
      delay = 0;
    }

    if (repeat === void 0) {
      repeat = false;
    }

    var scheduleSubscription = scheduler.schedule(function () {
      work();

      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);

    if (!repeat) {
      return scheduleSubscription;
    }
  }

  function observeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return operate(function (source, subscriber) {
      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        return executeSchedule(subscriber, scheduler, function () {
          return subscriber.next(value);
        }, delay);
      }, function () {
        return executeSchedule(subscriber, scheduler, function () {
          return subscriber.complete();
        }, delay);
      }, function (err) {
        return executeSchedule(subscriber, scheduler, function () {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }

  function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }

    return operate(function (source, subscriber) {
      subscriber.add(scheduler.schedule(function () {
        return source.subscribe(subscriber);
      }, delay));
    });
  }

  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
      var i = 0;
      return scheduler.schedule(function () {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);

          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  function scheduleIterable(input, scheduler) {
    return new Observable(function (subscriber) {
      var iterator$1;
      executeSchedule(subscriber, scheduler, function () {
        iterator$1 = input[iterator]();
        executeSchedule(subscriber, scheduler, function () {
          var _a;

          var value;
          var done;

          try {
            _a = iterator$1.next(), value = _a.value, done = _a.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }

          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function () {
        return isFunction(iterator$1 === null || iterator$1 === void 0 ? void 0 : iterator$1.return) && iterator$1.return();
      };
    });
  }

  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error('Iterable cannot be null');
    }

    return new Observable(function (subscriber) {
      executeSchedule(subscriber, scheduler, function () {
        var iterator = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function () {
          iterator.next().then(function (result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }

      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }

      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }

      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }

      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }

      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }

    throw createInvalidObservableTypeError(input);
  }

  function from$1(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }

  function of() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var scheduler = popScheduler(args);
    return from$1(args, scheduler);
  }

  function isValidDate(value) {
    return value instanceof Date && !isNaN(value);
  }

  function map(project, thisArg) {
    return operate(function (source, subscriber) {
      var index = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }

  var isArray$1 = Array.isArray;

  function callOrApply(fn, args) {
    return isArray$1(args) ? fn.apply(void 0, __spreadArray$1([], __read(args))) : fn(args);
  }

  function mapOneOrManyArgs(fn) {
    return map(function (args) {
      return callOrApply(fn, args);
    });
  }

  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalTeardown) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;

    var checkComplete = function () {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };

    var outerNext = function (value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };

    var doInnerSub = function (value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(new OperatorSubscriber(subscriber, function (innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);

        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function () {
        innerComplete = true;
      }, undefined, function () {
        if (innerComplete) {
          try {
            active--;

            var _loop_1 = function () {
              var bufferedValue = buffer.shift();

              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function () {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };

            while (buffer.length && active < concurrent) {
              _loop_1();
            }

            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };

    source.subscribe(new OperatorSubscriber(subscriber, outerNext, function () {
      isComplete = true;
      checkComplete();
    }));
    return function () {
      additionalTeardown === null || additionalTeardown === void 0 ? void 0 : additionalTeardown();
    };
  }

  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }

    if (isFunction(resultSelector)) {
      return mergeMap(function (a, i) {
        return map(function (b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === 'number') {
      concurrent = resultSelector;
    }

    return operate(function (source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }

  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }

    return mergeMap(identity, concurrent);
  }

  function concatAll() {
    return mergeAll(1);
  }

  function concat() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    return concatAll()(from$1(args, popScheduler(args)));
  }

  var nodeEventEmitterMethods = ['addListener', 'removeListener'];
  var eventTargetMethods = ['addEventListener', 'removeEventListener'];
  var jqueryMethods = ['on', 'off'];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
      resultSelector = options;
      options = undefined;
    }

    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }

    var _a = __read(isEventTarget(target) ? eventTargetMethods.map(function (methodName) {
      return function (handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2),
        add = _a[0],
        remove = _a[1];

    if (!add) {
      if (isArrayLike(target)) {
        return mergeMap(function (subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom(target));
      }
    }

    if (!add) {
      throw new TypeError('Invalid event target');
    }

    return new Observable(function (subscriber) {
      var handler = function () {
        var args = [];

        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }

        return subscriber.next(1 < args.length ? args : args[0]);
      };

      add(handler);
      return function () {
        return remove(handler);
      };
    });
  }

  function toCommonHandlerRegistry(target, eventName) {
    return function (methodName) {
      return function (handler) {
        return target[methodName](eventName, handler);
      };
    };
  }

  function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
  }

  function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
  }

  function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
  }

  function timer(dueTime, intervalOrScheduler, scheduler) {
    if (dueTime === void 0) {
      dueTime = 0;
    }

    if (scheduler === void 0) {
      scheduler = async;
    }

    var intervalDuration = -1;

    if (intervalOrScheduler != null) {
      if (isScheduler(intervalOrScheduler)) {
        scheduler = intervalOrScheduler;
      } else {
        intervalDuration = intervalOrScheduler;
      }
    }

    return new Observable(function (subscriber) {
      var due = isValidDate(dueTime) ? +dueTime - scheduler.now() : dueTime;

      if (due < 0) {
        due = 0;
      }

      var n = 0;
      return scheduler.schedule(function () {
        if (!subscriber.closed) {
          subscriber.next(n++);

          if (0 <= intervalDuration) {
            this.schedule(undefined, intervalDuration);
          } else {
            subscriber.complete();
          }
        }
      }, due);
    });
  }

  function interval(period, scheduler) {
    if (period === void 0) {
      period = 0;
    }

    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }

    if (period < 0) {
      period = 0;
    }

    return timer(period, period, scheduler);
  }

  function merge$1() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var scheduler = popScheduler(args);
    var concurrent = popNumber(args, Infinity);
    var sources = args;
    return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from$1(sources, scheduler));
  }

  var NEVER = new Observable(noop$1);

  var isArray = Array.isArray;
  function argsOrArgArray(args) {
    return args.length === 1 && isArray(args[0]) ? args[0] : args;
  }

  function filter$1(predicate, thisArg) {
    return operate(function (source, subscriber) {
      var index = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }

  function zip() {
    var args = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }

    var resultSelector = popResultSelector(args);
    var sources = argsOrArgArray(args);
    return sources.length ? new Observable(function (subscriber) {
      var buffers = sources.map(function () {
        return [];
      });
      var completed = sources.map(function () {
        return false;
      });
      subscriber.add(function () {
        buffers = completed = null;
      });

      var _loop_1 = function (sourceIndex) {
        innerFrom(sources[sourceIndex]).subscribe(new OperatorSubscriber(subscriber, function (value) {
          buffers[sourceIndex].push(value);

          if (buffers.every(function (buffer) {
            return buffer.length;
          })) {
            var result = buffers.map(function (buffer) {
              return buffer.shift();
            });
            subscriber.next(resultSelector ? resultSelector.apply(void 0, __spreadArray$1([], __read(result))) : result);

            if (buffers.some(function (buffer, i) {
              return !buffer.length && completed[i];
            })) {
              subscriber.complete();
            }
          }
        }, function () {
          completed[sourceIndex] = true;
          !buffers[sourceIndex].length && subscriber.complete();
        }));
      };

      for (var sourceIndex = 0; !subscriber.closed && sourceIndex < sources.length; sourceIndex++) {
        _loop_1(sourceIndex);
      }

      return function () {
        buffers = completed = null;
      };
    }) : EMPTY;
  }

  function debounceTime(dueTime, scheduler) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }

    return operate(function (source, subscriber) {
      var activeTask = null;
      var lastValue = null;
      var lastTime = null;

      var emit = function () {
        if (activeTask) {
          activeTask.unsubscribe();
          activeTask = null;
          var value = lastValue;
          lastValue = null;
          subscriber.next(value);
        }
      };

      function emitWhenIdle() {
        var targetTime = lastTime + dueTime;
        var now = scheduler.now();

        if (now < targetTime) {
          activeTask = this.schedule(undefined, targetTime - now);
          subscriber.add(activeTask);
          return;
        }

        emit();
      }

      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        lastValue = value;
        lastTime = scheduler.now();

        if (!activeTask) {
          activeTask = scheduler.schedule(emitWhenIdle, dueTime);
          subscriber.add(activeTask);
        }
      }, function () {
        emit();
        subscriber.complete();
      }, undefined, function () {
        lastValue = activeTask = null;
      }));
    });
  }

  function take(count) {
    return count <= 0 ? function () {
      return EMPTY;
    } : operate(function (source, subscriber) {
      var seen = 0;
      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        if (++seen <= count) {
          subscriber.next(value);

          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }

  function ignoreElements() {
    return operate(function (source, subscriber) {
      source.subscribe(new OperatorSubscriber(subscriber, noop$1));
    });
  }

  function mapTo(value) {
    return map(function () {
      return value;
    });
  }

  function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) {
      keySelector = identity;
    }

    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return operate(function (source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        var currentKey = keySelector(value);

        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }

  function defaultCompare(a, b) {
    return a === b;
  }

  function pluck() {
    var properties = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      properties[_i] = arguments[_i];
    }

    var length = properties.length;

    if (length === 0) {
      throw new Error('list of properties cannot be empty.');
    }

    return map(function (x) {
      var currentProp = x;

      for (var i = 0; i < length; i++) {
        var p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];

        if (typeof p !== 'undefined') {
          currentProp = p;
        } else {
          return undefined;
        }
      }

      return currentProp;
    });
  }

  function share(options) {
    if (options === void 0) {
      options = {};
    }

    var _a = options.connector,
        connector = _a === void 0 ? function () {
      return new Subject();
    } : _a,
        _b = options.resetOnError,
        resetOnError = _b === void 0 ? true : _b,
        _c = options.resetOnComplete,
        resetOnComplete = _c === void 0 ? true : _c,
        _d = options.resetOnRefCountZero,
        resetOnRefCountZero = _d === void 0 ? true : _d;
    return function (wrapperSource) {
      var connection = null;
      var resetConnection = null;
      var subject = null;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;

      var cancelReset = function () {
        resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
        resetConnection = null;
      };

      var reset = function () {
        cancelReset();
        connection = subject = null;
        hasCompleted = hasErrored = false;
      };

      var resetAndUnsubscribe = function () {
        var conn = connection;
        reset();
        conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
      };

      return operate(function (source, subscriber) {
        refCount++;

        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }

        var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
        subscriber.add(function () {
          refCount--;

          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);

        if (!connection) {
          connection = new SafeSubscriber({
            next: function (value) {
              return dest.next(value);
            },
            error: function (err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function () {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          from$1(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }

  function handleReset(reset, on) {
    var args = [];

    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }

    if (on === true) {
      reset();
      return null;
    }

    if (on === false) {
      return null;
    }

    return on.apply(void 0, __spreadArray$1([], __read(args))).pipe(take(1)).subscribe(function () {
      return reset();
    });
  }

  function startWith() {
    var values = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }

    var scheduler = popScheduler(values);
    return operate(function (source, subscriber) {
      (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
    });
  }

  function switchMap(project, resultSelector) {
    return operate(function (source, subscriber) {
      var innerSubscriber = null;
      var index = 0;
      var isComplete = false;

      var checkComplete = function () {
        return isComplete && !innerSubscriber && subscriber.complete();
      };

      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();
        var innerIndex = 0;
        var outerIndex = index++;
        innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = new OperatorSubscriber(subscriber, function (innerValue) {
          return subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue);
        }, function () {
          innerSubscriber = null;
          checkComplete();
        }));
      }, function () {
        isComplete = true;
        checkComplete();
      }));
    });
  }

  function takeUntil(notifier) {
    return operate(function (source, subscriber) {
      innerFrom(notifier).subscribe(new OperatorSubscriber(subscriber, function () {
        return subscriber.complete();
      }, noop$1));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }

  function tap(observerOrNext, error, complete) {
    var tapObserver = isFunction(observerOrNext) || error || complete ? {
      next: observerOrNext,
      error: error,
      complete: complete
    } : observerOrNext;
    return tapObserver ? operate(function (source, subscriber) {
      var _a;

      (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
      var isUnsub = true;
      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        var _a;

        (_a = tapObserver.next) === null || _a === void 0 ? void 0 : _a.call(tapObserver, value);
        subscriber.next(value);
      }, function () {
        var _a;

        isUnsub = false;
        (_a = tapObserver.complete) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        subscriber.complete();
      }, function (err) {
        var _a;

        isUnsub = false;
        (_a = tapObserver.error) === null || _a === void 0 ? void 0 : _a.call(tapObserver, err);
        subscriber.error(err);
      }, function () {
        var _a, _b;

        if (isUnsub) {
          (_a = tapObserver.unsubscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);
        }

        (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);
      }));
    }) : identity;
  }

  var defaultThrottleConfig = {
    leading: true,
    trailing: false
  };
  function throttle(durationSelector, _a) {
    var _b = _a === void 0 ? defaultThrottleConfig : _a,
        leading = _b.leading,
        trailing = _b.trailing;

    return operate(function (source, subscriber) {
      var hasValue = false;
      var sendValue = null;
      var throttled = null;
      var isComplete = false;

      var endThrottling = function () {
        throttled === null || throttled === void 0 ? void 0 : throttled.unsubscribe();
        throttled = null;

        if (trailing) {
          send();
          isComplete && subscriber.complete();
        }
      };

      var cleanupThrottling = function () {
        throttled = null;
        isComplete && subscriber.complete();
      };

      var startThrottle = function (value) {
        return throttled = innerFrom(durationSelector(value)).subscribe(new OperatorSubscriber(subscriber, endThrottling, cleanupThrottling));
      };

      var send = function () {
        if (hasValue) {
          hasValue = false;
          var value = sendValue;
          sendValue = null;
          subscriber.next(value);
          !isComplete && startThrottle(value);
        }
      };

      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        hasValue = true;
        sendValue = value;
        !(throttled && !throttled.closed) && (leading ? send() : startThrottle(value));
      }, function () {
        isComplete = true;
        !(trailing && hasValue && throttled && !throttled.closed) && subscriber.complete();
      }));
    });
  }

  function throttleTime(duration, scheduler, config) {
    if (scheduler === void 0) {
      scheduler = asyncScheduler;
    }

    if (config === void 0) {
      config = defaultThrottleConfig;
    }

    var duration$ = timer(duration, scheduler);
    return throttle(function () {
      return duration$;
    }, config);
  }

  function withLatestFrom() {
    var inputs = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      inputs[_i] = arguments[_i];
    }

    var project = popResultSelector(inputs);
    return operate(function (source, subscriber) {
      var len = inputs.length;
      var otherValues = new Array(len);
      var hasValue = inputs.map(function () {
        return false;
      });
      var ready = false;

      var _loop_1 = function (i) {
        innerFrom(inputs[i]).subscribe(new OperatorSubscriber(subscriber, function (value) {
          otherValues[i] = value;

          if (!ready && !hasValue[i]) {
            hasValue[i] = true;
            (ready = hasValue.every(identity)) && (hasValue = null);
          }
        }, noop$1));
      };

      for (var i = 0; i < len; i++) {
        _loop_1(i);
      }

      source.subscribe(new OperatorSubscriber(subscriber, function (value) {
        if (ready) {
          var values = __spreadArray$1([value], __read(otherValues));

          subscriber.next(project ? project.apply(void 0, __spreadArray$1([], __read(values))) : values);
        }
      }));
    });
  }

  function removeLastPiece(str, splitChar = '.') {
    return (str = `${str}`).substr(0, str.lastIndexOf(splitChar));
  }
  function popPiece(str, splitChar = '.') {
    return String(str).split(splitChar).pop();
  }
  const isSimple = (str, separator = '.') => String(str).split(separator).length === 1;
  const isSymmetricCombination = (string1, string2, separator = '.') => String(string1).split(separator).length === String(string2).split(separator).length;

  var queryString$1 = {};

  var strictUriEncode = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);

  var token$1 = '%[a-f0-9]{2}';
  var singleMatcher = new RegExp(token$1, 'gi');
  var multiMatcher = new RegExp('(' + token$1 + ')+', 'gi');

  function decodeComponents(components, split) {
    try {
      // Try to decode the entire string first
      return decodeURIComponent(components.join(''));
    } catch (err) {// Do nothing
    }

    if (components.length === 1) {
      return components;
    }

    split = split || 1; // Split the array in 2 parts

    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
  }

  function decode(input) {
    try {
      return decodeURIComponent(input);
    } catch (err) {
      var tokens = input.match(singleMatcher);

      for (var i = 1; i < tokens.length; i++) {
        input = decodeComponents(tokens, i).join('');
        tokens = input.match(singleMatcher);
      }

      return input;
    }
  }

  function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
      '%FE%FF': '\uFFFD\uFFFD',
      '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);

    while (match) {
      try {
        // Decode as big chunks as possible
        replaceMap[match[0]] = decodeURIComponent(match[0]);
      } catch (err) {
        var result = decode(match[0]);

        if (result !== match[0]) {
          replaceMap[match[0]] = result;
        }
      }

      match = multiMatcher.exec(input);
    } // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else


    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);

    for (var i = 0; i < entries.length; i++) {
      // Replace all decoded components
      var key = entries[i];
      input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }

    return input;
  }

  var decodeUriComponent = function (encodedURI) {
    if (typeof encodedURI !== 'string') {
      throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }

    try {
      encodedURI = encodedURI.replace(/\+/g, ' '); // Try the built in decoder first

      return decodeURIComponent(encodedURI);
    } catch (err) {
      // Fallback to a more advanced decoder
      return customDecodeURIComponent(encodedURI);
    }
  };

  var splitOnFirst = (string, separator) => {
    if (!(typeof string === 'string' && typeof separator === 'string')) {
      throw new TypeError('Expected the arguments to be of type `string`');
    }

    if (separator === '') {
      return [string];
    }

    const separatorIndex = string.indexOf(separator);

    if (separatorIndex === -1) {
      return [string];
    }

    return [string.slice(0, separatorIndex), string.slice(separatorIndex + separator.length)];
  };

  var filterObj = function (obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var val = obj[key];

      if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
        ret[key] = val;
      }
    }

    return ret;
  };

  (function (exports) {

  const strictUriEncode$1 = strictUriEncode;

  const decodeComponent = decodeUriComponent;

  const splitOnFirst$1 = splitOnFirst;

  const filterObject = filterObj;

  const isNullOrUndefined = value => value === null || value === undefined;

  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case 'index':
        return key => (result, value) => {
          const index = result.length;

          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [...result, [encode(key, options), '[', index, ']'].join('')];
          }

          return [...result, [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')];
        };

      case 'bracket':
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [...result, [encode(key, options), '[]'].join('')];
          }

          return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
        };

      case 'comma':
      case 'separator':
        return key => (result, value) => {
          if (value === null || value === undefined || value.length === 0) {
            return result;
          }

          if (result.length === 0) {
            return [[encode(key, options), '=', encode(value, options)].join('')];
          }

          return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
        };

      default:
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [...result, encode(key, options)];
          }

          return [...result, [encode(key, options), '=', encode(value, options)].join('')];
        };
    }
  }

  function parserForArrayFormat(options) {
    let result;

    switch (options.arrayFormat) {
      case 'index':
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = {};
          }

          accumulator[key][result[1]] = value;
        };

      case 'bracket':
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };

      case 'comma':
      case 'separator':
        return (key, value, accumulator) => {
          const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode(value, options) : value;
          const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
          accumulator[key] = newValue;
        };

      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === undefined) {
            accumulator[key] = value;
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }

  function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
      throw new TypeError('arrayFormatSeparator must be single character string');
    }
  }

  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }

    return value;
  }

  function decode(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }

    return value;
  }

  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }

    if (typeof input === 'object') {
      return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map(key => input[key]);
    }

    return input;
  }

  function removeHash(input) {
    const hashStart = input.indexOf('#');

    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }

    return input;
  }

  function getHash(url) {
    let hash = '';
    const hashStart = url.indexOf('#');

    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }

    return hash;
  }

  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf('?');

    if (queryStart === -1) {
      return '';
    }

    return input.slice(queryStart + 1);
  }

  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
      value = value.toLowerCase() === 'true';
    }

    return value;
  }

  function parse(query, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ',',
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options); // Create an object with no prototype

    const ret = Object.create(null);

    if (typeof query !== 'string') {
      return ret;
    }

    query = query.trim().replace(/^[?#&]/, '');

    if (!query) {
      return ret;
    }

    for (const param of query.split('&')) {
      if (param === '') {
        continue;
      }

      let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '='); // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters

      value = value === undefined ? null : ['comma', 'separator'].includes(options.arrayFormat) ? value : decode(value, options);
      formatter(decode(key, options), value, ret);
    }

    for (const key of Object.keys(ret)) {
      const value = ret[key];

      if (typeof value === 'object' && value !== null) {
        for (const k of Object.keys(value)) {
          value[k] = parseValue(value[k], options);
        }
      } else {
        ret[key] = parseValue(value, options);
      }
    }

    if (options.sort === false) {
      return ret;
    }

    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
      const value = ret[key];

      if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
        // Sort object keys, not values
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }

      return result;
    }, Object.create(null));
  }

  exports.extract = extract;
  exports.parse = parse;

  exports.stringify = (object, options) => {
    if (!object) {
      return '';
    }

    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);

    const shouldFilter = key => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';

    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};

    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }

    const keys = Object.keys(objectCopy);

    if (options.sort !== false) {
      keys.sort(options.sort);
    }

    return keys.map(key => {
      const value = object[key];

      if (value === undefined) {
        return '';
      }

      if (value === null) {
        return encode(key, options);
      }

      if (Array.isArray(value)) {
        return value.reduce(formatter(key), []).join('&');
      }

      return encode(key, options) + '=' + encode(value, options);
    }).filter(x => x.length > 0).join('&');
  };

  exports.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash] = splitOnFirst$1(url, '#');
    return Object.assign({
      url: url_.split('?')[0] || '',
      query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
      fragmentIdentifier: decode(hash, options)
    } : {});
  };

  exports.stringifyUrl = (object, options) => {
    options = Object.assign({
      encode: true,
      strict: true
    }, options);
    const url = removeHash(object.url).split('?')[0] || '';
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, {
      sort: false
    });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString = exports.stringify(query, options);

    if (queryString) {
      queryString = `?${queryString}`;
    }

    let hash = getHash(object.url);

    if (object.fragmentIdentifier) {
      hash = `#${encode(object.fragmentIdentifier, options)}`;
    }

    return `${url}${queryString}${hash}`;
  };

  exports.pick = (input, filter, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true
    }, options);
    const {
      url,
      query,
      fragmentIdentifier
    } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options);
  };

  exports.exclude = (input, filter, options) => {
    const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input, exclusionFilter, options);
  };
  }(queryString$1));

  function pluckProps(source, ...props) {
    let omitNull = false;
    const object = {};

    if (!source) {
      return object;
    }

    if (typeof props[0] === 'boolean') {
      omitNull = true;
      props.shift();
    }

    props.forEach(_prop_ => {
      const prop = String(_prop_);
      const propName = prop.substr(prop.lastIndexOf('.') + 1);
      const value = retrieveProperty(source, prop);

      if (nnou(value) || !omitNull) {
        object[propName] = value;
      }
    });
    return object;
  }
  function reversePluckProps(source, ...props) {
    const object = {};

    if (!source) {
      return object;
    }

    for (let key in source) {
      if (!props.includes(key) && source.hasOwnProperty(key)) {
        object[key] = source[key];
      }
    }

    return object;
  }
  function createLookupTable(list, idProp = 'id') {
    const table = {};
    list.forEach(item => {
      table[retrieveProperty(item, idProp)] = item;
    });
    return table;
  }
  function retrieveProperty(object, prop) {
    return object == null ? null : !prop ? object : prop.split('.').reduce((value, prop) => value[prop], object);
  }
  function setProperty(object, prop, value) {
    if (object) {
      const props = prop.split('.');
      const propToSet = props.pop();
      let target = retrieveProperty(object, props.join('.'));

      if (!target) {
        setProperty(object, props.join('.'), {});
        target = retrieveProperty(object, props.join('.'));
      }

      target[propToSet] = value;
    }

    return object;
  }
  let UND;
  function nnou(object) {
    return object !== null && object !== UND;
  }
  const notNullOrUndefined = nnou;
  function nou(object) {
    return object === null || object === UND;
  }
  const nullOrUndefined = nou;

  function forEach(array, fn, emptyReturnValue) {
    if (emptyReturnValue != null && (array === null || array === void 0 ? void 0 : array.length) === 0) {
      return emptyReturnValue;
    }

    for (let i = 0, l = array.length; i < l; i++) {
      const result = fn(array[i], i, array);

      if (result !== 'continue') {
        if (result === 'break') {
          break;
        } else if (result !== undefined) {
          return result;
        }
      }
    }

    return emptyReturnValue;
  }
  function mergeArraysAlternatively(a, b) {
    return (a.length > b.length ? a : b).reduce((acc, cur, i) => a[i] && b[i] ? [...acc, a[i], b[i]] : [...acc, cur], []);
  }

  const systemPropList = ['id', 'path', 'contentTypeId', 'dateCreated', 'dateModified', 'label'];
  function prop(model, propName) {
    if (model == null) {
      return null;
    } else if (systemPropList.includes(propName)) {
      propName = `craftercms.${propName}`;
    }

    return retrieveProperty(model, propName);
  }
  function value(model, fieldId, newValue) {
    const cleanFieldId = fieldId.replace(/-/g, '__');

    if (cleanFieldId !== fieldId && retrieveProperty(model, cleanFieldId)) {
      fieldId = cleanFieldId;
    }

    if (nnou(newValue)) {
      setProperty(model, fieldId, newValue);
    }

    return retrieveProperty(model, fieldId);
  }
  function extractCollection(model, fieldId, index) {
    return extractCollectionPiece(model, fieldId, removeLastPiece(`${index}`));
  }
  function extractCollectionItem(model, fieldId, index) {
    const indexes = index === '' || nou(index) ? [] : `${index}`.split('.').map(i => parseInt(i));
    const fields = fieldId.split('.');

    if (indexes.length > fields.length) {
      throw new Error('[Model.extractCollectionItem] The number of indexes surpasses the number ' + `of nested properties on model id "${prop(model, 'id')}", field id "${fieldId}". ` + `Supplied index path was ${index}. `);
    }

    if (Math.abs(indexes.length - fields.length) > 1) {
      throw new Error('[extractCollectionItem] The number of indexes and number of nested props mismatch ' + `by more than 1 on "${prop(model, 'id')}", field id "${fieldId}". ` + `Supplied index path was ${index}. Number of nested props may be greater by no more than one ` + 'than the number of nested indexes.');
    }

    return extractCollectionPiece(model, fieldId, index);
  }
  function getContentTypeId(model) {
    var _a;

    return (_a = model === null || model === void 0 ? void 0 : model.craftercms) === null || _a === void 0 ? void 0 : _a.contentTypeId;
  }

  function extractCollectionPiece(model, fieldId, index) {
    const indexes = index === '' || nou(index) ? [] : `${index}`.split('.').map(i => parseInt(i, 10));

    if (indexes.length === 0) {
      return retrieveProperty(model, fieldId);
    }

    const fields = fieldId.split('.');
    let aux = model;

    if (indexes.length > fields.length) {
      throw new Error('[content/extractNode] Path not handled: indexes.length > fields.length. Indexes ' + `is ${indexes} and fields is ${fields}`);
    }

    indexes.forEach((index, i) => {
      var _a;

      const field = fields[i];
      aux = (_a = aux[field]) === null || _a === void 0 ? void 0 : _a[index];
    });

    if (nou(aux)) {
      return aux;
    }

    if (indexes.length === fields.length) {
      return aux;
    } else if (indexes.length < fields.length) {
      const field = fields[fields.length - 1];
      return aux[field];
    }
  }

  /*! js-cookie v3.0.1 | MIT */
  /* eslint-disable no-var */
  function assign (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        target[key] = source[key];
      }
    }
    return target
  }
  /* eslint-enable no-var */

  /* eslint-disable no-var */
  var defaultConverter = {
    read: function (value) {
      if (value[0] === '"') {
        value = value.slice(1, -1);
      }
      return value.replace(/(%[\dA-F]{2})+/gi, decodeURIComponent)
    },
    write: function (value) {
      return encodeURIComponent(value).replace(
        /%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,
        decodeURIComponent
      )
    }
  };
  /* eslint-enable no-var */

  /* eslint-disable no-var */

  function init (converter, defaultAttributes) {
    function set (key, value, attributes) {
      if (typeof document === 'undefined') {
        return
      }

      attributes = assign({}, defaultAttributes, attributes);

      if (typeof attributes.expires === 'number') {
        attributes.expires = new Date(Date.now() + attributes.expires * 864e5);
      }
      if (attributes.expires) {
        attributes.expires = attributes.expires.toUTCString();
      }

      key = encodeURIComponent(key)
        .replace(/%(2[346B]|5E|60|7C)/g, decodeURIComponent)
        .replace(/[()]/g, escape);

      var stringifiedAttributes = '';
      for (var attributeName in attributes) {
        if (!attributes[attributeName]) {
          continue
        }

        stringifiedAttributes += '; ' + attributeName;

        if (attributes[attributeName] === true) {
          continue
        }

        // Considers RFC 6265 section 5.2:
        // ...
        // 3.  If the remaining unparsed-attributes contains a %x3B (";")
        //     character:
        // Consume the characters of the unparsed-attributes up to,
        // not including, the first %x3B (";") character.
        // ...
        stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
      }

      return (document.cookie =
        key + '=' + converter.write(value, key) + stringifiedAttributes)
    }

    function get (key) {
      if (typeof document === 'undefined' || (arguments.length && !key)) {
        return
      }

      // To prevent the for loop in the first place assign an empty array
      // in case there are no cookies at all.
      var cookies = document.cookie ? document.cookie.split('; ') : [];
      var jar = {};
      for (var i = 0; i < cookies.length; i++) {
        var parts = cookies[i].split('=');
        var value = parts.slice(1).join('=');

        try {
          var foundKey = decodeURIComponent(parts[0]);
          jar[foundKey] = converter.read(value, foundKey);

          if (key === foundKey) {
            break
          }
        } catch (e) {}
      }

      return key ? jar[key] : jar
    }

    return Object.create(
      {
        set: set,
        get: get,
        remove: function (key, attributes) {
          set(
            key,
            '',
            assign({}, attributes, {
              expires: -1
            })
          );
        },
        withAttributes: function (attributes) {
          return init(this.converter, assign({}, this.attributes, attributes))
        },
        withConverter: function (converter) {
          return init(assign({}, this.converter, converter), this.attributes)
        }
      },
      {
        attributes: { value: Object.freeze(defaultAttributes) },
        converter: { value: Object.freeze(converter) }
      }
    )
  }

  var api = init(defaultConverter, { path: '/' });

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const message$ = typeof window === 'undefined' ? new Subject() : fromEvent(window, 'message').pipe(filter$1(e => {
    var _e$data;

    return Boolean((_e$data = e.data) === null || _e$data === void 0 ? void 0 : _e$data.type);
  }), map(e => e.data), share());
  const meta = {
    craftercms: true,
    source: 'guest'
  };

  const prepareAction = (type, payload) => typeof type === 'object' ? { ...type,
    meta
  } : {
    type,
    payload,
    meta
  };

  const post = typeof window === 'undefined' ? () => void 0 : (type, payload) => window.parent.postMessage(prepareAction(type, payload), '*');
  function fromTopic(type) {
    return message$.pipe(filter$1(e => e.type === type));
  }

  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  var getRandomValues$1;
  var rnds8$1 = new Uint8Array(16);
  function rng$2() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues$1) {
      // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
      // find the complete implementation of crypto (msCrypto) on IE11.
      getRandomValues$1 = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

      if (!getRandomValues$1) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }
    }

    return getRandomValues$1(rnds8$1);
  }

  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  function validate(uuid) {
    return typeof uuid === 'string' && REGEX.test(uuid);
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */

  var byteToHex$1 = [];

  for (var i$2 = 0; i$2 < 256; ++i$2) {
    byteToHex$1.push((i$2 + 0x100).toString(16).substr(1));
  }

  function stringify$1(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

    var uuid = (byteToHex$1[arr[offset + 0]] + byteToHex$1[arr[offset + 1]] + byteToHex$1[arr[offset + 2]] + byteToHex$1[arr[offset + 3]] + '-' + byteToHex$1[arr[offset + 4]] + byteToHex$1[arr[offset + 5]] + '-' + byteToHex$1[arr[offset + 6]] + byteToHex$1[arr[offset + 7]] + '-' + byteToHex$1[arr[offset + 8]] + byteToHex$1[arr[offset + 9]] + '-' + byteToHex$1[arr[offset + 10]] + byteToHex$1[arr[offset + 11]] + byteToHex$1[arr[offset + 12]] + byteToHex$1[arr[offset + 13]] + byteToHex$1[arr[offset + 14]] + byteToHex$1[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields

    if (!validate(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }

    return uuid;
  }

  function v4$2(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng$2)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }

      return buf;
    }

    return stringify$1(rnds);
  }

  function n$2(n) {
    for (var t = arguments.length, r = Array(t > 1 ? t - 1 : 0), e = 1; e < t; e++) r[e - 1] = arguments[e];

    throw Error("[Immer] minified error nr: " + n + (r.length ? " " + r.map(function (n) {
      return "'" + n + "'";
    }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
  }

  function t(n) {
    return !!n && !!n[Q];
  }

  function r$1(n) {
    return !!n && (function (n) {
      if (!n || "object" != typeof n) return !1;
      var t = Object.getPrototypeOf(n);
      if (null === t) return !0;
      var r = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
      return r === Object || "function" == typeof r && Function.toString.call(r) === Z;
    }(n) || Array.isArray(n) || !!n[L] || !!n.constructor[L] || s(n) || v$1(n));
  }

  function i$1(n, t, r) {
    void 0 === r && (r = !1), 0 === o(n) ? (r ? Object.keys : nn)(n).forEach(function (e) {
      r && "symbol" == typeof e || t(e, n[e], n);
    }) : n.forEach(function (r, e) {
      return t(e, r, n);
    });
  }

  function o(n) {
    var t = n[Q];
    return t ? t.i > 3 ? t.i - 4 : t.i : Array.isArray(n) ? 1 : s(n) ? 2 : v$1(n) ? 3 : 0;
  }

  function u$1(n, t) {
    return 2 === o(n) ? n.has(t) : Object.prototype.hasOwnProperty.call(n, t);
  }

  function a$1(n, t) {
    return 2 === o(n) ? n.get(t) : n[t];
  }

  function f$2(n, t, r) {
    var e = o(n);
    2 === e ? n.set(t, r) : 3 === e ? (n.delete(t), n.add(r)) : n[t] = r;
  }

  function c$1(n, t) {
    return n === t ? 0 !== n || 1 / n == 1 / t : n != n && t != t;
  }

  function s(n) {
    return X && n instanceof Map;
  }

  function v$1(n) {
    return q$2 && n instanceof Set;
  }

  function p$2(n) {
    return n.o || n.t;
  }

  function l$1(n) {
    if (Array.isArray(n)) return Array.prototype.slice.call(n);
    var t = tn(n);
    delete t[Q];

    for (var r = nn(t), e = 0; e < r.length; e++) {
      var i = r[e],
          o = t[i];
      !1 === o.writable && (o.writable = !0, o.configurable = !0), (o.get || o.set) && (t[i] = {
        configurable: !0,
        writable: !0,
        enumerable: o.enumerable,
        value: n[i]
      });
    }

    return Object.create(Object.getPrototypeOf(n), t);
  }

  function d$1(n, e) {
    return void 0 === e && (e = !1), y$1(n) || t(n) || !r$1(n) ? n : (o(n) > 1 && (n.set = n.add = n.clear = n.delete = h$2), Object.freeze(n), e && i$1(n, function (n, t) {
      return d$1(t, !0);
    }, !0), n);
  }

  function h$2() {
    n$2(2);
  }

  function y$1(n) {
    return null == n || "object" != typeof n || Object.isFrozen(n);
  }

  function b$1(t) {
    var r = rn[t];
    return r || n$2(18, t), r;
  }

  function m$2(n, t) {
    rn[n] || (rn[n] = t);
  }

  function _$1() {
    return U;
  }

  function j(n, t) {
    t && (b$1("Patches"), n.u = [], n.s = [], n.v = t);
  }

  function O(n) {
    g$2(n), n.p.forEach(S), n.p = null;
  }

  function g$2(n) {
    n === U && (U = n.l);
  }

  function w$1(n) {
    return U = {
      p: [],
      l: U,
      h: n,
      m: !0,
      _: 0
    };
  }

  function S(n) {
    var t = n[Q];
    0 === t.i || 1 === t.i ? t.j() : t.O = !0;
  }

  function P(t, e) {
    e._ = e.p.length;
    var i = e.p[0],
        o = void 0 !== t && t !== i;
    return e.h.g || b$1("ES5").S(e, t, o), o ? (i[Q].P && (O(e), n$2(4)), r$1(t) && (t = M(e, t), e.l || x$1(e, t)), e.u && b$1("Patches").M(i[Q], t, e.u, e.s)) : t = M(e, i, []), O(e), e.u && e.v(e.u, e.s), t !== H$1 ? t : void 0;
  }

  function M(n, t, r) {
    if (y$1(t)) return t;
    var e = t[Q];
    if (!e) return i$1(t, function (i, o) {
      return A$1(n, e, t, i, o, r);
    }, !0), t;
    if (e.A !== n) return t;
    if (!e.P) return x$1(n, e.t, !0), e.t;

    if (!e.I) {
      e.I = !0, e.A._--;
      var o = 4 === e.i || 5 === e.i ? e.o = l$1(e.k) : e.o;
      i$1(3 === e.i ? new Set(o) : o, function (t, i) {
        return A$1(n, e, o, t, i, r);
      }), x$1(n, o, !1), r && n.u && b$1("Patches").R(e, r, n.u, n.s);
    }

    return e.o;
  }

  function A$1(e, i, o, a, c, s) {
    if (t(c)) {
      var v = M(e, c, s && i && 3 !== i.i && !u$1(i.D, a) ? s.concat(a) : void 0);
      if (f$2(o, a, v), !t(v)) return;
      e.m = !1;
    }

    if (r$1(c) && !y$1(c)) {
      if (!e.h.F && e._ < 1) return;
      M(e, c), i && i.A.l || x$1(e, c);
    }
  }

  function x$1(n, t, r) {
    void 0 === r && (r = !1), n.h.F && n.m && d$1(t, r);
  }

  function z$1(n, t) {
    var r = n[Q];
    return (r ? p$2(r) : n)[t];
  }

  function I$1(n, t) {
    if (t in n) for (var r = Object.getPrototypeOf(n); r;) {
      var e = Object.getOwnPropertyDescriptor(r, t);
      if (e) return e;
      r = Object.getPrototypeOf(r);
    }
  }

  function k$2(n) {
    n.P || (n.P = !0, n.l && k$2(n.l));
  }

  function E$1(n) {
    n.o || (n.o = l$1(n.t));
  }

  function R(n, t, r) {
    var e = s(t) ? b$1("MapSet").N(t, r) : v$1(t) ? b$1("MapSet").T(t, r) : n.g ? function (n, t) {
      var r = Array.isArray(n),
          e = {
        i: r ? 1 : 0,
        A: t ? t.A : _$1(),
        P: !1,
        I: !1,
        D: {},
        l: t,
        t: n,
        k: null,
        o: null,
        j: null,
        C: !1
      },
          i = e,
          o = en;
      r && (i = [e], o = on);
      var u = Proxy.revocable(i, o),
          a = u.revoke,
          f = u.proxy;
      return e.k = f, e.j = a, f;
    }(t, r) : b$1("ES5").J(t, r);
    return (r ? r.A : _$1()).p.push(e), e;
  }

  function D$1(e) {
    return t(e) || n$2(22, e), function n(t) {
      if (!r$1(t)) return t;
      var e,
          u = t[Q],
          c = o(t);

      if (u) {
        if (!u.P && (u.i < 4 || !b$1("ES5").K(u))) return u.t;
        u.I = !0, e = F$1(t, c), u.I = !1;
      } else e = F$1(t, c);

      return i$1(e, function (t, r) {
        u && a$1(u.t, t) === r || f$2(e, t, n(r));
      }), 3 === c ? new Set(e) : e;
    }(e);
  }

  function F$1(n, t) {
    switch (t) {
      case 2:
        return new Map(n);

      case 3:
        return Array.from(n);
    }

    return l$1(n);
  }

  function N() {
    function r(n, t) {
      var r = s[n];
      return r ? r.enumerable = t : s[n] = r = {
        configurable: !0,
        enumerable: t,
        get: function () {
          var t = this[Q];
          return en.get(t, n);
        },
        set: function (t) {
          var r = this[Q];
          en.set(r, n, t);
        }
      }, r;
    }

    function e(n) {
      for (var t = n.length - 1; t >= 0; t--) {
        var r = n[t][Q];
        if (!r.P) switch (r.i) {
          case 5:
            a(r) && k$2(r);
            break;

          case 4:
            o(r) && k$2(r);
        }
      }
    }

    function o(n) {
      for (var t = n.t, r = n.k, e = nn(r), i = e.length - 1; i >= 0; i--) {
        var o = e[i];

        if (o !== Q) {
          var a = t[o];
          if (void 0 === a && !u$1(t, o)) return !0;
          var f = r[o],
              s = f && f[Q];
          if (s ? s.t !== a : !c$1(f, a)) return !0;
        }
      }

      var v = !!t[Q];
      return e.length !== nn(t).length + (v ? 0 : 1);
    }

    function a(n) {
      var t = n.k;
      if (t.length !== n.t.length) return !0;
      var r = Object.getOwnPropertyDescriptor(t, t.length - 1);
      return !(!r || r.get);
    }

    var s = {};
    m$2("ES5", {
      J: function (n, t) {
        var e = Array.isArray(n),
            i = function (n, t) {
          if (n) {
            for (var e = Array(t.length), i = 0; i < t.length; i++) Object.defineProperty(e, "" + i, r(i, !0));

            return e;
          }

          var o = tn(t);
          delete o[Q];

          for (var u = nn(o), a = 0; a < u.length; a++) {
            var f = u[a];
            o[f] = r(f, n || !!o[f].enumerable);
          }

          return Object.create(Object.getPrototypeOf(t), o);
        }(e, n),
            o = {
          i: e ? 5 : 4,
          A: t ? t.A : _$1(),
          P: !1,
          I: !1,
          D: {},
          l: t,
          t: n,
          k: i,
          o: null,
          O: !1,
          C: !1
        };

        return Object.defineProperty(i, Q, {
          value: o,
          writable: !0
        }), i;
      },
      S: function (n, r, o) {
        o ? t(r) && r[Q].A === n && e(n.p) : (n.u && function n(t) {
          if (t && "object" == typeof t) {
            var r = t[Q];

            if (r) {
              var e = r.t,
                  o = r.k,
                  f = r.D,
                  c = r.i;
              if (4 === c) i$1(o, function (t) {
                t !== Q && (void 0 !== e[t] || u$1(e, t) ? f[t] || n(o[t]) : (f[t] = !0, k$2(r)));
              }), i$1(e, function (n) {
                void 0 !== o[n] || u$1(o, n) || (f[n] = !1, k$2(r));
              });else if (5 === c) {
                if (a(r) && (k$2(r), f.length = !0), o.length < e.length) for (var s = o.length; s < e.length; s++) f[s] = !1;else for (var v = e.length; v < o.length; v++) f[v] = !0;

                for (var p = Math.min(o.length, e.length), l = 0; l < p; l++) void 0 === f[l] && n(o[l]);
              }
            }
          }
        }(n.p[0]), e(n.p));
      },
      K: function (n) {
        return 4 === n.i ? o(n) : a(n);
      }
    });
  }

  var G$1,
      U,
      W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"),
      X = "undefined" != typeof Map,
      q$2 = "undefined" != typeof Set,
      B$1 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect,
      H$1 = W ? Symbol.for("immer-nothing") : ((G$1 = {})["immer-nothing"] = !0, G$1),
      L = W ? Symbol.for("immer-draftable") : "__$immer_draftable",
      Q = W ? Symbol.for("immer-state") : "__$immer_state",
      Z = "" + Object.prototype.constructor,
      nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function (n) {
    return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n));
  } : Object.getOwnPropertyNames,
      tn = Object.getOwnPropertyDescriptors || function (n) {
    var t = {};
    return nn(n).forEach(function (r) {
      t[r] = Object.getOwnPropertyDescriptor(n, r);
    }), t;
  },
      rn = {},
      en = {
    get: function (n, t) {
      if (t === Q) return n;
      var e = p$2(n);
      if (!u$1(e, t)) return function (n, t, r) {
        var e,
            i = I$1(t, r);
        return i ? "value" in i ? i.value : null === (e = i.get) || void 0 === e ? void 0 : e.call(n.k) : void 0;
      }(n, e, t);
      var i = e[t];
      return n.I || !r$1(i) ? i : i === z$1(n.t, t) ? (E$1(n), n.o[t] = R(n.A.h, i, n)) : i;
    },
    has: function (n, t) {
      return t in p$2(n);
    },
    ownKeys: function (n) {
      return Reflect.ownKeys(p$2(n));
    },
    set: function (n, t, r) {
      var e = I$1(p$2(n), t);
      if (null == e ? void 0 : e.set) return e.set.call(n.k, r), !0;

      if (!n.P) {
        var i = z$1(p$2(n), t),
            o = null == i ? void 0 : i[Q];
        if (o && o.t === r) return n.o[t] = r, n.D[t] = !1, !0;
        if (c$1(r, i) && (void 0 !== r || u$1(n.t, t))) return !0;
        E$1(n), k$2(n);
      }

      return n.o[t] === r && "number" != typeof r && (void 0 !== r || t in n.o) || (n.o[t] = r, n.D[t] = !0, !0);
    },
    deleteProperty: function (n, t) {
      return void 0 !== z$1(n.t, t) || t in n.t ? (n.D[t] = !1, E$1(n), k$2(n)) : delete n.D[t], n.o && delete n.o[t], !0;
    },
    getOwnPropertyDescriptor: function (n, t) {
      var r = p$2(n),
          e = Reflect.getOwnPropertyDescriptor(r, t);
      return e ? {
        writable: !0,
        configurable: 1 !== n.i || "length" !== t,
        enumerable: e.enumerable,
        value: r[t]
      } : e;
    },
    defineProperty: function () {
      n$2(11);
    },
    getPrototypeOf: function (n) {
      return Object.getPrototypeOf(n.t);
    },
    setPrototypeOf: function () {
      n$2(12);
    }
  },
      on = {};

  i$1(en, function (n, t) {
    on[n] = function () {
      return arguments[0] = arguments[0][0], t.apply(this, arguments);
    };
  }), on.deleteProperty = function (t, r) {
    return en.deleteProperty.call(this, t[0], r);
  }, on.set = function (t, r, e) {
    return en.set.call(this, t[0], r, e, t[0]);
  };

  var un = function () {
    function e(t) {
      var e = this;
      this.g = B$1, this.F = !0, this.produce = function (t, i, o) {
        if ("function" == typeof t && "function" != typeof i) {
          var u = i;
          i = t;
          var a = e;
          return function (n) {
            var t = this;
            void 0 === n && (n = u);

            for (var r = arguments.length, e = Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) e[o - 1] = arguments[o];

            return a.produce(n, function (n) {
              var r;
              return (r = i).call.apply(r, [t, n].concat(e));
            });
          };
        }

        var f;

        if ("function" != typeof i && n$2(6), void 0 !== o && "function" != typeof o && n$2(7), r$1(t)) {
          var c = w$1(e),
              s = R(e, t, void 0),
              v = !0;

          try {
            f = i(s), v = !1;
          } finally {
            v ? O(c) : g$2(c);
          }

          return "undefined" != typeof Promise && f instanceof Promise ? f.then(function (n) {
            return j(c, o), P(n, c);
          }, function (n) {
            throw O(c), n;
          }) : (j(c, o), P(f, c));
        }

        if (!t || "object" != typeof t) {
          if ((f = i(t)) === H$1) return;
          return void 0 === f && (f = t), e.F && d$1(f, !0), f;
        }

        n$2(21, t);
      }, this.produceWithPatches = function (n, t) {
        return "function" == typeof n ? function (t) {
          for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++) i[o - 1] = arguments[o];

          return e.produceWithPatches(t, function (t) {
            return n.apply(void 0, [t].concat(i));
          });
        } : [e.produce(n, t, function (n, t) {
          r = n, i = t;
        }), r, i];
        var r, i;
      }, "boolean" == typeof (null == t ? void 0 : t.useProxies) && this.setUseProxies(t.useProxies), "boolean" == typeof (null == t ? void 0 : t.autoFreeze) && this.setAutoFreeze(t.autoFreeze);
    }

    var i = e.prototype;
    return i.createDraft = function (e) {
      r$1(e) || n$2(8), t(e) && (e = D$1(e));
      var i = w$1(this),
          o = R(this, e, void 0);
      return o[Q].C = !0, g$2(i), o;
    }, i.finishDraft = function (t, r) {
      var e = t && t[Q];
      var i = e.A;
      return j(i, r), P(void 0, i);
    }, i.setAutoFreeze = function (n) {
      this.F = n;
    }, i.setUseProxies = function (t) {
      t && !B$1 && n$2(20), this.g = t;
    }, i.applyPatches = function (n, r) {
      var e;

      for (e = r.length - 1; e >= 0; e--) {
        var i = r[e];

        if (0 === i.path.length && "replace" === i.op) {
          n = i.value;
          break;
        }
      }

      e > -1 && (r = r.slice(e + 1));
      var o = b$1("Patches").$;
      return t(n) ? o(n, r) : this.produce(n, function (n) {
        return o(n, r);
      });
    }, e;
  }(),
      an = new un();
      an.produce;
      an.produceWithPatches.bind(an);
      an.setAutoFreeze.bind(an);
      an.setUseProxies.bind(an);
      an.applyPatches.bind(an);
      an.createDraft.bind(an);
      an.finishDraft.bind(an);

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);

      if (enumerableOnly) {
        symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }

      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  /**
   * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
   *
   * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
   * during build.
   * @param {number} code
   */

  function formatProdErrorMessage(code) {
    return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
  } // Inlined version of the `symbol-observable` polyfill


  var $$observable = function () {
    return typeof Symbol === 'function' && Symbol.observable || '@@observable';
  }();
  /**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */


  var randomString = function randomString() {
    return Math.random().toString(36).substring(7).split('').join('.');
  };

  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };
  /**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */

  function isPlainObject$3(obj) {
    if (typeof obj !== 'object' || obj === null) return false;
    var proto = obj;

    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(obj) === proto;
  } // Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */


  function createStore(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
      throw new Error(formatProdErrorMessage(0) );
    }

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error(formatProdErrorMessage(1) );
      }

      return enhancer(createStore)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error(formatProdErrorMessage(2) );
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    /**
     * This makes a shallow copy of currentListeners so we can use
     * nextListeners as a temporary list while dispatching.
     *
     * This prevents any bugs around consumers calling
     * subscribe/unsubscribe in the middle of a dispatch.
     */

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */


    function getState() {
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(3) );
      }

      return currentState;
    }
    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */


    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error(formatProdErrorMessage(4) );
      }

      if (isDispatching) {
        throw new Error(formatProdErrorMessage(5) );
      }

      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        if (isDispatching) {
          throw new Error(formatProdErrorMessage(6) );
        }

        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
        currentListeners = null;
      };
    }
    /**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing “what changed”. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */


    function dispatch(action) {
      if (!isPlainObject$3(action)) {
        throw new Error(formatProdErrorMessage(7) );
      }

      if (typeof action.type === 'undefined') {
        throw new Error(formatProdErrorMessage(8) );
      }

      if (isDispatching) {
        throw new Error(formatProdErrorMessage(9) );
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;

      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }
    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */


    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error(formatProdErrorMessage(10) );
      }

      currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
      // Any reducers that existed in both the new and old rootReducer
      // will receive the previous state. This effectively populates
      // the new state tree with any relevant data from the old one.

      dispatch({
        type: ActionTypes.REPLACE
      });
    }
    /**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */


    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe(observer) {
          if (typeof observer !== 'object' || observer === null) {
            throw new Error(formatProdErrorMessage(11) );
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe: unsubscribe
          };
        }
      }, _ref[$$observable] = function () {
        return this;
      }, _ref;
    } // When a store is created, an "INIT" action is dispatched so that every
    // reducer returns their initial state. This effectively populates
    // the initial state tree.


    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[$$observable] = observable, _ref2;
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, {
        type: ActionTypes.INIT
      });

      if (typeof initialState === 'undefined') {
        throw new Error(formatProdErrorMessage(12) );
      }

      if (typeof reducer(undefined, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === 'undefined') {
        throw new Error(formatProdErrorMessage(13) );
      }
    });
  }
  /**
   * Turns an object whose values are different reducer functions, into a single
   * reducer function. It will call every child reducer, and gather their results
   * into a single state object, whose keys correspond to the keys of the passed
   * reducer functions.
   *
   * @param {Object} reducers An object whose values correspond to different
   * reducer functions that need to be combined into one. One handy way to obtain
   * it is to use ES6 `import * as reducers` syntax. The reducers may never return
   * undefined for any action. Instead, they should return their initial state
   * if the state passed to them was undefined, and the current state for any
   * unrecognized action.
   *
   * @returns {Function} A reducer function that invokes every reducer inside the
   * passed object, and builds a state object with the same shape.
   */


  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};

    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }

    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same

    var shapeAssertionError;

    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination(state, action) {
      if (state === void 0) {
        state = {};
      }

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      var hasChanged = false;
      var nextState = {};

      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);

        if (typeof nextStateForKey === 'undefined') {
          action && action.type;
          throw new Error(formatProdErrorMessage(14) );
        }

        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }

      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }
  /**
   * Composes single-argument functions from right to left. The rightmost
   * function can take multiple arguments as it provides the signature for
   * the resulting composite function.
   *
   * @param {...Function} funcs The functions to compose.
   * @returns {Function} A function obtained by composing the argument functions
   * from right to left. For example, compose(f, g, h) is identical to doing
   * (...args) => f(g(h(...args))).
   */


  function compose$1() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }

    if (funcs.length === 1) {
      return funcs[0];
    }

    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(void 0, arguments));
      };
    });
  }
  /**
   * Creates a store enhancer that applies middleware to the dispatch method
   * of the Redux store. This is handy for a variety of tasks, such as expressing
   * asynchronous actions in a concise manner, or logging every action payload.
   *
   * See `redux-thunk` package as an example of the Redux middleware.
   *
   * Because middleware is potentially asynchronous, this should be the first
   * store enhancer in the composition chain.
   *
   * Note that each middleware will be given the `dispatch` and `getState` functions
   * as named arguments.
   *
   * @param {...Function} middlewares The middleware chain to be applied.
   * @returns {Function} A store enhancer applying the middleware.
   */


  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    return function (createStore) {
      return function () {
        var store = createStore.apply(void 0, arguments);

        var _dispatch = function dispatch() {
          throw new Error(formatProdErrorMessage(15) );
        };

        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch() {
            return _dispatch.apply(void 0, arguments);
          }
        };
        var chain = middlewares.map(function (middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose$1.apply(void 0, chain)(store.dispatch);
        return _objectSpread2(_objectSpread2({}, store), {}, {
          dispatch: _dispatch
        });
      };
    };
  }

  /** A function that accepts a potential "extra argument" value to be injected later,
   * and returns an instance of the thunk middleware that uses that value
   */
  function createThunkMiddleware(extraArgument) {
    // Standard Redux middleware definition pattern:
    // See: https://redux.js.org/tutorials/fundamentals/part-4-store#writing-custom-middleware
    var middleware = function middleware(_ref) {
      var dispatch = _ref.dispatch,
          getState = _ref.getState;
      return function (next) {
        return function (action) {
          // The thunk middleware looks for any functions that were passed to `store.dispatch`.
          // If this "action" is really a function, call it and return the result.
          if (typeof action === 'function') {
            // Inject the store's `dispatch` and `getState` methods, as well as any "extra arg"
            return action(dispatch, getState, extraArgument);
          } // Otherwise, pass the action down the middleware chain as usual


          return next(action);
        };
      };
    };

    return middleware;
  }

  var thunk = createThunkMiddleware(); // Attach the factory function so users can create a customized version
  // with whatever "extra arg" they want to inject into their thunks

  thunk.withExtraArgument = createThunkMiddleware;
  var thunkMiddleware = thunk;

  var __extends$2 = this && this.__extends || function () {
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    return function (d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();

  this && this.__generator || function (thisArg, body) {
    var _ = {
      label: 0,
      sent: function () {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
        if (y = 0, t) op = [op[0] & 2, t.value];

        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;

          case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;

          case 7:
            op = _.ops.pop();

            _.trys.pop();

            continue;

          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }

            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }

            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }

            if (t && _.label < t[2]) {
              _.label = t[2];

              _.ops.push(op);

              break;
            }

            if (t[2]) _.ops.pop();

            _.trys.pop();

            continue;
        }

        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  };

  var __spreadArray = this && this.__spreadArray || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

    return to;
  };

  var __defProp = Object.defineProperty;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;

  var __defNormalProp = function (obj, key, value) {
    return key in obj ? __defProp(obj, key, {
      enumerable: true,
      configurable: true,
      writable: true,
      value: value
    }) : obj[key] = value;
  };

  var __spreadValues = function (a, b) {
    for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);

    if (__getOwnPropSymbols) for (var _i = 0, _c = __getOwnPropSymbols(b); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);
    }
    return a;
  };
  var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function () {
    if (arguments.length === 0) return void 0;
    if (typeof arguments[0] === "object") return compose$1;
    return compose$1.apply(null, arguments);
  };

  function isPlainObject$2(value) {
    if (typeof value !== "object" || value === null) return false;
    var proto = Object.getPrototypeOf(value);
    if (proto === null) return true;
    var baseProto = proto;

    while (Object.getPrototypeOf(baseProto) !== null) {
      baseProto = Object.getPrototypeOf(baseProto);
    }

    return proto === baseProto;
  } // src/getDefaultMiddleware.ts

  var MiddlewareArray =
  /** @class */
  function (_super) {
    __extends$2(MiddlewareArray, _super);

    function MiddlewareArray() {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      var _this = _super.apply(this, args) || this;

      Object.setPrototypeOf(_this, MiddlewareArray.prototype);
      return _this;
    }

    Object.defineProperty(MiddlewareArray, Symbol.species, {
      get: function () {
        return MiddlewareArray;
      },
      enumerable: false,
      configurable: true
    });

    MiddlewareArray.prototype.concat = function () {
      var arr = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }

      return _super.prototype.concat.apply(this, arr);
    };

    MiddlewareArray.prototype.prepend = function () {
      var arr = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }

      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr[0].concat(this))))();
      }

      return new (MiddlewareArray.bind.apply(MiddlewareArray, __spreadArray([void 0], arr.concat(this))))();
    };

    return MiddlewareArray;
  }(Array); // src/immutableStateInvariantMiddleware.ts


  function isBoolean(x) {
    return typeof x === "boolean";
  }

  function curryGetDefaultMiddleware() {
    return function curriedGetDefaultMiddleware(options) {
      return getDefaultMiddleware(options);
    };
  }

  function getDefaultMiddleware(options) {
    if (options === void 0) {
      options = {};
    }

    var _c = options.thunk,
        thunk = _c === void 0 ? true : _c;
        options.immutableCheck;
        options.serializableCheck;
    var middlewareArray = new MiddlewareArray();

    if (thunk) {
      if (isBoolean(thunk)) {
        middlewareArray.push(thunkMiddleware);
      } else {
        middlewareArray.push(thunkMiddleware.withExtraArgument(thunk.extraArgument));
      }
    }

    return middlewareArray;
  } // src/configureStore.ts


  var IS_PRODUCTION = "production" === "production";

  function configureStore(options) {
    var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();

    var _c = options || {},
        _d = _c.reducer,
        reducer = _d === void 0 ? void 0 : _d,
        _e = _c.middleware,
        middleware = _e === void 0 ? curriedGetDefaultMiddleware() : _e,
        _f = _c.devTools,
        devTools = _f === void 0 ? true : _f,
        _g = _c.preloadedState,
        preloadedState = _g === void 0 ? void 0 : _g,
        _h = _c.enhancers,
        enhancers = _h === void 0 ? void 0 : _h;

    var rootReducer;

    if (typeof reducer === "function") {
      rootReducer = reducer;
    } else if (isPlainObject$2(reducer)) {
      rootReducer = combineReducers(reducer);
    } else {
      throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
    }

    var finalMiddleware = middleware;

    if (typeof finalMiddleware === "function") {
      finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
    }

    var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
    var finalCompose = compose$1;

    if (devTools) {
      finalCompose = composeWithDevTools(__spreadValues({
        trace: !IS_PRODUCTION
      }, typeof devTools === "object" && devTools));
    }

    var storeEnhancers = [middlewareEnhancer];

    if (Array.isArray(enhancers)) {
      storeEnhancers = __spreadArray([middlewareEnhancer], enhancers);
    } else if (typeof enhancers === "function") {
      storeEnhancers = enhancers(storeEnhancers);
    }

    var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
    return createStore(rootReducer, preloadedState, composedEnhancer);
  } // src/createAction.ts


  function createAction(type, prepareAction) {
    function actionCreator() {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      if (prepareAction) {
        var prepared = prepareAction.apply(void 0, args);

        if (!prepared) {
          throw new Error("prepareAction did not return an object");
        }

        return __spreadValues(__spreadValues({
          type: type,
          payload: prepared.payload
        }, "meta" in prepared && {
          meta: prepared.meta
        }), "error" in prepared && {
          error: prepared.error
        });
      }

      return {
        type: type,
        payload: args[0]
      };
    }

    actionCreator.toString = function () {
      return "" + type;
    };

    actionCreator.type = type;

    actionCreator.match = function (action) {
      return action.type === type;
    };

    return actionCreator;
  }


  N();

  const hostCheckIn = createAction('HOST_CHECK_IN');
  const guestCheckIn = createAction('GUEST_CHECK_IN');
  const guestCheckOut = createAction('GUEST_CHECK_OUT');
  createAction('FETCH_GUEST_MODEL');
  createAction('GUEST_SITE_LOAD');
  const sortItemOperation = createAction('SORT_ITEM_OPERATION');
  createAction('SORT_ITEM_OPERATION_COMPLETE');
  createAction('SORT_ITEM_OPERATION_FAILED');
  const insertComponentOperation = createAction('INSERT_COMPONENT_OPERATION');
  const insertInstanceOperation = createAction('INSERT_INSTANCE_OPERATION');
  const insertOperationComplete = createAction('INSERT_COMPONENT_OPERATION_COMPLETE');
  createAction('INSERT_COMPONENT_OPERATION_FAILED');
  const insertItemOperation = createAction('INSERT_ITEM_OPERATION');
  const insertItemOperationComplete = createAction('INSERT_ITEM_OPERATION_COMPLETE');
  createAction('INSERT_ITEM_OPERATION_FAILED');
  const duplicateItemOperation = createAction('DUPLICATE_ITEM_OPERATION');
  const duplicateItemOperationComplete = createAction('DUPLICATE_ITEM_OPERATION_COMPLETE');
  createAction('DUPLICATE_ITEM_OPERATION_FAILED');
  const moveItemOperation = createAction('MOVE_ITEM_OPERATION');
  createAction('MOVE_ITEM_OPERATION_COMPLETE');
  createAction('MOVE_ITEM_OPERATION_FAILED');
  const deleteItemOperation = createAction('DELETE_ITEM_OPERATION');
  createAction('DELETE_ITEM_OPERATION_COMPLETE');
  createAction('DELETE_ITEM_OPERATION_FAILED');
  const updateFieldValueOperation = createAction('UPDATE_FIELD_VALUE_OPERATION');
  createAction('UPDATE_FIELD_VALUE_OPERATION_COMPLETE');
  createAction('UPDATE_FIELD_VALUE_OPERATION_FAILED');
  createAction('ICE_ZONE_SELECTED');
  const clearSelectedZones = createAction('CLEAR_SELECTED_ZONES');
  const assetDragStarted = createAction('ASSET_DRAG_STARTED');
  const assetDragEnded = createAction('ASSET_DRAG_ENDED');
  const componentDragStarted = createAction('COMPONENT_DRAG_STARTED');
  const componentDragEnded = createAction('COMPONENT_DRAG_ENDED');
  const trashed = createAction('TRASHED');
  const contentTypesResponse = createAction('CONTENT_TYPES_RESPONSE');
  const instanceDragBegun = createAction('INSTANCE_DRAG_BEGUN');
  const instanceDragEnded = createAction('INSTANCE_DRAG_ENDED');
  const navigationRequest = createAction('NAVIGATION_REQUEST');
  const reloadRequest = createAction('RELOAD_REQUEST');
  const desktopAssetDrop = createAction('DESKTOP_ASSET_DROP');
  const desktopAssetUploadComplete = createAction('DESKTOP_ASSET_UPLOAD_COMPLETE');
  const desktopAssetUploadProgress = createAction('DESKTOP_ASSET_UPLOAD_PROGRESS');
  const desktopAssetUploadStarted = createAction('DESKTOP_ASSET_UPLOAD_STARTED');
  const componentInstanceDragStarted = createAction('COMPONENT_INSTANCE_DRAG_STARTED');
  const componentInstanceDragEnded = createAction('COMPONENT_INSTANCE_DRAG_ENDED');
  const contentTypeDropTargetsRequest = createAction('CONTENT_TYPE_DROP_TARGETS_REQUEST');
  const contentTypeDropTargetsResponse = createAction('CONTENT_TYPE_DROP_TARGETS_RESPONSE');
  const scrollToDropTarget = createAction('SCROLL_TO_DROP_TARGET');
  const clearHighlightedDropTargets = createAction('CLEAR_HIGHLIGHTED_DROP_TARGETS');
  const contentTreeFieldSelected = createAction('CONTENT_TREE_FIELD_SELECTED');
  const clearContentTreeFieldSelected = createAction('CLEAR_CONTENT_TREE_FIELD_SELECTED');
  const validationMessage = createAction('VALIDATION_MESSAGE');
  createAction('EDIT_MODE_TOGGLE_HOTKEY');
  const hotKey = createAction('HOT_KEY');
  const showEditDialog = createAction('SHOW_EDIT_DIALOG');
  const updateRteConfig = createAction('UPDATE_RTE_CONFIG');
  const highlightModeChanged = createAction('HIGHLIGHT_MODE_CHANGED');
  createAction('CONTENT_TYPES_REQUEST');
  createAction('GUEST_MODELS_RECEIVED');
  createAction('CHILDREN_MAP_UPDATE');
  const contentTreeSwitchFieldInstance = createAction('CONTENT_TREE_SWITCH_FIELD_INSTANCE');
  const setEditModePadding = createAction('SET_DRAG_HELP_MODE');
  createAction('TOGGLE_DRAG_HELP_MODE');
  const OPEN_TOOLS = 'OPEN_TOOLS';
  const CLOSE_TOOLS = 'CLOSE_TOOLS';
  const FETCH_CONTENT_TYPES = 'FETCH_CONTENT_TYPES';
  const CHANGE_CURRENT_URL = 'CHANGE_CURRENT_URL';
  const FETCH_ASSETS_PANEL_ITEMS = 'FETCH_ASSETS_PANEL_ITEMS';
  const FETCH_ASSETS_PANEL_ITEMS_COMPLETE = 'FETCH_ASSETS_PANEL_ITEMS_COMPLETE';
  const FETCH_ASSETS_PANEL_ITEMS_FAILED = 'FETCH_ASSETS_PANEL_ITEMS_FAILED';
  const CLEAR_DROP_TARGETS = 'CLEAR_DROP_TARGETS';
  const SET_CONTENT_TYPE_FILTER = 'SET_CONTENT_TYPE_FILTER';
  createAction(OPEN_TOOLS);
  createAction(CLOSE_TOOLS);
  createAction(FETCH_CONTENT_TYPES);
  createAction('FETCH_PRIMARY_GUEST_MODEL_COMPLETE');
  createAction('FETCH_GUEST_MODELS_COMPLETE');
  createAction('GUEST_MODEL_UPDATED');
  createAction('GUEST_PATH_UPDATED');
  createAction(CHANGE_CURRENT_URL);
  createAction('FETCH_AUDIENCES_PANEL_MODEL');
  createAction('FETCH_AUDIENCES_PANEL_MODEL_COMPLETE');
  createAction('FETCH_AUDIENCES_PANEL_MODEL_FAILED');
  createAction(FETCH_ASSETS_PANEL_ITEMS);
  createAction(FETCH_ASSETS_PANEL_ITEMS_COMPLETE);
  createAction(FETCH_ASSETS_PANEL_ITEMS_FAILED);
  createAction('FETCH_COMPONENTS_BY_CONTENT_TYPE');
  createAction('FETCH_COMPONENTS_BY_CONTENT_TYPE_COMPLETE');
  createAction('FETCH_COMPONENTS_BY_CONTENT_TYPE_FAILED');
  createAction(CLEAR_DROP_TARGETS);
  createAction(contentTypeDropTargetsResponse.type);
  createAction(SET_CONTENT_TYPE_FILTER);
  createAction('UPDATE_TOOLS_PANEL_WIDTH');
  const setPreviewEditMode = createAction('EDIT_MODE_CHANGED');
  createAction('PREVIEW_ITEM');
  createAction('UPDATE_ICE_PANEL_WIDTH');
  createAction('INIT_TOOLS_PANEL_CONFIG');
  createAction('INIT_TOOLBAR_CONFIG');
  createAction('INIT_ICE_PANEL_CONFIG');
  createAction('INIT_RICH_TEXT_EDITOR_CONFIG');
  createAction('ASSOCIATE_TEMPLATE');
  createAction('ASSOCIATE_TEMPLATE_COMPLETE');
  createAction('ASSOCIATE_TEMPLATE_FAILED');
  createAction('DISSOCIATE_TEMPLATE');
  createAction('DISSOCIATE_TEMPLATE_COMPLETE');
  createAction('DISSOCIATE_TEMPLATE_FAILED');
  const requestEdit = createAction('REQUEST_EDIT');
  createAction('PUSH_TOOLS_PANEL_PAGE');
  createAction('POP_TOOLS_PANEL_PAGE');
  createAction('PUSH_ICE_PANEL_PAGE');
  createAction('POP_ICE_PANEL_PAGE');
  createAction('HIGHLIGHT_MODE_CHANGED');
  createAction('GO_TO_LAST_PAGE');
  createAction('GO_TO_NEXT_PAGE');

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function findComponentContainerFields(fields) {
    if (!Array.isArray(fields)) {
      fields = Object.values(fields);
    }

    return fields.filter(field => {
      if (field.type === 'node-selector') {
        return true;
      } else if (field.type === 'repeat') {
        // TODO Should repeats be considered containers?
        return false;
      } else {
        return false;
      }
    });
  }
  function getParentModelId(modelId, models, children) {
    return nullOrUndefined(prop(models[modelId], 'path')) ? findParentModelId(modelId, children, models) : null;
  }

  function findParentModelId(modelId, hierarchyDescriptorLookup, models) {
    const parentId = forEach(Object.entries(hierarchyDescriptorLookup), ([id, children]) => {
      if (notNullOrUndefined(children) && id !== modelId && children.children.includes(modelId)) {
        return id;
      }
    }, null);
    return notNullOrUndefined(parentId) ? // If it has a path, it is not embedded and hence the parent
    // Otherwise, need to keep looking.
    notNullOrUndefined(prop(models[parentId], 'path')) ? parentId : findParentModelId(parentId, hierarchyDescriptorLookup, models) : // No parent found for this model
    null;
  }

  function getCollectionWithoutItemAtIndex(collection, index) {
    const parsedIndex = parseInt(popPiece(`${index}`), 10);
    return collection.slice(0, parsedIndex).concat(collection.slice(parsedIndex + 1));
  }
  function getCollection(model, fieldId, index) {
    const isStringIndex = typeof index === 'string';
    return isStringIndex ? extractCollection(model, fieldId, index) : value(model, fieldId);
  }
  function setCollection(model, fieldId, index, collection) {
    if (!isSimple(fieldId)) {
      const concatFieldId = mergeArraysAlternatively(fieldId.split('.'), index.toString().split('.')).join('.');
      const fieldNames = concatFieldId.split('.');
      const {
        length
      } = fieldNames;
      const _model = { ...model
      };
      fieldNames.reduce((acc, _fieldId, i) => {
        if (i === length - 1) {
          acc[_fieldId] = collection;
        }

        return acc[_fieldId] = Array.isArray(acc[_fieldId]) ? [...acc[_fieldId]] : { ...acc[_fieldId]
        };
      }, _model);
      return _model;
    } else {
      return { ...model,
        [fieldId]: collection
      };
    }
  }
  function determineRecordType(entities) {
    let recordType;

    if (nou(entities.fieldId)) {
      // It's a model
      recordType = entities.contentType.type;
    } else if (nou(entities.index)) {
      // It's a ${entities.field.type} field
      recordType = 'field';
    } else {
      if (isSimple(entities.fieldId) || // By this point, it's been determined that it is a compound field
      isSymmetricCombination(entities.fieldId, entities.index)) {
        // It's an item of a ${entities.field.type}
        recordType = entities.field.type === 'node-selector' ? 'node-selector-item' : 'repeat-item';
      } else {
        // It's a ${entities.field.type} field of a repeat group item
        recordType = 'field';
      }
    }

    return recordType;
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  // TODO add return types

  /**
   * Query Object
   */
  var Query =
  /** @class */
  function () {
    /**
     * Creates an empty query
     * @constructor
     */
    function Query(params) {
      if (params === void 0) {
        params = {};
      }

      this.params = params;
    }
    /**
     * Sets a single value parameter in the query object
     * @param {string} name - Name of the parameter
     * @param {object} value - Value of the parameter
     */


    Query.prototype.setParam = function (name, value) {
      this.params[name] = value;
    };
    /**
     * Adds a value for a parameter in the query object
     * @param {string} name - Name of the parameter
     * @param {object} value - Value of the parameter
     */


    Query.prototype.addParam = function (name, value) {
      if (this.params[name]) {
        if (Array.isArray(this.params[name])) {
          this.params[name].push(value);
        } else {
          this.params[name] = [this.params[name], value];
        }
      } else {
        this.params[name] = value;
      }
    };

    return Query;
  }();

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var extendStatics$1 = function (d, b) {
    extendStatics$1 = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics$1(d, b);
  };

  function __extends$1(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics$1(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function () {
    __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };

    return __assign.apply(this, arguments);
  };

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  /**
   * Query implementation for Elasticsearch
   */

  var ElasticQuery =
  /** @class */
  function (_super) {
    __extends$1(ElasticQuery, _super);

    function ElasticQuery() {
      return _super !== null && _super.apply(this, arguments) || this;
    }

    Object.defineProperty(ElasticQuery.prototype, "query", {
      /**
       * Sets the actual query.
       * @param {string} query - Query string
       */
      set: function (query) {
        this.params = query;
      },
      enumerable: false,
      configurable: true
    });
    return ElasticQuery;
  }(Query);

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  function composeUrl(crafterConfigOrBaseUrl, endpoint) {
    var base = typeof crafterConfigOrBaseUrl === 'string' ? crafterConfigOrBaseUrl : crafterConfigOrBaseUrl.baseUrl ? crafterConfigOrBaseUrl.baseUrl + "/" : '';
    return ("" + base + endpoint).replace(/([^:]\/)\/+/g, "$1");
  }
  function isPlainObject$1(obj) {
    return typeof obj === 'object' && obj !== null && obj.constructor == Object;
  }
  function extendDeep(target, source) {
    for (var prop in source) {
      if (source.hasOwnProperty(prop)) {
        if (prop in target && isPlainObject$1(target[prop]) && isPlainObject$1(source[prop])) {
          extendDeep(target[prop], source[prop]);
        } else {
          target[prop] = source[prop];
        }
      }
    }

    return target;
  }
  function extendDeepExistingProps(target, source) {
    for (var prop in source) {
      if (prop in target && source.hasOwnProperty(prop)) {
        if (isPlainObject$1(target[prop]) && isPlainObject$1(source[prop])) {
          extendDeep(target[prop], source[prop]);
        } else {
          target[prop] = source[prop];
        }
      }
    }

    return target;
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  function log(message, type) {
    if (type === void 0) {
      type = log.DEFAULT;
    }

    console && (console[type] && !console[type](message) || console.log && console.log(message));
  }

  (function (log) {
    log.DEFAULT = 'log';
    log.ERROR = 'error';
    log.WARN = 'warn';
  })(log || (log = {}));

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  var MessageScope;

  (function (MessageScope) {
    MessageScope["ALL"] = "ALL";
    MessageScope["Local"] = "LOCAL";
    MessageScope["External"] = "EXTERNAL";
    MessageScope["Broadcast"] = "BROADCAST";
  })(MessageScope || (MessageScope = {}));

  var MessageTopic;

  (function (MessageTopic) {
    MessageTopic["ALL"] = "ALL";
    MessageTopic["GUEST_CHECK_IN"] = "GUEST_CHECK_IN";
    MessageTopic["GUEST_LOAD_EVENT"] = "GUEST_LOAD_EVENT";
    MessageTopic["HOST_ICE_START_REQUEST"] = "HOST_ICE_START_REQUEST";
    MessageTopic["HOST_END_ICE_REQUEST"] = "HOST_END_ICE_REQUEST";
    MessageTopic["HOST_RELOAD_REQUEST"] = "HOST_RELOAD_REQUEST";
    MessageTopic["HOST_NAV_REQUEST"] = "HOST_NAV_REQUEST";
    MessageTopic["NAV_REQUEST"] = "NAV_REQUEST";
    MessageTopic["PROJECT_CREATED"] = "PROJECT_CREATED";
    MessageTopic["PROJECT_UPDATED"] = "PROJECT_UPDATED";
    MessageTopic["PROJECT_DELETED"] = "PROJECT_DELETED";
  })(MessageTopic || (MessageTopic = {}));

  function fromFetch(input, initWithSelector) {
    if (initWithSelector === void 0) {
      initWithSelector = {};
    }

    var selector = initWithSelector.selector,
        init = __rest(initWithSelector, ["selector"]);

    return new Observable(function (subscriber) {
      var controller = new AbortController();
      var signal = controller.signal;
      var abortable = true;
      var outerSignal = init.signal;

      if (outerSignal) {
        if (outerSignal.aborted) {
          controller.abort();
        } else {
          var outerSignalHandler_1 = function () {
            if (!signal.aborted) {
              controller.abort();
            }
          };

          outerSignal.addEventListener('abort', outerSignalHandler_1);
          subscriber.add(function () {
            return outerSignal.removeEventListener('abort', outerSignalHandler_1);
          });
        }
      }

      var perSubscriberInit = __assign$1(__assign$1({}, init), {
        signal: signal
      });

      var handleError = function (err) {
        abortable = false;
        subscriber.error(err);
      };

      fetch(input, perSubscriberInit).then(function (response) {
        if (selector) {
          innerFrom(selector(response)).subscribe(new OperatorSubscriber(subscriber, undefined, function () {
            abortable = false;
            subscriber.complete();
          }, handleError));
        } else {
          abortable = false;
          subscriber.next(response);
          subscriber.complete();
        }
      }).catch(handleError);
      return function () {
        if (abortable) {
          controller.abort();
        }
      };
    });
  }

  function getXHRResponse(xhr) {
    switch (xhr.responseType) {
      case 'json':
        {
          if ('response' in xhr) {
            return xhr.response;
          } else {
            var ieXHR = xhr;
            return JSON.parse(ieXHR.responseText);
          }
        }

      case 'document':
        return xhr.responseXML;

      case 'text':
      default:
        {
          if ('response' in xhr) {
            return xhr.response;
          } else {
            var ieXHR = xhr;
            return ieXHR.responseText;
          }
        }
    }
  }

  var AjaxResponse = function () {
    function AjaxResponse(originalEvent, xhr, request, type) {
      if (type === void 0) {
        type = 'download_load';
      }

      this.originalEvent = originalEvent;
      this.xhr = xhr;
      this.request = request;
      this.type = type;
      var status = xhr.status,
          responseType = xhr.responseType;
      this.status = status !== null && status !== void 0 ? status : 0;
      this.responseType = responseType !== null && responseType !== void 0 ? responseType : '';
      var allHeaders = xhr.getAllResponseHeaders();
      this.responseHeaders = allHeaders ? allHeaders.split('\n').reduce(function (headers, line) {
        var index = line.indexOf(': ');
        headers[line.slice(0, index)] = line.slice(index + 2);
        return headers;
      }, {}) : {};
      this.response = getXHRResponse(xhr);
      var loaded = originalEvent.loaded,
          total = originalEvent.total;
      this.loaded = loaded;
      this.total = total;
    }

    return AjaxResponse;
  }();

  var AjaxError = createErrorClass(function (_super) {
    return function AjaxErrorImpl(message, xhr, request) {
      this.message = message;
      this.name = 'AjaxError';
      this.xhr = xhr;
      this.request = request;
      this.status = xhr.status;
      this.responseType = xhr.responseType;
      var response;

      try {
        response = getXHRResponse(xhr);
      } catch (err) {
        response = xhr.responseText;
      }

      this.response = response;
    };
  });
  var AjaxTimeoutError = function () {
    function AjaxTimeoutErrorImpl(xhr, request) {
      AjaxError.call(this, 'ajax timeout', xhr, request);
      this.name = 'AjaxTimeoutError';
      return this;
    }

    AjaxTimeoutErrorImpl.prototype = Object.create(AjaxError.prototype);
    return AjaxTimeoutErrorImpl;
  }();

  function ajaxGet(url, headers) {
    return ajax({
      method: 'GET',
      url: url,
      headers: headers
    });
  }

  function ajaxPost(url, body, headers) {
    return ajax({
      method: 'POST',
      url: url,
      body: body,
      headers: headers
    });
  }

  function ajaxDelete(url, headers) {
    return ajax({
      method: 'DELETE',
      url: url,
      headers: headers
    });
  }

  function ajaxPut(url, body, headers) {
    return ajax({
      method: 'PUT',
      url: url,
      body: body,
      headers: headers
    });
  }

  function ajaxPatch(url, body, headers) {
    return ajax({
      method: 'PATCH',
      url: url,
      body: body,
      headers: headers
    });
  }

  var mapResponse = map(function (x) {
    return x.response;
  });

  function ajaxGetJSON(url, headers) {
    return mapResponse(ajax({
      method: 'GET',
      url: url,
      headers: headers
    }));
  }

  var ajax = function () {
    var create = function (urlOrConfig) {
      var config = typeof urlOrConfig === 'string' ? {
        url: urlOrConfig
      } : urlOrConfig;
      return fromAjax(config);
    };

    create.get = ajaxGet;
    create.post = ajaxPost;
    create.delete = ajaxDelete;
    create.put = ajaxPut;
    create.patch = ajaxPatch;
    create.getJSON = ajaxGetJSON;
    return create;
  }();
  var UPLOAD = 'upload';
  var DOWNLOAD = 'download';
  var LOADSTART = 'loadstart';
  var PROGRESS = 'progress';
  var LOAD = 'load';
  function fromAjax(config) {
    return new Observable(function (destination) {
      var _a, _b;

      var queryParams = config.queryParams,
          configuredBody = config.body,
          configuredHeaders = config.headers,
          remainingConfig = __rest(config, ["queryParams", "body", "headers"]);

      var url = remainingConfig.url;

      if (!url) {
        throw new TypeError('url is required');
      }

      if (queryParams) {
        var searchParams_1;

        if (url.includes('?')) {
          var parts = url.split('?');

          if (2 < parts.length) {
            throw new TypeError('invalid url');
          }

          searchParams_1 = new URLSearchParams(parts[1]);
          new URLSearchParams(queryParams).forEach(function (value, key) {
            return searchParams_1.set(key, value);
          });
          url = parts[0] + '?' + searchParams_1;
        } else {
          searchParams_1 = new URLSearchParams(queryParams);
          url = url + '?' + searchParams_1;
        }
      }

      var headers = {};

      if (configuredHeaders) {
        for (var key in configuredHeaders) {
          if (configuredHeaders.hasOwnProperty(key)) {
            headers[key.toLowerCase()] = configuredHeaders[key];
          }
        }
      }

      if (!config.crossDomain && !('x-requested-with' in headers)) {
        headers['x-requested-with'] = 'XMLHttpRequest';
      }

      var withCredentials = remainingConfig.withCredentials,
          xsrfCookieName = remainingConfig.xsrfCookieName,
          xsrfHeaderName = remainingConfig.xsrfHeaderName;

      if ((withCredentials || !remainingConfig.crossDomain) && xsrfCookieName && xsrfHeaderName) {
        var xsrfCookie = (_b = (_a = document === null || document === void 0 ? void 0 : document.cookie.match(new RegExp("(^|;\\s*)(" + xsrfCookieName + ")=([^;]*)"))) === null || _a === void 0 ? void 0 : _a.pop()) !== null && _b !== void 0 ? _b : '';

        if (xsrfCookie) {
          headers[xsrfHeaderName] = xsrfCookie;
        }
      }

      var body = extractContentTypeAndMaybeSerializeBody(configuredBody, headers);

      var _request = __assign$1(__assign$1({
        async: true,
        crossDomain: true,
        withCredentials: false,
        method: 'GET',
        timeout: 0,
        responseType: 'json'
      }, remainingConfig), {
        url: url,
        headers: headers,
        body: body
      });

      var xhr;
      xhr = config.createXHR ? config.createXHR() : new XMLHttpRequest();
      {
        var progressSubscriber_1 = config.progressSubscriber,
            _c = config.includeDownloadProgress,
            includeDownloadProgress = _c === void 0 ? false : _c,
            _d = config.includeUploadProgress,
            includeUploadProgress = _d === void 0 ? false : _d;

        var addErrorEvent = function (type, errorFactory) {
          xhr.addEventListener(type, function () {
            var _a;

            var error = errorFactory();
            (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, error);
            destination.error(error);
          });
        };

        addErrorEvent('timeout', function () {
          return new AjaxTimeoutError(xhr, _request);
        });
        addErrorEvent('abort', function () {
          return new AjaxError('aborted', xhr, _request);
        });

        var createResponse_1 = function (direction, event) {
          return new AjaxResponse(event, xhr, _request, direction + "_" + event.type);
        };

        var addProgressEvent_1 = function (target, type, direction) {
          target.addEventListener(type, function (event) {
            destination.next(createResponse_1(direction, event));
          });
        };

        if (includeUploadProgress) {
          [LOADSTART, PROGRESS, LOAD].forEach(function (type) {
            return addProgressEvent_1(xhr.upload, type, UPLOAD);
          });
        }

        if (progressSubscriber_1) {
          [LOADSTART, PROGRESS].forEach(function (type) {
            return xhr.upload.addEventListener(type, function (e) {
              var _a;

              return (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.next) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e);
            });
          });
        }

        if (includeDownloadProgress) {
          [LOADSTART, PROGRESS].forEach(function (type) {
            return addProgressEvent_1(xhr, type, DOWNLOAD);
          });
        }

        var emitError_1 = function (status) {
          var msg = 'ajax error' + (status ? ' ' + status : '');
          destination.error(new AjaxError(msg, xhr, _request));
        };

        xhr.addEventListener('error', function (e) {
          var _a;

          (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1, e);
          emitError_1();
        });
        xhr.addEventListener(LOAD, function (event) {
          var _a, _b;

          var status = xhr.status;

          if (status < 400) {
            (_a = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.complete) === null || _a === void 0 ? void 0 : _a.call(progressSubscriber_1);
            var response = void 0;

            try {
              response = createResponse_1(DOWNLOAD, event);
            } catch (err) {
              destination.error(err);
              return;
            }

            destination.next(response);
            destination.complete();
          } else {
            (_b = progressSubscriber_1 === null || progressSubscriber_1 === void 0 ? void 0 : progressSubscriber_1.error) === null || _b === void 0 ? void 0 : _b.call(progressSubscriber_1, event);
            emitError_1(status);
          }
        });
      }
      var user = _request.user,
          method = _request.method,
          async = _request.async;

      if (user) {
        xhr.open(method, url, async, user, _request.password);
      } else {
        xhr.open(method, url, async);
      }

      if (async) {
        xhr.timeout = _request.timeout;
        xhr.responseType = _request.responseType;
      }

      if ('withCredentials' in xhr) {
        xhr.withCredentials = _request.withCredentials;
      }

      for (var key in headers) {
        if (headers.hasOwnProperty(key)) {
          xhr.setRequestHeader(key, headers[key]);
        }
      }

      if (body) {
        xhr.send(body);
      } else {
        xhr.send();
      }

      return function () {
        if (xhr && xhr.readyState !== 4) {
          xhr.abort();
        }
      };
    });
  }

  function extractContentTypeAndMaybeSerializeBody(body, headers) {
    var _a;

    if (!body || typeof body === 'string' || isFormData(body) || isURLSearchParams(body) || isArrayBuffer(body) || isFile(body) || isBlob(body) || isReadableStream(body)) {
      return body;
    }

    if (isArrayBufferView(body)) {
      return body.buffer;
    }

    if (typeof body === 'object') {
      headers['content-type'] = (_a = headers['content-type']) !== null && _a !== void 0 ? _a : 'application/json;charset=utf-8';
      return JSON.stringify(body);
    }

    throw new TypeError('Unknown body type');
  }

  var _toString = Object.prototype.toString;

  function toStringCheck(obj, name) {
    return _toString.call(obj) === "[object " + name + "]";
  }

  function isArrayBuffer(body) {
    return toStringCheck(body, 'ArrayBuffer');
  }

  function isFile(body) {
    return toStringCheck(body, 'File');
  }

  function isBlob(body) {
    return toStringCheck(body, 'Blob');
  }

  function isArrayBufferView(body) {
    return typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView(body);
  }

  function isFormData(body) {
    return typeof FormData !== 'undefined' && body instanceof FormData;
  }

  function isURLSearchParams(body) {
    return typeof URLSearchParams !== 'undefined' && body instanceof URLSearchParams;
  }

  function isReadableStream(body) {
    return typeof ReadableStream !== 'undefined' && body instanceof ReadableStream;
  }

  var queryString = {};

  (function (exports) {

  const strictUriEncode$1 = strictUriEncode;

  const decodeComponent = decodeUriComponent;

  const splitOnFirst$1 = splitOnFirst;

  const filterObject = filterObj;

  const isNullOrUndefined = value => value === null || value === undefined;

  const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');

  function encoderForArrayFormat(options) {
    switch (options.arrayFormat) {
      case 'index':
        return key => (result, value) => {
          const index = result.length;

          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [...result, [encode(key, options), '[', index, ']'].join('')];
          }

          return [...result, [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')];
        };

      case 'bracket':
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [...result, [encode(key, options), '[]'].join('')];
          }

          return [...result, [encode(key, options), '[]=', encode(value, options)].join('')];
        };

      case 'colon-list-separator':
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [...result, [encode(key, options), ':list='].join('')];
          }

          return [...result, [encode(key, options), ':list=', encode(value, options)].join('')];
        };

      case 'comma':
      case 'separator':
      case 'bracket-separator':
        {
          const keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
          return key => (result, value) => {
            if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
              return result;
            } // Translate null to an empty string so that it doesn't serialize as 'null'


            value = value === null ? '' : value;

            if (result.length === 0) {
              return [[encode(key, options), keyValueSep, encode(value, options)].join('')];
            }

            return [[result, encode(value, options)].join(options.arrayFormatSeparator)];
          };
        }

      default:
        return key => (result, value) => {
          if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
            return result;
          }

          if (value === null) {
            return [...result, encode(key, options)];
          }

          return [...result, [encode(key, options), '=', encode(value, options)].join('')];
        };
    }
  }

  function parserForArrayFormat(options) {
    let result;

    switch (options.arrayFormat) {
      case 'index':
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = {};
          }

          accumulator[key][result[1]] = value;
        };

      case 'bracket':
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };

      case 'colon-list-separator':
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, '');

          if (!result) {
            accumulator[key] = value;
            return;
          }

          if (accumulator[key] === undefined) {
            accumulator[key] = [value];
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };

      case 'comma':
      case 'separator':
        return (key, value, accumulator) => {
          const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
          const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
          value = isEncodedArray ? decode(value, options) : value;
          const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);
          accumulator[key] = newValue;
        };

      case 'bracket-separator':
        return (key, value, accumulator) => {
          const isArray = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, '');

          if (!isArray) {
            accumulator[key] = value ? decode(value, options) : value;
            return;
          }

          const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map(item => decode(item, options));

          if (accumulator[key] === undefined) {
            accumulator[key] = arrayValue;
            return;
          }

          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };

      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === undefined) {
            accumulator[key] = value;
            return;
          }

          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }

  function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
      throw new TypeError('arrayFormatSeparator must be single character string');
    }
  }

  function encode(value, options) {
    if (options.encode) {
      return options.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }

    return value;
  }

  function decode(value, options) {
    if (options.decode) {
      return decodeComponent(value);
    }

    return value;
  }

  function keysSorter(input) {
    if (Array.isArray(input)) {
      return input.sort();
    }

    if (typeof input === 'object') {
      return keysSorter(Object.keys(input)).sort((a, b) => Number(a) - Number(b)).map(key => input[key]);
    }

    return input;
  }

  function removeHash(input) {
    const hashStart = input.indexOf('#');

    if (hashStart !== -1) {
      input = input.slice(0, hashStart);
    }

    return input;
  }

  function getHash(url) {
    let hash = '';
    const hashStart = url.indexOf('#');

    if (hashStart !== -1) {
      hash = url.slice(hashStart);
    }

    return hash;
  }

  function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf('?');

    if (queryStart === -1) {
      return '';
    }

    return input.slice(queryStart + 1);
  }

  function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
      value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
      value = value.toLowerCase() === 'true';
    }

    return value;
  }

  function parse(query, options) {
    options = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ',',
      parseNumbers: false,
      parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options); // Create an object with no prototype

    const ret = Object.create(null);

    if (typeof query !== 'string') {
      return ret;
    }

    query = query.trim().replace(/^[?#&]/, '');

    if (!query) {
      return ret;
    }

    for (const param of query.split('&')) {
      if (param === '') {
        continue;
      }

      let [key, value] = splitOnFirst$1(options.decode ? param.replace(/\+/g, ' ') : param, '='); // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters

      value = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);
      formatter(decode(key, options), value, ret);
    }

    for (const key of Object.keys(ret)) {
      const value = ret[key];

      if (typeof value === 'object' && value !== null) {
        for (const k of Object.keys(value)) {
          value[k] = parseValue(value[k], options);
        }
      } else {
        ret[key] = parseValue(value, options);
      }
    }

    if (options.sort === false) {
      return ret;
    }

    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
      const value = ret[key];

      if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
        // Sort object keys, not values
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }

      return result;
    }, Object.create(null));
  }

  exports.extract = extract;
  exports.parse = parse;

  exports.stringify = (object, options) => {
    if (!object) {
      return '';
    }

    options = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: 'none',
      arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);

    const shouldFilter = key => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';

    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};

    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }

    const keys = Object.keys(objectCopy);

    if (options.sort !== false) {
      keys.sort(options.sort);
    }

    return keys.map(key => {
      const value = object[key];

      if (value === undefined) {
        return '';
      }

      if (value === null) {
        return encode(key, options);
      }

      if (Array.isArray(value)) {
        if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
          return encode(key, options) + '[]';
        }

        return value.reduce(formatter(key), []).join('&');
      }

      return encode(key, options) + '=' + encode(value, options);
    }).filter(x => x.length > 0).join('&');
  };

  exports.parseUrl = (url, options) => {
    options = Object.assign({
      decode: true
    }, options);
    const [url_, hash] = splitOnFirst$1(url, '#');
    return Object.assign({
      url: url_.split('?')[0] || '',
      query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
      fragmentIdentifier: decode(hash, options)
    } : {});
  };

  exports.stringifyUrl = (object, options) => {
    options = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object.url).split('?')[0] || '';
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, {
      sort: false
    });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString = exports.stringify(query, options);

    if (queryString) {
      queryString = `?${queryString}`;
    }

    let hash = getHash(object.url);

    if (object.fragmentIdentifier) {
      hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }

    return `${url}${queryString}${hash}`;
  };

  exports.pick = (input, filter, options) => {
    options = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options);
    const {
      url,
      query,
      fragmentIdentifier
    } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options);
  };

  exports.exclude = (input, filter, options) => {
    const exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input, exclusionFilter, options);
  };
  }(queryString));

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  var DEFAULTS = {
    site: '',
    cors: false,
    baseUrl: '',
    searchId: null,
    endpoints: {
      GET_ITEM_URL: '/api/1/site/content_store/item.json',
      GET_DESCRIPTOR: '/api/1/site/content_store/descriptor.json',
      GET_CHILDREN: '/api/1/site/content_store/children.json',
      GET_TREE: '/api/1/site/content_store/tree.json',
      GET_NAV_TREE: '/api/1/site/navigation/tree.json',
      GET_BREADCRUMB: '/api/1/site/navigation/breadcrumb.json',
      TRANSFORM_URL: '/api/1/site/url/transform.json',
      ELASTICSEARCH: '/api/1/site/elasticsearch/search'
    },
    contentTypeRegistry: {},
    headers: {}
  };

  var ConfigManager =
  /** @class */
  function () {
    function ConfigManager() {
      this.config = __assign({}, DEFAULTS);
      this.config$ = new BehaviorSubject(__assign({}, DEFAULTS));
    }

    ConfigManager.prototype.publishConfig = function (config) {
      this.config = __assign({}, config);
      this.config$.next(__assign({}, config));
    };

    ConfigManager.prototype.subscribe = function (observerOrNext) {
      var operators = [];

      for (var _i = 1; _i < arguments.length; _i++) {
        operators[_i - 1] = arguments[_i];
      }

      return this.config$.pipe.apply(this.config$, operators).subscribe(observerOrNext);
    };

    ConfigManager.prototype.entry = function (propPath, nextValue) {
      var _a;

      var config = this.config;
      if (!propPath) return __assign({}, config);
      var getter = nextValue == null;
      var path = propPath.split('.');
      var prop = !getter && path.pop();

      var value = function () {
        try {
          var l_1 = path.length - 1;
          return path.length ? path.reduce(function (cfg, property, i) {
            return getter && l_1 === i && isPlainObject$1(cfg[property]) ? __assign({}, cfg[property]) : cfg[property];
          }, config) : config;
        } catch (e) {
          log("Error retrieving crafter config prop '" + propPath + "': " + (e.message || e), log.WARN);
          return null;
        }
      }();

      if (getter) {
        return value;
      } else if (prop in value || path[path.length - 1] === 'contentTypeRegistry') {
        this.publishConfig(__assign(__assign({}, value), (_a = {}, _a[prop] = nextValue, _a)));
      }
    };

    ConfigManager.prototype.getConfig = function () {
      return __assign({}, this.config);
    };

    ConfigManager.prototype.mix = function (mixin) {
      if (mixin === void 0) {
        mixin = {};
      }

      return extendDeepExistingProps(__assign({}, this.config), mixin);
    };

    ConfigManager.prototype.configure = function (nextConfig) {
      this.publishConfig(this.mix(nextConfig));
    };

    return ConfigManager;
  }();

  var crafterConf = new ConfigManager();

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  function httpGet(requestURL, params, headers) {
    if (params === void 0) {
      params = {};
    }

    var mode = crafterConf.getConfig().cors;
    return fromFetch(requestURL + "?" + queryString.stringify(params), {
      method: 'GET',
      headers: headers,
      mode: typeof mode === 'boolean' ? mode ? 'cors' : 'no-cors' : mode,
      selector: function (response) {
        return response.json();
      }
    });
  }
  function httpPost(requestURL, body, headers) {
    if (body === void 0) {
      body = {};
    }

    return ajax.post(requestURL, body, __assign({
      'Content-Type': 'application/json'
    }, headers)).pipe(pluck('response'));
  }
  var SDKService = {
    httpGet: httpGet,
    httpPost: httpPost
  };

  var rngBrowser = {exports: {}};

  // Unique ID creation requires a high quality random # generator.  In the
  // browser this is a little complicated due to unknown quality of Math.random()
  // and inconsistent support for the `crypto` API.  We do the best we can via
  // feature-detection
  // getRandomValues needs to be invoked in a context where "this" is a Crypto
  // implementation. Also, find the complete implementation of crypto on IE11.
  var getRandomValues = typeof crypto != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto);

  if (getRandomValues) {
    // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
    var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

    rngBrowser.exports = function whatwgRNG() {
      getRandomValues(rnds8);
      return rnds8;
    };
  } else {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var rnds = new Array(16);

    rngBrowser.exports = function mathRNG() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return rnds;
    };
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */

  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
  }

  function bytesToUuid$2(buf, offset) {
    var i = offset || 0;
    var bth = byteToHex; // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4

    return [bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], '-', bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]], bth[buf[i++]]].join('');
  }

  var bytesToUuid_1 = bytesToUuid$2;

  var rng$1 = rngBrowser.exports;

  var bytesToUuid$1 = bytesToUuid_1; // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html


  var _nodeId;

  var _clockseq; // Previous uuid creation time


  var _lastMSecs = 0;
  var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

  function v1$1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189

    if (node == null || clockseq == null) {
      var seedBytes = rng$1();

      if (node == null) {
        // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }

      if (clockseq == null) {
        // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
      }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


    var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock

    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval


    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested


    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

    msecs += 12219292800000; // `time_low`

    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`

    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`

    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

    b[i++] = clockseq & 0xff; // `node`

    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }

    return buf ? buf : bytesToUuid$1(b);
  }

  var v1_1 = v1$1;

  var rng = rngBrowser.exports;

  var bytesToUuid = bytesToUuid_1;

  function v4$1(options, buf, offset) {
    var i = buf && offset || 0;

    if (typeof options == 'string') {
      buf = options === 'binary' ? new Array(16) : null;
      options = null;
    }

    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      for (var ii = 0; ii < 16; ++ii) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || bytesToUuid(rnds);
  }

  var v4_1 = v4$1;

  var v1 = v1_1;

  var v4 = v4_1;

  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  var uuid_1 = uuid;

  /**
   *
   *
   * @author Jerry Bendy <jerry@icewingcc.com>
   * @licence MIT
   *
   */

  (function (self) {

    var nativeURLSearchParams = self.URLSearchParams && self.URLSearchParams.prototype.get ? self.URLSearchParams : null,
        isSupportObjectConstructor = nativeURLSearchParams && new nativeURLSearchParams({
      a: 1
    }).toString() === 'a=1',
        // There is a bug in safari 10.1 (and earlier) that incorrectly decodes `%2B` as an empty space and not a plus.
    decodesPlusesCorrectly = nativeURLSearchParams && new nativeURLSearchParams('s=%2B').get('s') === '+',
        __URLSearchParams__ = "__URLSearchParams__",
        // Fix bug in Edge which cannot encode ' &' correctly
    encodesAmpersandsCorrectly = nativeURLSearchParams ? function () {
      var ampersandTest = new nativeURLSearchParams();
      ampersandTest.append('s', ' &');
      return ampersandTest.toString() === 's=+%26';
    }() : true,
        prototype = URLSearchParamsPolyfill.prototype,
        iterable = !!(self.Symbol && self.Symbol.iterator);

    if (nativeURLSearchParams && isSupportObjectConstructor && decodesPlusesCorrectly && encodesAmpersandsCorrectly) {
      return;
    }
    /**
     * Make a URLSearchParams instance
     *
     * @param {object|string|URLSearchParams} search
     * @constructor
     */


    function URLSearchParamsPolyfill(search) {
      search = search || ""; // support construct object with another URLSearchParams instance

      if (search instanceof URLSearchParams || search instanceof URLSearchParamsPolyfill) {
        search = search.toString();
      }

      this[__URLSearchParams__] = parseToDict(search);
    }
    /**
     * Appends a specified key/value pair as a new search parameter.
     *
     * @param {string} name
     * @param {string} value
     */


    prototype.append = function (name, value) {
      appendTo(this[__URLSearchParams__], name, value);
    };
    /**
     * Deletes the given search parameter, and its associated value,
     * from the list of all search parameters.
     *
     * @param {string} name
     */


    prototype['delete'] = function (name) {
      delete this[__URLSearchParams__][name];
    };
    /**
     * Returns the first value associated to the given search parameter.
     *
     * @param {string} name
     * @returns {string|null}
     */


    prototype.get = function (name) {
      var dict = this[__URLSearchParams__];
      return name in dict ? dict[name][0] : null;
    };
    /**
     * Returns all the values association with a given search parameter.
     *
     * @param {string} name
     * @returns {Array}
     */


    prototype.getAll = function (name) {
      var dict = this[__URLSearchParams__];
      return name in dict ? dict[name].slice(0) : [];
    };
    /**
     * Returns a Boolean indicating if such a search parameter exists.
     *
     * @param {string} name
     * @returns {boolean}
     */


    prototype.has = function (name) {
      return name in this[__URLSearchParams__];
    };
    /**
     * Sets the value associated to a given search parameter to
     * the given value. If there were several values, delete the
     * others.
     *
     * @param {string} name
     * @param {string} value
     */


    prototype.set = function set(name, value) {
      this[__URLSearchParams__][name] = ['' + value];
    };
    /**
     * Returns a string containg a query string suitable for use in a URL.
     *
     * @returns {string}
     */


    prototype.toString = function () {
      var dict = this[__URLSearchParams__],
          query = [],
          i,
          key,
          name,
          value;

      for (key in dict) {
        name = encode(key);

        for (i = 0, value = dict[key]; i < value.length; i++) {
          query.push(name + '=' + encode(value[i]));
        }
      }

      return query.join('&');
    }; // There is a bug in Safari 10.1 and `Proxy`ing it is not enough.


    var forSureUsePolyfill = !decodesPlusesCorrectly;
    var useProxy = !forSureUsePolyfill && nativeURLSearchParams && !isSupportObjectConstructor && self.Proxy;
    /*
     * Apply polifill to global object and append other prototype into it
     */

    Object.defineProperty(self, 'URLSearchParams', {
      value: useProxy ? // Safari 10.0 doesn't support Proxy, so it won't extend URLSearchParams on safari 10.0
      new Proxy(nativeURLSearchParams, {
        construct: function (target, args) {
          return new target(new URLSearchParamsPolyfill(args[0]).toString());
        }
      }) : URLSearchParamsPolyfill
    });
    var USPProto = self.URLSearchParams.prototype;
    USPProto.polyfill = true;
    /**
     *
     * @param {function} callback
     * @param {object} thisArg
     */

    USPProto.forEach = USPProto.forEach || function (callback, thisArg) {
      var dict = parseToDict(this.toString());
      Object.getOwnPropertyNames(dict).forEach(function (name) {
        dict[name].forEach(function (value) {
          callback.call(thisArg, value, name, this);
        }, this);
      }, this);
    };
    /**
     * Sort all name-value pairs
     */


    USPProto.sort = USPProto.sort || function () {
      var dict = parseToDict(this.toString()),
          keys = [],
          k,
          i,
          j;

      for (k in dict) {
        keys.push(k);
      }

      keys.sort();

      for (i = 0; i < keys.length; i++) {
        this['delete'](keys[i]);
      }

      for (i = 0; i < keys.length; i++) {
        var key = keys[i],
            values = dict[key];

        for (j = 0; j < values.length; j++) {
          this.append(key, values[j]);
        }
      }
    };
    /**
     * Returns an iterator allowing to go through all keys of
     * the key/value pairs contained in this object.
     *
     * @returns {function}
     */


    USPProto.keys = USPProto.keys || function () {
      var items = [];
      this.forEach(function (item, name) {
        items.push(name);
      });
      return makeIterator(items);
    };
    /**
     * Returns an iterator allowing to go through all values of
     * the key/value pairs contained in this object.
     *
     * @returns {function}
     */


    USPProto.values = USPProto.values || function () {
      var items = [];
      this.forEach(function (item) {
        items.push(item);
      });
      return makeIterator(items);
    };
    /**
     * Returns an iterator allowing to go through all key/value
     * pairs contained in this object.
     *
     * @returns {function}
     */


    USPProto.entries = USPProto.entries || function () {
      var items = [];
      this.forEach(function (item, name) {
        items.push([name, item]);
      });
      return makeIterator(items);
    };

    if (iterable) {
      USPProto[self.Symbol.iterator] = USPProto[self.Symbol.iterator] || USPProto.entries;
    }

    function encode(str) {
      var replace = {
        '!': '%21',
        "'": '%27',
        '(': '%28',
        ')': '%29',
        '~': '%7E',
        '%20': '+',
        '%00': '\x00'
      };
      return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function (match) {
        return replace[match];
      });
    }

    function decode(str) {
      return decodeURIComponent(str.replace(/\+/g, ' '));
    }

    function makeIterator(arr) {
      var iterator = {
        next: function () {
          var value = arr.shift();
          return {
            done: value === undefined,
            value: value
          };
        }
      };

      if (iterable) {
        iterator[self.Symbol.iterator] = function () {
          return iterator;
        };
      }

      return iterator;
    }

    function parseToDict(search) {
      var dict = {};

      if (typeof search === "object") {
        for (var key in search) {
          if (search.hasOwnProperty(key)) {
            appendTo(dict, key, search[key]);
          }
        }
      } else {
        // remove first '?'
        if (search.indexOf("?") === 0) {
          search = search.slice(1);
        }

        var pairs = search.split("&");

        for (var j = 0; j < pairs.length; j++) {
          var value = pairs[j],
              index = value.indexOf('=');

          if (-1 < index) {
            appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));
          } else {
            if (value) {
              appendTo(dict, decode(value), '');
            }
          }
        }
      }

      return dict;
    }

    function appendTo(dict, name, value) {
      var val = typeof value === 'string' ? value : value !== null && value !== undefined && typeof value.toString === 'function' ? value.toString() : JSON.stringify(value);

      if (name in dict) {
        dict[name].push(val);
      } else {
        dict[name] = [val];
      }
    }
  })(typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : commonjsGlobal);

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  function search(queryOrParams, config) {
    config = crafterConf.mix(config);
    var requestURL;
    var params = queryOrParams instanceof Query ? queryOrParams.params : queryOrParams;

    if (queryOrParams instanceof ElasticQuery) {
      requestURL = composeUrl(config, config.endpoints.ELASTICSEARCH) + '?crafterSite=' + config.site;
      return SDKService.httpPost(requestURL, params).pipe(map(function (response) {
        return response.hits;
      }));
    }
  }
  /**
   * Returns a new Query object
   */

  function createQuery(params) {
    var query,
        queryId = params && params['uuid'] ? params['uuid'] : uuid_1();
    query = new ElasticQuery();
    Object.assign(query.params, params);
    query.uuid = queryId;
    return query;
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  var systemPropMap = {
    guid: 'id',
    cmsId: 'id',
    objectId: 'id',
    localId: 'path',
    'file-name': 'fileName',
    'file__name': 'fileName',
    placeInNav: 'placeInNav',
    'internal-name': 'label',
    internal__name: 'label',
    'content-type': 'contentTypeId',
    content__type: 'contentTypeId',
    createdDate_dt: 'dateCreated',
    lastModifiedDate_dt: 'dateModified',
    disabled: 'disabled'
  };
  var ignoreProps = ['orderDefault_f', 'merge-strategy', 'display-template', 'objectGroupId', 'folder-name', 'createdDate', 'lastModifiedDate', 'no-template-required'];
  var systemProps$1 = Object.keys(systemPropMap).concat(Object.values(systemPropMap));
  function parseDescriptor(data) {
    if (data == null) {
      return null;
    } else if (Array.isArray(data)) {
      return data.map(function (item) {
        return parseDescriptor(item);
      });
    } else if (data.children) {
      return parseDescriptor(extractChildren(data.children));
    } else if (data.descriptorDom === null && data.descriptorUrl) {
      // This path catches calls to getChildren (/api/1/site/content_store/children.json?url=&crafterSite=)
      // The getChildren call contains certain items that can't be parsed into content items.
      throw new Error('[parseDescriptor] Invalid descriptor supplied. Did you call ' + 'parseDescriptor with a `getChildren` API response? The `getChildren` API ' + 'response may contain certain items that are not parsable into ContentInstances. ' + 'Try a different API (getItem, getDescriptor or getTree) or filter out the metadata ' + 'items which descriptorDom property has a `page` or `component` property with the content item.');
    }

    var parsed = {
      craftercms: {
        id: null,
        path: null,
        label: null,
        contentTypeId: null,
        dateCreated: null,
        dateModified: null,
        sourceMap: {}
      }
    };
    return parseProps(extractContent(data), parsed);
  }
  function parseProps(props, parsed) {
    if (parsed === void 0) {
      parsed = {};
    }

    Object.entries(props).forEach(function (_a) {
      var _b, _c;

      var prop = _a[0],
          value = _a[1];

      if (ignoreProps.includes(prop)) {
        return; // continue, skip prop.
      }

      if (value === null || value === void 0 ? void 0 : value['crafter-source-content-type-id']) {
        // @ts-ignore
        parsed.craftercms.sourceMap[prop] = value['crafter-source-content-type-id'];

        if (typeof value.text === 'string') {
          value = value.text;
        } else if (Object.keys(value).length === 2) {
          // Only has `crafter-source` & `crafter-source-content-type-id`. Empty value for the actual prop.
          value = null;
        }
      }

      if (systemProps$1.includes(prop)) {
        // @ts-ignore
        parsed.craftercms[(_b = systemPropMap[prop]) !== null && _b !== void 0 ? _b : prop] = value; // Is there a risk prop name that matches what's considered a system prop?
        // In that case, here, parsed.craftercms might not be in the target object
        // and throw. We could do the below to de-risk but feels this needs assessment.
        // if (parsed.craftercms) {
        //   parsed.craftercms[systemPropMap[prop] ?? prop] = value;
        // } else {
        //   parsed[prop] = value;
        // }
      } else if (prop.endsWith('_o')) {
        parsed[prop] = (_c = value === null || value === void 0 ? void 0 : value.item) !== null && _c !== void 0 ? _c : [];

        if (!Array.isArray(parsed[prop])) {
          parsed[prop] = [parsed[prop]];
        }

        parsed[prop] = parsed[prop].map(function (item) {
          var key = item.key,
              value = item.value,
              component = item.component,
              include = item.include;

          if (item.component || item.key && item.value) {
            // Components
            var newComponent = __assign(__assign({
              label: value
            }, component), {
              path: (key === null || key === void 0 ? void 0 : key.startsWith('/')) ? key : (include === null || include === void 0 ? void 0 : include.startsWith('/')) ? include : (component === null || component === void 0 ? void 0 : component.path) ? component.path : null
            });

            return parseDescriptor(newComponent);
          } else {
            // Repeat group items
            return parseProps(item);
          }
        });
      } else {
        parsed[prop] = value !== null && value !== void 0 ? value : null;
      }
    });
    return parsed;
  }
  /**
   * Inspects the data for getItem or getDescriptor responses and returns the inner content object
   * */

  function extractContent(data) {
    var output = data;

    if (data.descriptorDom) {
      return __assign(__assign({}, data.descriptorDom.page || data.descriptorDom.component), {
        path: data.url
      });
    } else if (data.page) {
      return data.page;
    } else if (data.component) {
      return data.component;
    }

    return output;
  }
  /**
   * Flattens a getChildren response into a flat list of content items
   * */


  function extractChildren(children) {
    return children.flatMap(function (child) {
      return child.children ? extractChildren(child.children) : child;
    });
  }

  var propsToRemove = ['rootId', 'crafterSite', 'crafterPublishedDate', 'crafterPublishedDate_dt', 'inheritsFrom_smv'];
  function preParseSearchResults(source) {
    Object.entries(source).forEach(function (_a) {
      var prop = _a[0],
          value = _a[1];

      if (propsToRemove.includes(prop)) {
        delete source[prop];
      } else if (prop.endsWith('_o')) {
        var collection = value;

        if (!Array.isArray(collection.item)) {
          source[prop] = {
            item: [collection.item]
          };
        }

        source[prop].item.forEach(function (item, i) {
          source[prop].item[i] = preParseSearchResults(item);

          if (item.component) {
            source[prop].item[i].component = preParseSearchResults(item.component);
          }
        });
      }
    });
    return source;
  }

  /**
   *
   * Jabber, tiny library to generate random real like words / sentences lipsum / lorem ipsum
   *
   *
   */

  const consonants = 'bcdfghjklmnpqrstvwxyzbpcrtpcrddrtplmnplmnbbcbcdrbnmklhgd';
  const vowels = 'aeiou';
  /**
   * Jabber Class
   * class definition
   */

  class Jabber {
    /**
     *
     * @param themeWords {array} Custom words that need to appear in some density
     * @param themeWordDensity {number} appearance of themeword 1 per this number so 5 will make it approx 1 per 5 words
     * @param extraVowels {string} additional vowel chars
     * @param extraConsonants {string} additional consonants
     */
    constructor(themeWords = [], themeWordDensity = 3, extraVowels = '', extraConsonants = '') {
      this.themeWords = themeWords;
      this.themeWordDensity = themeWordDensity;
      this.vowels = vowels + extraVowels;
      this.consonants = consonants + extraConsonants;
    }
    /**
     * Create word of certain length
     * @param length
     * @param capitalize {boolean}
     * @param avoidThemeWords {boolean}
     * @returns {string}
     */


    createWord(length, capitalize, avoidThemeWords = false) {
      let word = '';

      if (!avoidThemeWords && this.themeWords.length && Math.floor(Math.random() * this.themeWordDensity) < 1) {
        word = this.themeWords[Math.floor(Math.random() * this.themeWords.length)];
      } else {
        let currently = 'consonants';

        for (let i = 0; i < length; i++) {
          if (currently === 'consonants') {
            word += this.consonants.substr(Math.floor(Math.random() * this.consonants.length), 1);
            currently = 'vowels';
          } else {
            word += this.vowels.substr(Math.floor(Math.random() * this.vowels.length), 1);
            currently = 'consonants';
          }
        }
      }

      if (capitalize) {
        word = this._jsUcfirst(word);
      }

      return word;
    }
    /**
     * Create paragraph of certain number of words
     * @param length
     * @returns {string}
     */


    createParagraph(length) {
      let paragraph = '';
      let capitalizeNextWord = true;

      for (let i = 0; i < length; i++) {
        paragraph += this.createWord(2 + Math.floor(Math.random() * 9), capitalizeNextWord);

        if (Math.floor(Math.random() * 9) < 1) {
          paragraph += '. ';
          capitalizeNextWord = true;
        } else {
          paragraph += ' ';
          capitalizeNextWord = false;
        }
      }

      return paragraph.trim() + '.';
    }
    /**
     * Create fake full name
     * @param salutation {boolean}
     * @returns {string}
     */


    createFullName(salutation = true) {
      return (salutation ? Math.random() > 0.5 ? 'Mr. ' : 'Ms. ' : '') + this.createWord(3 + Math.floor(Math.random() * 5), true, true) + ' ' + this.createWord(2 + Math.floor(Math.random() * 9), true, true);
    }
    /**
     * Create email
     * @param customDomain {string}
     * @returns {string}
     */


    createEmail(customDomain) {
      return this.createWord(3 + Math.floor(Math.random() * 5), false, true) + '.' + this.createWord(2 + Math.floor(Math.random() * 9), false, true) + '@' + (customDomain ? customDomain : 'domain.com');
    }

    _jsUcfirst(string) {
      return string.charAt(0).toUpperCase() + string.slice(1);
    }

  }

  var jabber = Jabber;

  function isGroupItem(contentType, fieldId) {
    return fieldId.includes('.');
  }
  function isComponentHolder(contentType, fieldId) {
    return getField(contentType, fieldId).type === 'node-selector';
  }
  function getField(type, fieldId, contentTypes) {
    const fields = fieldId.split('.');
    let accumulator = Array.isArray(type.fields) ? createLookupTable(type.fields) : type.fields;
    fields.forEach(field => {

      if (accumulator.type === 'node-selector') {
        if (!contentTypes) {
          throw new Error(`Content types not provided to content type helper \`getField\` method. ` + `Unable to retrieve the field \`${fieldId}\` without full list of content types.`);
        }

        const contentTypeWithTargetFieldId = accumulator.validations.allowedContentTypes.value.find(ct => Boolean(contentTypes[ct].fields[field]));
        accumulator = contentTypes[contentTypeWithTargetFieldId].fields[field];
      } else {
        if (accumulator.type === 'repeat') {
          accumulator = accumulator.fields[field];
        } else {
          accumulator = accumulator[field];
        }
      }
    });
    return accumulator;
  }
  function getDefaultValue(field) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;

    if (field.defaultValue) {
      return field.defaultValue;
    } else if ((_a = field.validations.required) === null || _a === void 0 ? void 0 : _a.value) {
      switch (field.type) {
        case 'image':
          {
            const width = (_e = (_c = (_b = field.validations.width) === null || _b === void 0 ? void 0 : _b.value) !== null && _c !== void 0 ? _c : (_d = field.validations.minWidth) === null || _d === void 0 ? void 0 : _d.value) !== null && _e !== void 0 ? _e : 150;
            const height = (_j = (_g = (_f = field.validations.height) === null || _f === void 0 ? void 0 : _f.value) !== null && _g !== void 0 ? _g : (_h = field.validations.minHeight) === null || _h === void 0 ? void 0 : _h.value) !== null && _j !== void 0 ? _j : width;
            return `https://via.placeholder.com/${width}x${height}`;
          }

        case 'text':
        case 'textarea':
          {
            let maxLength = parseInt((_k = field.validations.maxLength) === null || _k === void 0 ? void 0 : _k.value);
            let textGen = new jabber();
            return maxLength ? `${textGen.createParagraph(50).substring(0, maxLength)}.`.replace(/\.+/, '.') : textGen.createParagraph(10);
          }

        case 'html':
          {
            let textGen = new jabber();
            return textGen.createParagraph(10);
          }

        case 'numeric-input':
          {
            return (_m = (_l = field.validations.minValue) === null || _l === void 0 ? void 0 : _l.value) !== null && _m !== void 0 ? _m : 1;
          }

        case 'boolean':
          {
            return 'false';
          }

        case 'date-time':
          {
            return new Date().toISOString();
          }

        case 'repeat':
          {
            const repeat = [];

            if (field.validations.minCount && field.fields) {
              new Array(field.validations.minCount).fill(null).forEach(() => {
                const item = {};

                for (const subFieldId in field.fields) {
                  item[subFieldId] = getDefaultValue(field.fields[subFieldId]);
                }

                repeat.push(item);
              });
            }

            return repeat;
          }

        case 'node-selector':
          return [];

        default:
          {
            return null;
          }
      }
    }
  }

  var parser = {};

  var node2json = {};

  var util$4 = {};

  (function (exports) {

  const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
  const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
  const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';
  const regexName = new RegExp('^' + nameRegexp + '$');

  const getAllMatches = function (string, regex) {
    const matches = [];
    let match = regex.exec(string);

    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;

      for (let index = 0; index < len; index++) {
        allmatches.push(match[index]);
      }

      matches.push(allmatches);
      match = regex.exec(string);
    }

    return matches;
  };

  const isName = function (string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === 'undefined');
  };

  exports.isExist = function (v) {
    return typeof v !== 'undefined';
  };

  exports.isEmptyObject = function (obj) {
    return Object.keys(obj).length === 0;
  };
  /**
   * Copy all the properties of a into b.
   * @param {*} target
   * @param {*} a
   */


  exports.merge = function (target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a); // will return an array of own properties

      const len = keys.length; //don't make it inline

      for (let i = 0; i < len; i++) {
        if (arrayMode === 'strict') {
          target[keys[i]] = [a[keys[i]]];
        } else {
          target[keys[i]] = a[keys[i]];
        }
      }
    }
  };
  /* exports.merge =function (b,a){
    return Object.assign(b,a);
  } */


  exports.getValue = function (v) {
    if (exports.isExist(v)) {
      return v;
    } else {
      return '';
    }
  }; // const fakeCall = function(a) {return a;};
  // const fakeCallNoReturn = function() {};


  exports.buildOptions = function (options, defaultOptions, props) {
    let newOptions = {};

    if (!options) {
      return defaultOptions; //if there are not options
    }

    for (let i = 0; i < props.length; i++) {
      if (options[props[i]] !== undefined) {
        newOptions[props[i]] = options[props[i]];
      } else {
        newOptions[props[i]] = defaultOptions[props[i]];
      }
    }

    return newOptions;
  };
  /**
   * Check if a tag name should be treated as array
   *
   * @param tagName the node tagname
   * @param arrayMode the array mode option
   * @param parentTagName the parent tag name
   * @returns {boolean} true if node should be parsed as array
   */


  exports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {
    if (arrayMode === false) {
      return false;
    } else if (arrayMode instanceof RegExp) {
      return arrayMode.test(tagName);
    } else if (typeof arrayMode === 'function') {
      return !!arrayMode(tagName, parentTagName);
    }

    return arrayMode === "strict";
  };

  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
  }(util$4));

  const util$3 = util$4;

  const convertToJson = function (node, options, parentTagName) {
    const jObj = {}; // when no child node or attr is present

    if (!options.alwaysCreateTextNode && (!node.child || util$3.isEmptyObject(node.child)) && (!node.attrsMap || util$3.isEmptyObject(node.attrsMap))) {
      return util$3.isExist(node.val) ? node.val : '';
    } // otherwise create a textnode if node has some text


    if (util$3.isExist(node.val) && !(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
      const asArray = util$3.isTagNameInArrayMode(node.tagname, options.arrayMode, parentTagName);
      jObj[options.textNodeName] = asArray ? [node.val] : node.val;
    }

    util$3.merge(jObj, node.attrsMap, options.arrayMode);
    const keys = Object.keys(node.child);

    for (let index = 0; index < keys.length; index++) {
      const tagName = keys[index];

      if (node.child[tagName] && node.child[tagName].length > 1) {
        jObj[tagName] = [];

        for (let tag in node.child[tagName]) {
          if (node.child[tagName].hasOwnProperty(tag)) {
            jObj[tagName].push(convertToJson(node.child[tagName][tag], options, tagName));
          }
        }
      } else {
        const result = convertToJson(node.child[tagName][0], options, tagName);
        const asArray = options.arrayMode === true && typeof result === 'object' || util$3.isTagNameInArrayMode(tagName, options.arrayMode, parentTagName);
        jObj[tagName] = asArray ? [result] : result;
      }
    } //add value


    return jObj;
  };

  node2json.convertToJson = convertToJson;

  var xmlstr2xmlnode = {};

  var xmlNode$1 = function (tagname, parent, val) {
    this.tagname = tagname;
    this.parent = parent;
    this.child = {}; //child tags

    this.attrsMap = {}; //attributes map

    this.val = val; //text only

    this.addChild = function (child) {
      if (Array.isArray(this.child[child.tagname])) {
        //already presents
        this.child[child.tagname].push(child);
      } else {
        this.child[child.tagname] = [child];
      }
    };
  };

  const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
  const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/; // const octRegex = /0x[a-z0-9]+/;
  // const binRegex = /0x[a-z0-9]+/;
  //polyfill

  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }

  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }

  const consider = {
    hex: true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true //skipLike: /regex/

  };

  function toNumber$1(str, options = {}) {
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }
    options = Object.assign({}, consider, options);
    if (!str || typeof str !== "string") return str;
    let trimmedStr = str.trim(); // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if (options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;else if (options.hex && hexRegex.test(trimmedStr)) {
      return Number.parseInt(trimmedStr, 16); // } else if (options.parseOct && octRegex.test(str)) {
      //     return Number.parseInt(val, 8);
      // }else if (options.parseBin && binRegex.test(str)) {
      //     return Number.parseInt(val, 2);
    } else {
      //separate negative sign, leading zeros, and rest number
      const match = numRegex.exec(trimmedStr);

      if (match) {
        const sign = match[1];
        const leadingZeros = match[2];
        let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
        //trim ending zeros for floating number

        const eNotation = match[4] || match[6];
        if (!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
        else if (!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
        else {
          //no leading zeros or leading zeros are allowed
          const num = Number(trimmedStr);
          const numStr = "" + num;

          if (numStr.search(/[eE]/) !== -1) {
            //given number is long and parsed to eNotation
            if (options.eNotation) return num;else return str;
          } else if (eNotation) {
            //given number has enotation
            if (options.eNotation) return num;else return str;
          } else if (trimmedStr.indexOf(".") !== -1) {
            //floating number
            // const decimalPart = match[5].substr(1);
            // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));
            // const p = numStr.indexOf(".");
            // const givenIntPart = numStr.substr(0,p);
            // const givenDecPart = numStr.substr(p+1);
            if (numStr === "0" && numTrimmedByZeros === "") return num; //0.0
            else if (numStr === numTrimmedByZeros) return num; //0.456. 0.79000
            else if (sign && numStr === "-" + numTrimmedByZeros) return num;else return str;
          }

          if (leadingZeros) {
            // if(numTrimmedByZeros === numStr){
            //     if(options.leadingZeros) return num;
            //     else return str;
            // }else return str;
            if (numTrimmedByZeros === numStr) return num;else if (sign + numTrimmedByZeros === numStr) return num;else return str;
          }

          if (trimmedStr === numStr) return num;else if (trimmedStr === sign + numStr) return num; // else{
          //     //number with +/- sign
          //     trimmedStr.test(/[-+][0-9]);
          // }

          return str;
        } // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
      } else {
        //non-numeric string
        return str;
      }
    }
  }
  /**
   * 
   * @param {string} numStr without leading zeros
   * @returns 
   */


  function trimZeros(numStr) {
    if (numStr && numStr.indexOf(".") !== -1) {
      //float
      numStr = numStr.replace(/0+$/, ""); //remove ending zeros

      if (numStr === ".") numStr = "0";else if (numStr[0] === ".") numStr = "0" + numStr;else if (numStr[numStr.length - 1] === ".") numStr = numStr.substr(0, numStr.length - 1);
      return numStr;
    }

    return numStr;
  }

  var strnum = toNumber$1;

  const util$2 = util$4;

  const buildOptions$3 = util$4.buildOptions;

  const xmlNode = xmlNode$1;

  const toNumber = strnum;

  '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'.replace(/NAME/g, util$2.nameRegexp); //const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
  //const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");
  //polyfill

  if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
  }

  if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
  }

  const defaultOptions$2 = {
    attributeNamePrefix: '@_',
    attrNodeName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    ignoreNameSpace: false,
    allowBooleanAttributes: false,
    //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseNodeValue: true,
    parseAttributeValue: false,
    arrayMode: false,
    trimValues: true,
    //Trim string values of tag and attributes
    cdataTagName: false,
    cdataPositionChar: '\\c',
    numParseOptions: {
      hex: true,
      leadingZeros: true
    },
    tagValueProcessor: function (a, tagName) {
      return a;
    },
    attrValueProcessor: function (a, attrName) {
      return a;
    },
    stopNodes: [],
    alwaysCreateTextNode: false //decodeStrict: false,

  };
  xmlstr2xmlnode.defaultOptions = defaultOptions$2;
  const props$2 = ['attributeNamePrefix', 'attrNodeName', 'textNodeName', 'ignoreAttributes', 'ignoreNameSpace', 'allowBooleanAttributes', 'parseNodeValue', 'parseAttributeValue', 'arrayMode', 'trimValues', 'cdataTagName', 'cdataPositionChar', 'tagValueProcessor', 'attrValueProcessor', 'parseTrueNumberOnly', 'numParseOptions', 'stopNodes', 'alwaysCreateTextNode'];
  xmlstr2xmlnode.props = props$2;
  /**
   * Trim -> valueProcessor -> parse value
   * @param {string} tagName
   * @param {string} val
   * @param {object} options
   */

  function processTagValue(tagName, val, options) {
    if (val) {
      if (options.trimValues) {
        val = val.trim();
      }

      val = options.tagValueProcessor(val, tagName);
      val = parseValue(val, options.parseNodeValue, options.numParseOptions);
    }

    return val;
  }

  function resolveNameSpace(tagname, options) {
    if (options.ignoreNameSpace) {
      const tags = tagname.split(':');
      const prefix = tagname.charAt(0) === '/' ? '/' : '';

      if (tags[0] === 'xmlns') {
        return '';
      }

      if (tags.length === 2) {
        tagname = prefix + tags[1];
      }
    }

    return tagname;
  }

  function parseValue(val, shouldParse, options) {
    if (shouldParse && typeof val === 'string') {
      //console.log(options)
      const newval = val.trim();
      if (newval === 'true') return true;else if (newval === 'false') return false;else return toNumber(val, options);
    } else {
      if (util$2.isExist(val)) {
        return val;
      } else {
        return '';
      }
    }
  } //TODO: change regex to capture NS
  //const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");


  const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])(.*?)\\3)?', 'g');

  function buildAttributesMap(attrStr, options) {
    if (!options.ignoreAttributes && typeof attrStr === 'string') {
      attrStr = attrStr.replace(/\r?\n/g, ' '); //attrStr = attrStr || attrStr.trim();

      const matches = util$2.getAllMatches(attrStr, attrsRegx);
      const len = matches.length; //don't make it inline

      const attrs = {};

      for (let i = 0; i < len; i++) {
        const attrName = resolveNameSpace(matches[i][1], options);

        if (attrName.length) {
          if (matches[i][4] !== undefined) {
            if (options.trimValues) {
              matches[i][4] = matches[i][4].trim();
            }

            matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);
            attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.numParseOptions);
          } else if (options.allowBooleanAttributes) {
            attrs[options.attributeNamePrefix + attrName] = true;
          }
        }
      }

      if (!Object.keys(attrs).length) {
        return;
      }

      if (options.attrNodeName) {
        const attrCollection = {};
        attrCollection[options.attrNodeName] = attrs;
        return attrCollection;
      }

      return attrs;
    }
  }

  const getTraversalObj = function (xmlData, options) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    options = buildOptions$3(options, defaultOptions$2, props$2);
    const xmlObj = new xmlNode('!xml');
    let currentNode = xmlObj;
    let textData = ""; //function match(xmlData){

    for (let i = 0; i < xmlData.length; i++) {
      const ch = xmlData[i];

      if (ch === '<') {
        if (xmlData[i + 1] === '/') {
          //Closing Tag
          const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
          let tagName = xmlData.substring(i + 2, closeIndex).trim();

          if (options.ignoreNameSpace) {
            const colonIndex = tagName.indexOf(":");

            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
            }
          }
          /* if (currentNode.parent) {
            currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);
          } */


          if (currentNode) {
            if (currentNode.val) {
              currentNode.val = util$2.getValue(currentNode.val) + '' + processTagValue(tagName, textData, options);
            } else {
              currentNode.val = processTagValue(tagName, textData, options);
            }
          }

          if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {
            currentNode.child = [];

            if (currentNode.attrsMap == undefined) {
              currentNode.attrsMap = {};
            }

            currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1);
          }

          currentNode = currentNode.parent;
          textData = "";
          i = closeIndex;
        } else if (xmlData[i + 1] === '?') {
          i = findClosingIndex(xmlData, "?>", i, "Pi Tag is not closed.");
        } else if (xmlData.substr(i + 1, 3) === '!--') {
          i = findClosingIndex(xmlData, "-->", i, "Comment is not closed.");
        } else if (xmlData.substr(i + 1, 2) === '!D') {
          const closeIndex = findClosingIndex(xmlData, ">", i, "DOCTYPE is not closed.");
          const tagExp = xmlData.substring(i, closeIndex);

          if (tagExp.indexOf("[") >= 0) {
            i = xmlData.indexOf("]>", i) + 1;
          } else {
            i = closeIndex;
          }
        } else if (xmlData.substr(i + 1, 2) === '![') {
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
          const tagExp = xmlData.substring(i + 9, closeIndex); //considerations
          //1. CDATA will always have parent node
          //2. A tag with CDATA is not a leaf node so it's value would be string type.

          if (textData) {
            currentNode.val = util$2.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);
            textData = "";
          }

          if (options.cdataTagName) {
            //add cdata node
            const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);
            currentNode.addChild(childNode); //for backtracking

            currentNode.val = util$2.getValue(currentNode.val) + options.cdataPositionChar; //add rest value to parent node

            if (tagExp) {
              childNode.val = tagExp;
            }
          } else {
            currentNode.val = (currentNode.val || '') + (tagExp || '');
          }

          i = closeIndex + 2;
        } else {
          //Opening tag
          const result = closingIndexForOpeningTag(xmlData, i + 1);
          let tagExp = result.data;
          const closeIndex = result.index;
          const separatorIndex = tagExp.indexOf(" ");
          let tagName = tagExp;
          let shouldBuildAttributesMap = true;

          if (separatorIndex !== -1) {
            tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, '');
            tagExp = tagExp.substr(separatorIndex + 1);
          }

          if (options.ignoreNameSpace) {
            const colonIndex = tagName.indexOf(":");

            if (colonIndex !== -1) {
              tagName = tagName.substr(colonIndex + 1);
              shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);
            }
          } //save text to parent node


          if (currentNode && textData) {
            if (currentNode.tagname !== '!xml') {
              currentNode.val = util$2.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData, options);
            }
          }

          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            //selfClosing tag
            if (tagName[tagName.length - 1] === "/") {
              //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }

            const childNode = new xmlNode(tagName, currentNode, '');

            if (tagName !== tagExp) {
              childNode.attrsMap = buildAttributesMap(tagExp, options);
            }

            currentNode.addChild(childNode);
          } else {
            //opening tag
            const childNode = new xmlNode(tagName, currentNode);

            if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {
              childNode.startIndex = closeIndex;
            }

            if (tagName !== tagExp && shouldBuildAttributesMap) {
              childNode.attrsMap = buildAttributesMap(tagExp, options);
            }

            currentNode.addChild(childNode);
            currentNode = childNode;
          }

          textData = "";
          i = closeIndex;
        }
      } else {
        textData += xmlData[i];
      }
    }

    return xmlObj;
  };

  function closingIndexForOpeningTag(data, i) {
    let attrBoundary;
    let tagExp = "";

    for (let index = i; index < data.length; index++) {
      let ch = data[index];

      if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = ""; //reset
      } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
      } else if (ch === '>') {
        return {
          data: tagExp,
          index: index
        };
      } else if (ch === '\t') {
        ch = " ";
      }

      tagExp += ch;
    }
  }

  function findClosingIndex(xmlData, str, i, errMsg) {
    const closingIndex = xmlData.indexOf(str, i);

    if (closingIndex === -1) {
      throw new Error(errMsg);
    } else {
      return closingIndex + str.length - 1;
    }
  }

  xmlstr2xmlnode.getTraversalObj = getTraversalObj;

  var validator = {};

  const util$1 = util$4;

  const defaultOptions$1 = {
    allowBooleanAttributes: false //A tag can have attributes without any value

  };
  const props$1 = ['allowBooleanAttributes']; //const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");

  validator.validate = function (xmlData, options) {
    options = util$1.buildOptions(options, defaultOptions$1, props$1); //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
    //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
    //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE

    const tags = [];
    let tagFound = false; //indicates that the root tag has been closed (aka. depth 0 has been reached)

    let reachedRoot = false;

    if (xmlData[0] === '\ufeff') {
      // check for byte order mark (BOM)
      xmlData = xmlData.substr(1);
    }

    for (let i = 0; i < xmlData.length; i++) {
      if (xmlData[i] === '<' && xmlData[i + 1] === '?') {
        i += 2;
        i = readPI(xmlData, i);
        if (i.err) return i;
      } else if (xmlData[i] === '<') {
        //starting of tag
        //read until you reach to '>' avoiding any '>' in attribute value
        let tagStartPos = i;
        i++;

        if (xmlData[i] === '!') {
          i = readCommentAndCDATA(xmlData, i);
          continue;
        } else {
          let closingTag = false;

          if (xmlData[i] === '/') {
            //closing tag
            closingTag = true;
            i++;
          } //read tagname


          let tagName = '';

          for (; i < xmlData.length && xmlData[i] !== '>' && xmlData[i] !== ' ' && xmlData[i] !== '\t' && xmlData[i] !== '\n' && xmlData[i] !== '\r'; i++) {
            tagName += xmlData[i];
          }

          tagName = tagName.trim(); //console.log(tagName);

          if (tagName[tagName.length - 1] === '/') {
            //self closing tag without attributes
            tagName = tagName.substring(0, tagName.length - 1); //continue;

            i--;
          }

          if (!validateTagName(tagName)) {
            let msg;

            if (tagName.trim().length === 0) {
              msg = "Invalid space after '<'.";
            } else {
              msg = "Tag '" + tagName + "' is an invalid name.";
            }

            return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
          }

          const result = readAttributeStr(xmlData, i);

          if (result === false) {
            return getErrorObject('InvalidAttr', "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
          }

          let attrStr = result.value;
          i = result.index;

          if (attrStr[attrStr.length - 1] === '/') {
            //self closing tag
            const attrStrStart = i - attrStr.length;
            attrStr = attrStr.substring(0, attrStr.length - 1);
            const isValid = validateAttributeString(attrStr, options);

            if (isValid === true) {
              tagFound = true; //continue; //text may presents after self closing tag
            } else {
              //the result from the nested function returns the position of the error within the attribute
              //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
              //this gives us the absolute index in the entire xml, which we can use to find the line at last
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
            }
          } else if (closingTag) {
            if (!result.tagClosed) {
              return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
            } else if (attrStr.trim().length > 0) {
              return getErrorObject('InvalidTag', "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
            } else {
              const otg = tags.pop();

              if (tagName !== otg.tagName) {
                let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
                return getErrorObject('InvalidTag', "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.", getLineNumberForPosition(xmlData, tagStartPos));
              } //when there are no more tags, we reached the root level.


              if (tags.length == 0) {
                reachedRoot = true;
              }
            }
          } else {
            const isValid = validateAttributeString(attrStr, options);

            if (isValid !== true) {
              //the result from the nested function returns the position of the error within the attribute
              //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
              //this gives us the absolute index in the entire xml, which we can use to find the line at last
              return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
            } //if the root level has been reached before ...


            if (reachedRoot === true) {
              return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
            } else {
              tags.push({
                tagName,
                tagStartPos
              });
            }

            tagFound = true;
          } //skip tag text value
          //It may include comments and CDATA value


          for (i++; i < xmlData.length; i++) {
            if (xmlData[i] === '<') {
              if (xmlData[i + 1] === '!') {
                //comment or CADATA
                i++;
                i = readCommentAndCDATA(xmlData, i);
                continue;
              } else if (xmlData[i + 1] === '?') {
                i = readPI(xmlData, ++i);
                if (i.err) return i;
              } else {
                break;
              }
            } else if (xmlData[i] === '&') {
              const afterAmp = validateAmpersand(xmlData, i);
              if (afterAmp == -1) return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
              i = afterAmp;
            }
          } //end of reading tag text value


          if (xmlData[i] === '<') {
            i--;
          }
        }
      } else {
        if (xmlData[i] === ' ' || xmlData[i] === '\t' || xmlData[i] === '\n' || xmlData[i] === '\r') {
          continue;
        }

        return getErrorObject('InvalidChar', "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
      }
    }

    if (!tagFound) {
      return getErrorObject('InvalidXml', 'Start tag expected.', 1);
    } else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
    } else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '" + JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '') + "' found.", {
        line: 1,
        col: 1
      });
    }

    return true;
  };
  /**
   * Read Processing insstructions and skip
   * @param {*} xmlData
   * @param {*} i
   */


  function readPI(xmlData, i) {
    const start = i;

    for (; i < xmlData.length; i++) {
      if (xmlData[i] == '?' || xmlData[i] == ' ') {
        //tagname
        const tagname = xmlData.substr(start, i - start);

        if (i > 5 && tagname === 'xml') {
          return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
        } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
          //check if valid attribut string
          i++;
          break;
        } else {
          continue;
        }
      }
    }

    return i;
  }

  function readCommentAndCDATA(xmlData, i) {
    if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
      //comment
      for (i += 3; i < xmlData.length; i++) {
        if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
          i += 2;
          break;
        }
      }
    } else if (xmlData.length > i + 8 && xmlData[i + 1] === 'D' && xmlData[i + 2] === 'O' && xmlData[i + 3] === 'C' && xmlData[i + 4] === 'T' && xmlData[i + 5] === 'Y' && xmlData[i + 6] === 'P' && xmlData[i + 7] === 'E') {
      let angleBracketsCount = 1;

      for (i += 8; i < xmlData.length; i++) {
        if (xmlData[i] === '<') {
          angleBracketsCount++;
        } else if (xmlData[i] === '>') {
          angleBracketsCount--;

          if (angleBracketsCount === 0) {
            break;
          }
        }
      }
    } else if (xmlData.length > i + 9 && xmlData[i + 1] === '[' && xmlData[i + 2] === 'C' && xmlData[i + 3] === 'D' && xmlData[i + 4] === 'A' && xmlData[i + 5] === 'T' && xmlData[i + 6] === 'A' && xmlData[i + 7] === '[') {
      for (i += 8; i < xmlData.length; i++) {
        if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
          i += 2;
          break;
        }
      }
    }

    return i;
  }

  const doubleQuote = '"';
  const singleQuote = "'";
  /**
   * Keep reading xmlData until '<' is found outside the attribute value.
   * @param {string} xmlData
   * @param {number} i
   */

  function readAttributeStr(xmlData, i) {
    let attrStr = '';
    let startChar = '';
    let tagClosed = false;

    for (; i < xmlData.length; i++) {
      if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
        if (startChar === '') {
          startChar = xmlData[i];
        } else if (startChar !== xmlData[i]) ; else {
          startChar = '';
        }
      } else if (xmlData[i] === '>') {
        if (startChar === '') {
          tagClosed = true;
          break;
        }
      }

      attrStr += xmlData[i];
    }

    if (startChar !== '') {
      return false;
    }

    return {
      value: attrStr,
      index: i,
      tagClosed: tagClosed
    };
  }
  /**
   * Select all the attributes whether valid or invalid.
   */


  const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g'); //attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

  function validateAttributeString(attrStr, options) {
    //console.log("start:"+attrStr+":end");
    //if(attrStr.trim().length === 0) return true; //empty string
    const matches = util$1.getAllMatches(attrStr, validAttrStrRegxp);
    const attrNames = {};

    for (let i = 0; i < matches.length; i++) {
      if (matches[i][1].length === 0) {
        //nospace before attribute name: a="sd"b="saf"
        return getErrorObject('InvalidAttr', "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
      } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
        //independent attribute: ab
        return getErrorObject('InvalidAttr', "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
      }
      /* else if(matches[i][6] === undefined){//attribute without value: ab=
                      return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                  } */


      const attrName = matches[i][2];

      if (!validateAttrName(attrName)) {
        return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
      }

      if (!attrNames.hasOwnProperty(attrName)) {
        //check for duplicate attribute.
        attrNames[attrName] = 1;
      } else {
        return getErrorObject('InvalidAttr', "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
      }
    }

    return true;
  }

  function validateNumberAmpersand(xmlData, i) {
    let re = /\d/;

    if (xmlData[i] === 'x') {
      i++;
      re = /[\da-fA-F]/;
    }

    for (; i < xmlData.length; i++) {
      if (xmlData[i] === ';') return i;
      if (!xmlData[i].match(re)) break;
    }

    return -1;
  }

  function validateAmpersand(xmlData, i) {
    // https://www.w3.org/TR/xml/#dt-charref
    i++;
    if (xmlData[i] === ';') return -1;

    if (xmlData[i] === '#') {
      i++;
      return validateNumberAmpersand(xmlData, i);
    }

    let count = 0;

    for (; i < xmlData.length; i++, count++) {
      if (xmlData[i].match(/\w/) && count < 20) continue;
      if (xmlData[i] === ';') break;
      return -1;
    }

    return i;
  }

  function getErrorObject(code, message, lineNumber) {
    return {
      err: {
        code: code,
        msg: message,
        line: lineNumber.line || lineNumber,
        col: lineNumber.col
      }
    };
  }

  function validateAttrName(attrName) {
    return util$1.isName(attrName);
  } // const startsWithXML = /^xml/i;


  function validateTagName(tagname) {
    return util$1.isName(tagname)
    /* && !tagname.match(startsWithXML) */
    ;
  } //this function returns the line number for the character at the given index


  function getLineNumberForPosition(xmlData, index) {
    const lines = xmlData.substring(0, index).split(/\r?\n/);
    return {
      line: lines.length,
      // column number is last line's length + 1, because column numbering starts at 1:
      col: lines[lines.length - 1].length + 1
    };
  } //this function returns the position of the first character of match within attrStr


  function getPositionFromMatch(match) {
    return match.startIndex + match[1].length;
  }

  var nimndata = {};

  const char$1 = function (a) {
    return String.fromCharCode(a);
  };

  const chars = {
    nilChar: char$1(176),
    missingChar: char$1(201),
    nilPremitive: char$1(175),
    missingPremitive: char$1(200),
    emptyChar: char$1(178),
    emptyValue: char$1(177),
    //empty Premitive
    boundryChar: char$1(179),
    objStart: char$1(198),
    arrStart: char$1(204),
    arrayEnd: char$1(185)
  };
  const charsArr = [chars.nilChar, chars.nilPremitive, chars.missingChar, chars.missingPremitive, chars.boundryChar, chars.emptyChar, chars.emptyValue, chars.arrayEnd, chars.objStart, chars.arrStart];

  const _e = function (node, e_schema, options) {
    if (typeof e_schema === 'string') {
      //premitive
      if (node && node[0] && node[0].val !== undefined) {
        return getValue$2(node[0].val);
      } else {
        return getValue$2(node);
      }
    } else {
      const hasValidData = hasData(node);

      if (hasValidData === true) {
        let str = '';

        if (Array.isArray(e_schema)) {
          //attributes can't be repeated. hence check in children tags only
          str += chars.arrStart;
          const itemSchema = e_schema[0]; //const itemSchemaType = itemSchema;

          const arr_len = node.length;

          if (typeof itemSchema === 'string') {
            for (let arr_i = 0; arr_i < arr_len; arr_i++) {
              const r = getValue$2(node[arr_i].val);
              str = processValue(str, r);
            }
          } else {
            for (let arr_i = 0; arr_i < arr_len; arr_i++) {
              const r = _e(node[arr_i], itemSchema, options);

              str = processValue(str, r);
            }
          }

          str += chars.arrayEnd; //indicates that next item is not array item
        } else {
          //object
          str += chars.objStart;
          const keys = Object.keys(e_schema);

          if (Array.isArray(node)) {
            node = node[0];
          }

          for (let i in keys) {
            const key = keys[i]; //a property defined in schema can be present either in attrsMap or children tags
            //options.textNodeName will not present in both maps, take it's value from val
            //options.attrNodeName will be present in attrsMap

            let r;

            if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {
              r = _e(node.attrsMap[key], e_schema[key], options);
            } else if (key === options.textNodeName) {
              r = _e(node.val, e_schema[key], options);
            } else {
              r = _e(node.child[key], e_schema[key], options);
            }

            str = processValue(str, r);
          }
        }

        return str;
      } else {
        return hasValidData;
      }
    }
  };

  const getValue$2 = function (a
  /*, type*/
  ) {
    switch (a) {
      case undefined:
        return chars.missingPremitive;

      case null:
        return chars.nilPremitive;

      case '':
        return chars.emptyValue;

      default:
        return a;
    }
  };

  const processValue = function (str, r) {
    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {
      str += chars.boundryChar;
    }

    return str + r;
  };

  const isAppChar = function (ch) {
    return charsArr.indexOf(ch) !== -1;
  };

  function hasData(jObj) {
    if (jObj === undefined) {
      return chars.missingChar;
    } else if (jObj === null) {
      return chars.nilChar;
    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {
      return chars.emptyChar;
    } else {
      return true;
    }
  }

  const x2j$1 = xmlstr2xmlnode;

  const buildOptions$2 = util$4.buildOptions;

  const convert2nimn = function (node, e_schema, options) {
    options = buildOptions$2(options, x2j$1.defaultOptions, x2j$1.props);
    return _e(node, e_schema, options);
  };

  nimndata.convert2nimn = convert2nimn;

  var node2json_str = {};

  const util = util$4;

  const buildOptions$1 = util$4.buildOptions;

  const x2j = xmlstr2xmlnode; //TODO: do it later


  const convertToJsonString = function (node, options) {
    options = buildOptions$1(options, x2j.defaultOptions, x2j.props);
    options.indentBy = options.indentBy || '';
    return _cToJsonStr(node, options);
  };

  const _cToJsonStr = function (node, options, level) {
    let jObj = '{'; //traver through all the children

    const keys = Object.keys(node.child);

    for (let index = 0; index < keys.length; index++) {
      const tagname = keys[index];

      if (node.child[tagname] && node.child[tagname].length > 1) {
        jObj += '"' + tagname + '" : [ ';

        for (let tag in node.child[tagname]) {
          jObj += _cToJsonStr(node.child[tagname][tag], options) + ' , ';
        }

        jObj = jObj.substr(0, jObj.length - 1) + ' ] '; //remove extra comma in last
      } else {
        jObj += '"' + tagname + '" : ' + _cToJsonStr(node.child[tagname][0], options) + ' ,';
      }
    }

    util.merge(jObj, node.attrsMap); //add attrsMap as new children

    if (util.isEmptyObject(jObj)) {
      return util.isExist(node.val) ? node.val : '';
    } else {
      if (util.isExist(node.val)) {
        if (!(typeof node.val === 'string' && (node.val === '' || node.val === options.cdataPositionChar))) {
          jObj += '"' + options.textNodeName + '" : ' + stringval(node.val);
        }
      }
    } //add value


    if (jObj[jObj.length - 1] === ',') {
      jObj = jObj.substr(0, jObj.length - 2);
    }

    return jObj + '}';
  };

  function stringval(v) {
    if (v === true || v === false || !isNaN(v)) {
      return v;
    } else {
      return '"' + v + '"';
    }
  }

  node2json_str.convertToJsonString = convertToJsonString;

  const buildOptions = util$4.buildOptions;

  const defaultOptions = {
    attributeNamePrefix: '@_',
    attrNodeName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    cdataTagName: false,
    cdataPositionChar: '\\c',
    format: false,
    indentBy: '  ',
    supressEmptyNode: false,
    tagValueProcessor: function (a) {
      return a;
    },
    attrValueProcessor: function (a) {
      return a;
    }
  };
  const props = ['attributeNamePrefix', 'attrNodeName', 'textNodeName', 'ignoreAttributes', 'cdataTagName', 'cdataPositionChar', 'format', 'indentBy', 'supressEmptyNode', 'tagValueProcessor', 'attrValueProcessor', 'rootNodeName' //when array as root
  ];

  function Parser(options) {
    this.options = buildOptions(options, defaultOptions, props);

    if (this.options.ignoreAttributes || this.options.attrNodeName) {
      this.isAttribute = function
        /*a*/
      () {
        return false;
      };
    } else {
      this.attrPrefixLen = this.options.attributeNamePrefix.length;
      this.isAttribute = isAttribute;
    }

    if (this.options.cdataTagName) {
      this.isCDATA = isCDATA;
    } else {
      this.isCDATA = function
        /*a*/
      () {
        return false;
      };
    }

    this.replaceCDATAstr = replaceCDATAstr;
    this.replaceCDATAarr = replaceCDATAarr;
    this.processTextOrObjNode = processTextOrObjNode;

    if (this.options.format) {
      this.indentate = indentate;
      this.tagEndChar = '>\n';
      this.newLine = '\n';
    } else {
      this.indentate = function () {
        return '';
      };

      this.tagEndChar = '>';
      this.newLine = '';
    }

    if (this.options.supressEmptyNode) {
      this.buildTextNode = buildEmptyTextNode;
      this.buildObjNode = buildEmptyObjNode;
    } else {
      this.buildTextNode = buildTextValNode;
      this.buildObjNode = buildObjectNode;
    }

    this.buildTextValNode = buildTextValNode;
    this.buildObjectNode = buildObjectNode;
  }

  Parser.prototype.parse = function (jObj) {
    if (Array.isArray(jObj) && this.options.rootNodeName && this.options.rootNodeName.length > 1) {
      jObj = {
        [this.options.rootNodeName]: jObj
      };
    }

    return this.j2x(jObj, 0).val;
  };

  Parser.prototype.j2x = function (jObj, level) {
    let attrStr = '';
    let val = '';

    for (let key in jObj) {
      if (typeof jObj[key] === 'undefined') ; else if (jObj[key] === null) {
        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      } else if (jObj[key] instanceof Date) {
        val += this.buildTextNode(jObj[key], key, '', level);
      } else if (typeof jObj[key] !== 'object') {
        //premitive type
        const attr = this.isAttribute(key);

        if (attr) {
          attrStr += ' ' + attr + '="' + this.options.attrValueProcessor('' + jObj[key]) + '"';
        } else if (this.isCDATA(key)) {
          if (jObj[this.options.textNodeName]) {
            val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);
          } else {
            val += this.replaceCDATAstr('', jObj[key]);
          }
        } else {
          //tag value
          if (key === this.options.textNodeName) {
            if (jObj[this.options.cdataTagName]) ; else {
              val += this.options.tagValueProcessor('' + jObj[key]);
            }
          } else {
            val += this.buildTextNode(jObj[key], key, '', level);
          }
        }
      } else if (Array.isArray(jObj[key])) {
        //repeated nodes
        if (this.isCDATA(key)) {
          val += this.indentate(level);

          if (jObj[this.options.textNodeName]) {
            val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);
          } else {
            val += this.replaceCDATAarr('', jObj[key]);
          }
        } else {
          //nested nodes
          const arrLen = jObj[key].length;

          for (let j = 0; j < arrLen; j++) {
            const item = jObj[key][j];

            if (typeof item === 'undefined') ; else if (item === null) {
              val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
            } else if (typeof item === 'object') {
              val += this.processTextOrObjNode(item, key, level);
            } else {
              val += this.buildTextNode(item, key, '', level);
            }
          }
        }
      } else {
        //nested node
        if (this.options.attrNodeName && key === this.options.attrNodeName) {
          const Ks = Object.keys(jObj[key]);
          const L = Ks.length;

          for (let j = 0; j < L; j++) {
            attrStr += ' ' + Ks[j] + '="' + this.options.attrValueProcessor('' + jObj[key][Ks[j]]) + '"';
          }
        } else {
          val += this.processTextOrObjNode(jObj[key], key, level);
        }
      }
    }

    return {
      attrStr: attrStr,
      val: val
    };
  };

  function processTextOrObjNode(object, key, level) {
    const result = this.j2x(object, level + 1);

    if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
      return this.buildTextNode(result.val, key, result.attrStr, level);
    } else {
      return this.buildObjNode(result.val, key, result.attrStr, level);
    }
  }

  function replaceCDATAstr(str, cdata) {
    str = this.options.tagValueProcessor('' + str);

    if (this.options.cdataPositionChar === '' || str === '') {
      return str + '<![CDATA[' + cdata + ']]' + this.tagEndChar;
    } else {
      return str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata + ']]' + this.tagEndChar);
    }
  }

  function replaceCDATAarr(str, cdata) {
    str = this.options.tagValueProcessor('' + str);

    if (this.options.cdataPositionChar === '' || str === '') {
      return str + '<![CDATA[' + cdata.join(']]><![CDATA[') + ']]' + this.tagEndChar;
    } else {
      for (let v in cdata) {
        str = str.replace(this.options.cdataPositionChar, '<![CDATA[' + cdata[v] + ']]>');
      }

      return str + this.newLine;
    }
  }

  function buildObjectNode(val, key, attrStr, level) {
    if (attrStr && val.indexOf('<') === -1) {
      return this.indentate(level) + '<' + key + attrStr + '>' + val + //+ this.newLine
      // + this.indentate(level)
      '</' + key + this.tagEndChar;
    } else {
      return this.indentate(level) + '<' + key + attrStr + this.tagEndChar + val + //+ this.newLine
      this.indentate(level) + '</' + key + this.tagEndChar;
    }
  }

  function buildEmptyObjNode(val, key, attrStr, level) {
    if (val !== '') {
      return this.buildObjectNode(val, key, attrStr, level);
    } else {
      return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar; //+ this.newLine
    }
  }

  function buildTextValNode(val, key, attrStr, level) {
    return this.indentate(level) + '<' + key + attrStr + '>' + this.options.tagValueProcessor(val) + '</' + key + this.tagEndChar;
  }

  function buildEmptyTextNode(val, key, attrStr, level) {
    if (val !== '') {
      return this.buildTextValNode(val, key, attrStr, level);
    } else {
      return this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
    }
  }

  function indentate(level) {
    return this.options.indentBy.repeat(level);
  }

  function isAttribute(name
  /*, options*/
  ) {
    if (name.startsWith(this.options.attributeNamePrefix)) {
      return name.substr(this.attrPrefixLen);
    } else {
      return false;
    }
  }

  function isCDATA(name) {
    return name === this.options.cdataTagName;
  } //formatting
  //indentation
  //\n after each closing or self closing tag


  var json2xml = Parser;

  (function (exports) {

  const nodeToJson = node2json;

  const xmlToNodeobj = xmlstr2xmlnode;

  const x2xmlnode = xmlstr2xmlnode;

  const buildOptions = util$4.buildOptions;

  const validator$1 = validator;

  exports.parse = function (xmlData, givenOptions = {}, validationOption) {
    if (validationOption) {
      if (validationOption === true) validationOption = {};
      const result = validator$1.validate(xmlData, validationOption);

      if (result !== true) {
        throw Error(result.err.msg);
      }
    }

    if (givenOptions.parseTrueNumberOnly && givenOptions.parseNodeValue !== false && !givenOptions.numParseOptions) {
      givenOptions.numParseOptions = {
        leadingZeros: false
      };
    }

    let options = buildOptions(givenOptions, x2xmlnode.defaultOptions, x2xmlnode.props);
    const traversableObj = xmlToNodeobj.getTraversalObj(xmlData, options); //print(traversableObj, "  ");

    return nodeToJson.convertToJson(traversableObj, options);
  };

  exports.convertTonimn = nimndata.convert2nimn;
  exports.getTraversalObj = xmlToNodeobj.getTraversalObj;
  exports.convertToJson = nodeToJson.convertToJson;
  exports.convertToJsonString = node2json_str.convertToJsonString;
  exports.validate = validator$1.validate;
  exports.j2xParser = json2xml;

  exports.parseToNimn = function (xmlData, schema, options) {
    return exports.convertTonimn(exports.getTraversalObj(xmlData, options), schema, options);
  };
  }(parser));

  function modelsToLookup(models) {
    const lookup = {};
    models.forEach(model => {
      modelsToLookupModelParser(model, lookup);
    });
    return lookup;
  }

  function modelsToLookupModelParser(model, lookup) {
    if ('craftercms' in model) {
      if (model.craftercms.id === null) {
        return;
      }

      lookup[model.craftercms.id] = model;
    }

    Object.entries(model).forEach(([prop, value]) => {
      if (prop.endsWith('_o')) {
        const collection = value;
        forEach(collection, item => {
          if ('craftercms' in item) {
            if (item.craftercms.id === null) {
              return 'continue';
            }

            lookup[item.craftercms.id] = item;
          }

          modelsToLookupModelParser(item, lookup);
        });
      }
    });
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  // TODO: Notice
  // Not so sure about this assumption. Maybe best to just leave it up to the consumer
  // app to set the crafter URL via `crafterConf` if it wants something different?

  typeof window !== 'undefined' && crafterConf.getConfig().baseUrl === '' && crafterConf.configure({
    baseUrl: window.location.hostname === 'localhost' ? 'http://localhost:8080' : window.location.origin,
    site: api.get('crafterSite')
  }); // }

  const operations$ = new Subject();
  const operationsObs$ = operations$.asObservable();
  const modelHierarchyMap = {
    /* [id]: [id, id, id] */
  };
  let requestedPaths = {};
  const paths$ = new BehaviorSubject({
    /* 'path': 'modelId' */
  });
  const models$ = new BehaviorSubject({
    /* 'modelId': { ...modelData } */
  });
  const contentTypes$ = new BehaviorSubject({
    /* 'contentTypeId': { ...contentTypeData } */
  }); // Share operator makes the behaviour subject's behaviour go away. New subscribers
  // don't receive the latest value as soon as they subscribe. Would need to multicast
  // to be able to continue using share

  const notEmpty = objects => Object.keys(objects).length > 0;

  const modelsObs$ = models$.pipe(filter$1(notEmpty));
  const contentTypesObs$ = contentTypes$.pipe(filter$1(notEmpty));
  const pathsObs$ = paths$.pipe(filter$1(notEmpty));

  function model$(modelId) {
    return models$.pipe(pluck(modelId), filter$1(model => Boolean(model)));
  }
  function hasCachedModel(modelId) {
    return Boolean(models$.value[modelId]);
  }
  function getCachedModel(modelId) {
    return models$.value[modelId];
  }
  function getCachedModels() {
    return models$.value;
  }
  function fetchById(id) {
    return search(createQuery({
      query: {
        bool: {
          filter: [{
            bool: {
              should: {
                multi_match: {
                  query: id,
                  fields: ['*objectId']
                }
              }
            }
          }]
        }
      }
    }), // TODO: Remove hardcoded url
    crafterConf.getConfig()).pipe( // @ts-ignore - TODO: Upgrade SDK to rxjs@7
    tap(({
      total
    }) => total === 0 && console.log(`[ContentController/fetchById] Model with id ${id} not found.`)), map(({
      hits
    }) => hits.map(({
      _source
    }) => parseDescriptor(preParseSearchResults(_source)))), map(modelsToLookup));
  }
  function byPathFetchIfNotLoaded(path) {
    if (nou(path)) {
      return of(null);
    } else if (requestedPaths[path]) {
      return paths$.pipe(filter$1(paths => Boolean(paths[path])), pluck(path), map(modelId => models$.value[modelId]));
    } else {
      requestedPaths[path] = true;
      return fetchByPath(path).pipe(pluck('model'));
    }
  }
  function getContentInstanceByPath(path) {
    let modelId = paths$.value[path];
    return models$.value[modelId];
  }
  function isInheritedField(modelId, fieldId) {
    var _getCachedModel$craft;

    return !!((_getCachedModel$craft = getCachedModel(modelId).craftercms.sourceMap) !== null && _getCachedModel$craft !== void 0 && _getCachedModel$craft[fieldId]);
  }
  function getModelIdFromInheritedField(modelId, fieldId) {
    var _models$$value$modelI;

    const levelDescriptorPath = (_models$$value$modelI = models$.value[modelId].craftercms.sourceMap) === null || _models$$value$modelI === void 0 ? void 0 : _models$$value$modelI[fieldId];

    if (levelDescriptorPath) {
      return getContentInstanceByPath(levelDescriptorPath).craftercms.id;
    } else {
      return modelId;
    }
  }
  function fetchByPath(path) {
    return of('nothing').pipe(tap(() => post({
      type: 'FETCH_GUEST_MODEL',
      payload: {
        path
      }
    })), switchMap(() => fromTopic('FETCH_GUEST_MODEL_COMPLETE').pipe(pluck('payload'), filter$1(payload => payload.path === path), take(1))));
  }
  function flushRequestedPaths() {
    requestedPaths = {};
  } // endregion
  // region Content Types

  function hasCachedContentType(contentTypeId) {
    return Boolean(contentTypes$.value[contentTypeId]);
  }
  function getCachedContentType(contentTypeId) {
    return contentTypes$.value[contentTypeId];
  }
  function getCachedContentTypes() {
    return contentTypes$.value;
  } // endregion
  // region Operations
  // To propagate the update up the model tree for
  // reference based UI rendering libraries.

  function collectReferrers(modelId) {
    const models = getCachedModels();
    const parentModels = [];
    const modelsToUpdate = {};
    let currentID = getParentModelId(modelId, models, modelHierarchyMap);

    while (currentID) {
      parentModels.push(currentID);
      currentID = getParentModelId(currentID, models, modelHierarchyMap);
    }

    parentModels.forEach(id => modelsToUpdate[id] = { ...models[id]
    });
    return modelsToUpdate;
  }

  function updateHierarchyMapIndexesFromCollection(collection) {
    if (collection.length) {
      const isSimpleIndex = isSimple(modelHierarchyMap[collection[0]].parentContainerFieldIndex); // 1. Update item being sorted and items getting displaced because of that sort

      collection.forEach(isSimpleIndex ? (id, index) => {
        modelHierarchyMap[id].parentContainerFieldIndex = String(index);
      } : (id, index) => {
        const current = modelHierarchyMap[id].parentContainerFieldIndex;
        modelHierarchyMap[id].parentContainerFieldIndex = `${removeLastPiece(current)}.${index}`;
      });
    }
  }

  function updateHierarchyMapIndexesFromPosition(fieldId, model, currentIndex) {
    const {
      position,
      splitIndex,
      numericIndex
    } = getIndexMetaData(fieldId, model);

    if (numericIndex > currentIndex) {
      splitIndex[position] = (numericIndex - 1).toString();
    }

    model.parentContainerFieldIndex = splitIndex.join('.');
  }

  function getIndexMetaData(fieldId, model) {
    const position = model.parentContainerFieldPath.split('.').indexOf(isSimple(fieldId) ? fieldId : popPiece(fieldId));
    const index = model.parentContainerFieldIndex;
    const splitIndex = index.split('.');
    const numericIndex = Number(splitIndex[position]);
    return {
      position,
      splitIndex,
      numericIndex
    };
  }

  function deleteItemFromHierarchyMap(modelId) {
    modelHierarchyMap[modelId].children.forEach(_modelId => {
      deleteItemFromHierarchyMap(_modelId);
    });
    const index = modelHierarchyMap[modelHierarchyMap[modelId].parentId].children.indexOf(modelId);
    const children = [...modelHierarchyMap[modelHierarchyMap[modelId].parentId].children];
    modelHierarchyMap[modelHierarchyMap[modelId].parentId].children = children.slice(0, index).concat(children.slice(index + 1));
    delete modelHierarchyMap[modelId];
  }

  function updateField(modelId, fieldId, index, value$1) {
    const models = getCachedModels();
    const model = { ...models[modelId]
    };
    const parentModelId = getParentModelId(modelId, models, modelHierarchyMap);
    const modelsToUpdate = collectReferrers(modelId); // Using `index` being present as the factor to determine how to treat this update.
    // For now, fieldId should only ever have a `.` if the target zone is inside some collection
    // (node selector, repeat group) which would in turn mean there should be an `index` present.
    // In the future there may be some object type fields that would need this logic revisited
    // to account for a nested field without an index.

    if (nnou(index)) {
      // Assuming field/index should be asymmetric (one more piece of field than index). e.g.
      // - field = repeatingGroup_o.textField_s, index = 0
      // - field = repeatingGroup_o.nodeSelector_o.textField_s, index = 0.0
      const fieldPieces = fieldId.split('.');
      const indexPieces = `${index}`.split('.');
      let target = model;

      for (let i = 0, length = indexPieces.length; i < length; i++) {
        const fieldPiece = fieldPieces[i]; // repeatingGroup_o   textField_s

        const indexPiece = indexPieces[i]; // 0

        if (i + 1 === length) {
          // If it is the last iteration, create a new object: avoid mutating the original.
          // This should be an object (not an array): a repeat group item.
          target[fieldPiece][indexPiece] = { ...target[fieldPiece][indexPiece]
          };
        }

        target = target[fieldPiece][indexPiece];
      }

      const specificFieldId = fieldPieces.pop();
      target[specificFieldId] = value$1;
    } else {
      value(model, fieldId, value$1);
    } // Update the model cache


    models$.next({ ...models,
      ...modelsToUpdate,
      [modelId]: model
    }); // Post the update to studio to persist it

    post(updateFieldValueOperation({
      modelId,
      fieldId,
      index,
      value: value$1,
      parentModelId
    }));
    operations$.next({
      type: updateFieldValueOperation.type,
      args: {
        modelId: getModelIdFromInheritedField(modelId, fieldId),
        fieldId,
        index,
        value: value$1
      }
    });
  }
  function duplicateItem(modelId, fieldId, index) {
    const models = getCachedModels();
    post(duplicateItemOperation({
      modelId,
      fieldId,
      index,
      parentModelId: getParentModelId(modelId, models, modelHierarchyMap)
    }));
    operations$.next({
      type: duplicateItemOperation.type,
      args: {}
    });
  }
  function insertItem(modelId, fieldId, index, contentType) {
    const instance = {};
    const models = getCachedModels();
    Object.entries(contentType.fields[fieldId].fields).forEach(([id, field]) => {
      if (!systemProps.includes(field.id)) {
        instance[id] = getDefaultValue(field);
      }
    });
    post(insertItemOperation({
      modelId,
      fieldId,
      index,
      instance,
      parentModelId: getParentModelId(modelId, models, modelHierarchyMap)
    }));
    operations$.next({
      type: insertItemOperation.type,
      args: {}
    });
  }
  const systemProps = ['fileName', 'internalName'];
  function insertComponent(modelId, fieldId, targetIndex, contentType, shared = false) {
    var _modelHierarchyMap$mo;

    if (typeof contentType === 'string') {
      contentType = getCachedContentType(contentType);
    }

    const models = getCachedModels();
    const result = getCollection(models[modelId], fieldId, targetIndex).concat(); // Create Item
    // const now = new Date().toISOString();

    const instance = {
      craftercms: {
        id: v4$2(),
        path: null,
        label: `New ${contentType.name}`,
        contentTypeId: contentType.id,
        dateCreated: null,
        dateModified: null
      }
    };
    Object.entries(contentType.fields).forEach(([id, field]) => {
      if (!systemProps.includes(field.id)) {
        instance[id] = getDefaultValue(field);
      }
    }); // Insert in desired position

    result.splice(targetIndex, 0, instance.craftercms.id);
    const model = setCollection(models[modelId], fieldId, typeof targetIndex === 'string' ? removeLastPiece(targetIndex) : targetIndex, result);
    models$.next({ ...models,
      [instance.craftercms.id]: instance,
      [modelId]: model
    });
    modelHierarchyMap[instance.craftercms.id] = {
      children: [],
      modelId: instance.craftercms.id,
      parentContainerFieldIndex: isSimple(targetIndex) ? null : removeLastPiece(targetIndex),
      parentContainerFieldPath: isSimple(fieldId) ? fieldId : removeLastPiece(fieldId),
      parentId: modelId
    };
    (_modelHierarchyMap$mo = modelHierarchyMap[modelId]) === null || _modelHierarchyMap$mo === void 0 ? void 0 : _modelHierarchyMap$mo.children.push(instance.craftercms.id);
    updateHierarchyMapIndexesFromCollection(result);
    post(insertComponentOperation({
      modelId,
      fieldId,
      targetIndex,
      contentType,
      instance,
      parentModelId: getParentModelId(modelId, models, modelHierarchyMap),
      shared
    }));
    operations$.next({
      type: insertComponentOperation.type,
      args: {
        modelId,
        fieldId,
        targetIndex,
        contentType,
        shared,
        instance
      }
    });
  } // insertInstance(modelId: string, fieldId: string, targetIndex: number, instance: ContentInstance): void;
  // insertInstance(modelId: string, fieldId: string, targetIndex: string, instance: ContentInstance): void;

  function insertInstance(modelId, fieldId, targetIndex, instance) {
    var _modelHierarchyMap$mo2;

    const models = getCachedModels();
    const result = getCollection(models[modelId], fieldId, targetIndex).concat(); // Insert in desired position

    result.splice(targetIndex, 0, instance.craftercms.id);
    const model = setCollection(models[modelId], fieldId, typeof targetIndex === 'string' ? removeLastPiece(targetIndex) : targetIndex, result);
    models$.next({ ...models,
      [instance.craftercms.id]: instance,
      [modelId]: model
    });
    modelHierarchyMap[instance.craftercms.id] = {
      children: [],
      modelId: instance.craftercms.id,
      parentContainerFieldIndex: isSimple(targetIndex) ? null : removeLastPiece(targetIndex),
      parentContainerFieldPath: isSimple(fieldId) ? fieldId : removeLastPiece(fieldId),
      parentId: modelId
    };
    (_modelHierarchyMap$mo2 = modelHierarchyMap[modelId]) === null || _modelHierarchyMap$mo2 === void 0 ? void 0 : _modelHierarchyMap$mo2.children.push(instance.craftercms.id);
    updateHierarchyMapIndexesFromCollection(result);
    post(insertInstanceOperation({
      modelId,
      fieldId,
      targetIndex,
      instance,
      parentModelId: getParentModelId(modelId, models, modelHierarchyMap)
    }));
    operations$.next({
      type: insertInstanceOperation.type,
      args: {
        modelId,
        fieldId,
        targetIndex,
        instance
      }
    });
  }
  function insertGroup(modelId, fieldId, data) {}
  function sortUpItem(modelId, fieldId, index) {
    const currentIndexParsed = typeof index === 'number' ? index : parseInt(popPiece(index));

    if (currentIndexParsed !== 0) {
      const targetIndex = currentIndexParsed - 1;
      sortItem(modelId, fieldId, index, isSimple(index) ? targetIndex : `${removeLastPiece(index)}.${targetIndex}`);
    }
  }
  function sortDownItem(modelId, fieldId, index) {
    const models = getCachedModels();
    const currentIndexParsed = typeof index === 'number' ? index : parseInt(popPiece(index));
    const collection = getCollection(models[modelId], fieldId, index);

    if (currentIndexParsed < collection.length - 1) {
      const targetIndex = currentIndexParsed + 1;
      sortItem(modelId, fieldId, index, isSimple(index) ? targetIndex : `${removeLastPiece(index)}.${targetIndex}`);
    }
  }
  function sortItem(modelId, fieldId, currentIndex, targetIndex) {
    const models = getCachedModels();
    const currentIndexParsed = typeof currentIndex === 'number' ? currentIndex : parseInt(popPiece(currentIndex));
    const targetIndexParsed = typeof targetIndex === 'number' ? targetIndex : parseInt(popPiece(targetIndex));
    const collection = getCollection(models[modelId], fieldId, currentIndex);
    const result = getCollectionWithoutItemAtIndex(collection, currentIndexParsed); // Insert in desired position

    result.splice(targetIndexParsed, 0, collection[currentIndexParsed]);

    function updateModel(fieldId, model, currentIndex, targetIndex) {
      const {
        position,
        splitIndex,
        numericIndex
      } = getIndexMetaData(fieldId, model);

      if (numericIndex === currentIndex) {
        splitIndex[position] = targetIndex.toString();
      } else if (numericIndex === targetIndex) {
        splitIndex[position] = currentIndex.toString();
      } else if (targetIndex < currentIndex) {
        splitIndex[position] = (numericIndex + 1).toString();
      } else if (targetIndex > currentIndex) {
        splitIndex[position] = (numericIndex - 1).toString();
      }

      model.parentContainerFieldIndex = splitIndex.join('.');
    } // If it is a node selector, the hierarchy map must be updated.
    // Determine if it is a node selector or a repeat group. Node selectors are kept normalized so
    // a node selector collections will have strings on them (ids of the components they hold) vs
    // repeating groups that will have objects (the items per se).


    if (typeof result[0] === 'string') {
      updateHierarchyMapIndexesFromCollection(result);
    } else {
      modelHierarchyMap[modelId].children.forEach(_modelId => {
        var _modelHierarchyMap$_m;

        if ((_modelHierarchyMap$_m = modelHierarchyMap[_modelId].parentContainerFieldPath) !== null && _modelHierarchyMap$_m !== void 0 && _modelHierarchyMap$_m.startsWith(fieldId)) {
          updateModel(fieldId, modelHierarchyMap[_modelId], currentIndexParsed, targetIndexParsed);
        }
      });
    }

    const model = setCollection(models[modelId], fieldId, typeof currentIndex === 'string' ? removeLastPiece(currentIndex) : currentIndex, result);
    models$.next({ ...models,
      [modelId]: model
    });
    post(sortItemOperation({
      modelId,
      fieldId,
      currentIndex,
      targetIndex,
      parentModelId: getParentModelId(modelId, models, modelHierarchyMap)
    }));
    operations$.next({
      type: sortItemOperation.type,
      args: arguments
    });
  }
  function moveItem(originalModelId, originalFieldId, originalIndex, targetModelId, targetFieldId, targetIndex) {
    var _modelHierarchyMap$ta;

    const models = getCachedModels(); // Parse indexes to clear out dot notation for nested repeat/collection items.

    let originalIndexParsed = typeof originalIndex === 'number' ? originalIndex : parseInt(popPiece(originalIndex));
    let targetIndexParsed = typeof targetIndex === 'number' ? targetIndex : parseInt(popPiece(targetIndex));
    const symmetricOriginal = originalFieldId.split('.').length === `${originalIndex}`.split('.').length;
    const symmetricTarget = targetFieldId.split('.').length === `${targetIndex}`.split('.').length;

    if (!symmetricOriginal) {
      debugger;
    } else if (!symmetricTarget) {
      debugger;
    }

    const currentModel = models[originalModelId];
    const currentCollection = symmetricOriginal ? extractCollection(currentModel, originalFieldId, originalIndex) : extractCollectionItem(currentModel, originalFieldId, originalIndex);
    const item = currentCollection[originalIndexParsed]; // Remove item from original collection

    const currentResult = currentCollection.slice(0, originalIndexParsed).concat(currentCollection.slice(originalIndexParsed + 1));
    updateHierarchyMapIndexesFromCollection(currentResult);
    const targetModel = models[targetModelId];
    const targetCollection = symmetricTarget ? extractCollection(targetModel, targetFieldId, targetIndex) : extractCollectionItem(targetModel, targetFieldId, targetIndex); // Insert item in target collection @ the desired position

    const targetResult = targetCollection.slice(0);
    targetResult.splice(targetIndexParsed, 0, currentCollection[originalIndexParsed]);
    modelHierarchyMap[item] = { ...modelHierarchyMap[item],
      parentContainerFieldIndex: targetIndex,
      parentContainerFieldPath: targetFieldId,
      parentId: targetModelId
    };
    (_modelHierarchyMap$ta = modelHierarchyMap[targetModelId]) === null || _modelHierarchyMap$ta === void 0 ? void 0 : _modelHierarchyMap$ta.children.push(item);
    updateHierarchyMapIndexesFromCollection(targetResult);
    const newOriginalModel = { ...currentModel
    };
    const newTargetModel = originalModelId === targetModelId ? newOriginalModel : { ...targetModel
    }; // This should extract the object that contains the
    // collection so the collection can be replaced with the new one with the modifications.
    // This is for nested cases where there's something like `field_1.field_2`.

    const getFieldItem = (model, field, index) => {
      let item;

      if (symmetricOriginal) {
        item = extractCollectionItem(model, removeLastPiece(`${field}`), removeLastPiece(`${index}`));
      } else {
        debugger;
      }

      return item;
    };

    if (isSimple(originalFieldId)) {
      newOriginalModel[originalFieldId] = currentResult;
    } else {
      let item = getFieldItem(newOriginalModel, originalFieldId, originalIndex);
      item[popPiece(originalFieldId)] = currentResult;
    }

    if (isSimple(targetFieldId)) {
      newTargetModel[targetFieldId] = targetResult;
    } else {
      let item = getFieldItem(newTargetModel, targetFieldId, targetIndex);
      item[popPiece(targetFieldId)] = targetResult;
    }

    models$.next(originalModelId === targetModelId ? { ...models,
      [originalModelId]: newOriginalModel
    } : { ...models,
      [originalModelId]: newOriginalModel,
      [targetModelId]: newTargetModel
    });
    post(moveItemOperation({
      originalModelId,
      originalFieldId,
      originalIndex,
      targetModelId,
      targetFieldId,
      targetIndex,
      originalParentModelId: getParentModelId(originalModelId, models, modelHierarchyMap),
      targetParentModelId: getParentModelId(targetModelId, models, modelHierarchyMap)
    }));
    operations$.next({
      type: moveItemOperation.type,
      args: arguments
    });
  }
  function deleteItem(modelId, fieldId, index) {
    const isStringIndex = typeof index === 'string';
    const parsedIndex = parseInt(popPiece(`${index}`), 10);
    const models = getCachedModels();
    const collection = isStringIndex ? extractCollection(models[modelId], fieldId, index) : value(models[modelId], fieldId);
    const item = collection[parsedIndex];
    const result = collection.slice(0, parsedIndex).concat(collection.slice(parsedIndex + 1)); // Deleting item from modelHierarchyMap

    if (typeof collection[0] === 'string') {
      deleteItemFromHierarchyMap(item);
      updateHierarchyMapIndexesFromCollection(result);
    } else {
      const modelsToDelete = [];
      modelHierarchyMap[modelId].children.forEach(_modelId => {
        if (modelHierarchyMap[_modelId].parentContainerFieldPath.startsWith(fieldId)) {
          const {
            numericIndex
          } = getIndexMetaData(fieldId, modelHierarchyMap[_modelId]);

          if (numericIndex === parsedIndex) {
            modelsToDelete.push(_modelId);
          }

          updateHierarchyMapIndexesFromPosition(fieldId, modelHierarchyMap[_modelId], parsedIndex);
        }
      });
      modelsToDelete.forEach(id => {
        deleteItemFromHierarchyMap(id);
      });
    }

    const model = setCollection(models[modelId], fieldId, typeof index === 'string' ? removeLastPiece(index) : index, result);
    models$.next({ ...models,
      [modelId]: model
    });
    post(deleteItemOperation({
      modelId,
      fieldId,
      index,
      parentModelId: getParentModelId(modelId, models, modelHierarchyMap)
    }));
    operations$.next({
      type: deleteItemOperation.type,
      args: arguments,
      state: {
        item: collection[parsedIndex]
      }
    });
  } // endregion
  // Host sends over all content types upon Guest check in.

  fromTopic(contentTypesResponse.type).pipe(pluck('payload')).subscribe(({
    contentTypes
  }) => {
    contentTypes$.next(Array.isArray(contentTypes) ? createLookupTable(contentTypes) : contentTypes);
  });
  fromTopic('FETCH_GUEST_MODEL_COMPLETE').pipe(pluck('payload')).subscribe(({
    modelLookup,
    hierarchyMap,
    modelIdByPath
  }) => {
    Object.keys(modelIdByPath).forEach(path => {
      requestedPaths[path] = true;
    });
    Object.assign(modelHierarchyMap, hierarchyMap);
    models$.next({ ...models$.value,
      ...modelLookup
    });
    paths$.next({ ...paths$.value,
      ...modelIdByPath
    });
  });

  var contentController = /*#__PURE__*/Object.freeze({
    __proto__: null,
    modelHierarchyMap: modelHierarchyMap,
    operations$: operationsObs$,
    models$: modelsObs$,
    contentTypes$: contentTypesObs$,
    paths$: pathsObs$,
    model$: model$,
    hasCachedModel: hasCachedModel,
    getCachedModel: getCachedModel,
    getCachedModels: getCachedModels,
    fetchById: fetchById,
    byPathFetchIfNotLoaded: byPathFetchIfNotLoaded,
    getContentInstanceByPath: getContentInstanceByPath,
    isInheritedField: isInheritedField,
    getModelIdFromInheritedField: getModelIdFromInheritedField,
    fetchByPath: fetchByPath,
    flushRequestedPaths: flushRequestedPaths,
    hasCachedContentType: hasCachedContentType,
    getCachedContentType: getCachedContentType,
    getCachedContentTypes: getCachedContentTypes,
    updateField: updateField,
    duplicateItem: duplicateItem,
    insertItem: insertItem,
    insertComponent: insertComponent,
    insertInstance: insertInstance,
    insertGroup: insertGroup,
    sortUpItem: sortUpItem,
    sortDownItem: sortDownItem,
    sortItem: sortItem,
    moveItem: moveItem,
    deleteItem: deleteItem
  });

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const foo = (...args) => void null;
  const //
  X_AXIS = 'X',
        Y_AXIS = 'Y',
        HORIZONTAL = 'horizontal',
        VERTICAL = 'vertical',
        TOLERANCE_PERCENTS = {
    x: 5,
    y: 5
  },
        DEFAULT_RECORD_DATA = {
    id: null,
    modelId: null,
    fieldId: null,
    index: null,
    recordType: null
  };
  function not(condition) {
    return !condition;
  }
  function createLocationArgument() {
    return pluckProps(window.location, 'hash', 'host', 'hostname', 'href', 'origin', 'pathname', 'port', 'protocol', 'search');
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const validationChecks = {
    // TODO: implement max/min value.
    maxValue(p0) {},

    minValue(p0) {},

    minCount(id, minCount, level, length) {
      if (length < minCount) {
        return {
          id,
          level,
          values: {
            minCount
          }
        };
      } else {
        return null;
      }
    },

    maxCount(id, maxCount, level, length) {
      if (length >= maxCount) {
        return {
          id,
          level,
          values: {
            maxCount
          }
        };
      } else {
        return null;
      }
    },

    allowedContentTypeTags() {},

    allowedContentTypes() {},

    maxLength() {},

    readOnly() {},

    required() {},

    width() {},

    height() {},

    minWidth() {},

    minHeight() {},

    maxWidth() {},

    maxHeight() {},

    dropTargetsNotFound() {},

    registerNotFound() {}

  };
  let rid = 0;
  /* private */

  const registry$1 = new Map();
  let refCount = {};
  function register$1(registration) {
    // For consistency, set `fieldId` and `index` props
    // to null for records that don't include those values
    const data = Object.assign({}, DEFAULT_RECORD_DATA, pluckProps(registration, true, 'modelId', 'fieldId', 'index'));

    if (nullOrUndefined(data.modelId)) {
      throw new Error(`ICE component registration requires a model ID to be supplied. Supplied model id was ${data.modelId}.`);
    } else if (notNullOrUndefined(data.fieldId) && nullOrUndefined(data.index) && isGroupItem(getReferentialEntries(data).contentType, data.fieldId)) {
      throw new Error('Repeating group item registration requires the index within the repeating group to be supplied. ' + `Please supply index for '${data.fieldId}' of the ${getReferentialEntries(data).contentType.name} model.`);
    }

    const id = exists(data);

    if (id !== null) {
      // TODO: Risk
      // Though more efficient to just keep a refCount
      // clients mistakenly calling deregister multiple
      // times would set things off. The alternative was
      // having slave records.
      const record = getById(id);
      refCount[id]++;
      return record.id;
    } else {
      const record = { ...data,
        id: rid++
      };
      const entities = getReferentialEntries(record); // Record coherence validation

      if (notNullOrUndefined(entities.fieldId) && nullOrUndefined(entities.field)) {
        console.error(`[ICERegistry] Field "${entities.fieldId}" was not found on the "${entities.contentType.name}" content type. ` + `Please check the field name matches one of the content type field names ` + `(${Object.keys(entities.contentType.fields).join(', ')})`);
      }

      record.recordType = determineRecordType(entities);
      registry$1.set(record.id, record);
      refCount[record.id] = 1;
      return record.id;
    }
  }
  function deregister$1(id) {
    const record = registry$1.get(id);

    if (record) {
      if (refCount[id] === 1) {
        registry$1.delete(id);
      } else {
        refCount[id]--;
      }
    }

    return null;
  }
  function exists(data) {
    for (const [, record] of registry$1) {
      if (record.modelId === data.modelId && record.fieldId === data.fieldId && (nou(data.index) || nou(record.index) ? record.index === data.index : String(record.index) === String(data.index))) {
        return record.id;
      }
    }

    return null;
  }
  function getById(id) {
    if (nou(id)) return null;
    id = typeof id === 'string' ? parseInt(id) : id;
    return registry$1.get(id);
  }
  function isRepeatGroup(id) {
    const {
      field,
      recordType
    } = getReferentialEntries(id);
    return recordType === 'field' && field.type === 'repeat';
  }
  function isRepeatGroupItem(id) {
    const record = getById(id);
    return record.recordType === 'repeat-item';
  }
  function getMediaDropTargets(type) {
    const dropTargets = [];

    for (const [, record] of registry$1) {
      var _entries$field;

      const entries = getReferentialEntries(record);

      if (((_entries$field = entries.field) === null || _entries$field === void 0 ? void 0 : _entries$field.type) === type) {
        dropTargets.push(record);
      }
    }

    return dropTargets;
  }
  function getRecordDropTargets(id) {
    const record = getById(id);
    const {
      index,
      field,
      fieldId,
      model
    } = getReferentialEntries(record);

    if (nullOrUndefined(index)) {
      // Can't move something that's not part of a collection.
      // Collection items will always have an index.
      return [];
    } else if (field.type === 'node-selector') {
      // Get content type of item
      const models = getCachedModels();
      const id = extractCollectionItem(model, fieldId, index);
      const nestedModel = models[id];
      const contentType = getContentTypeId(nestedModel);
      const hierarchyMap = modelHierarchyMap;
      const allChildren = [];

      function flattenChildren(id, accum) {
        if (hierarchyMap[id].children.length) {
          accum.push(...hierarchyMap[id].children);
          hierarchyMap[id].children.forEach(child => flattenChildren(child, accum));
        }
      }

      flattenChildren(id, allChildren);
      return getContentTypeDropTargets(contentType).filter(rec => {
        // Not the current item nor a descendant of it (i.e. can't
        // move a item deeper inside itself).
        return rec.modelId !== id && !allChildren.includes(rec.modelId);
      });
    } else if (field.type === 'repeat') {
      return getRepeatGroupItemDropTargets(record);
    } else {
      console.error('[ICERegistry/getRecordDropTargets] Unhandled path');
      return [];
    }
  }
  function getRepeatGroupItemDropTargets(repeatItemRecord) {
    const records = registry$1.values();

    for (const record of records) {
      if ( // not the present record
      record.id !== repeatItemRecord.id && // same field and model
      record.fieldId === repeatItemRecord.fieldId && record.modelId === repeatItemRecord.modelId) {
        if (isSimple(repeatItemRecord.index)) {
          // if the item's index is simple (no dot notation), the parent record wouldn't have an index
          // must have this as separate if statement as the item's index can be simple but the current
          // record not be the one with the null index in which case, it shouldn't fall on the else.
          if (nullOrUndefined(record.index)) {
            return [record];
          }
        } else if ( // if the item's index isn't simple, the parent record index should be the item's index minus
        // the last piece (e.g. item.index = 1.2, parent.index = 1)
        removeLastPiece(repeatItemRecord.index) === String(record.index)) {
          return [record];
        }
      }
    }

    console.error('[IceRegistry/getRepeatGroupItemDropTargets] ' + 'No drop target found for repeat group item. Repeat group items should always have a drop target. ' + 'Check that the repeat group itself was registered and that the item in question is a repeat group item. ' + 'Repeat item in question attached.', repeatItemRecord);
    return [];
  }
  function getComponentItemDropTargets(record) {
    const contentType = getReferentialEntries(record).contentType;
    return getContentTypeDropTargets(contentType).map(rec => rec.id);
  }
  function getContentTypeDropTargets(contentType) {
    const contentTypeId = typeof contentType === 'string' ? contentType : contentType.id;
    return Array.from(registry$1.values()).filter(record => {
      const {
        fieldId,
        index
      } = record;

      if (notNullOrUndefined(fieldId)) {
        var _field$validations, _field$validations$al;

        const {
          field,
          contentType: _contentType,
          model
        } = getReferentialEntries(record);
        const acceptedTypes = field === null || field === void 0 ? void 0 : (_field$validations = field.validations) === null || _field$validations === void 0 ? void 0 : (_field$validations$al = _field$validations.allowedContentTypes) === null || _field$validations$al === void 0 ? void 0 : _field$validations$al.value;
        const accepts = acceptedTypes && (acceptedTypes.includes(contentTypeId) || acceptedTypes.includes('*'));

        if (!accepts) {
          return false;
        } else if (nullOrUndefined(index)) {
          return true;
        } else {
          // At this point, this field has been identified as accepting the content type
          // but the record has an index. If it has an index, it may still be a nested component
          // holder (node-selector).
          return (// Check that the field in question is a node-selector
            isComponentHolder(_contentType, fieldId) && // If it is an array, it is a receptacle, otherwise it's an item:
            // If it is a node selector, it may be an item of the node selector or a node
            // selector itself. Node selectors themselves will be arrays. If it's a value of the
            // node selector it would be a string representing an id of a model held by the node
            // selector.
            Array.isArray(extractCollectionItem(model, fieldId, index))
          );
        }
      } else {
        return false;
      }
    });
  }
  function runDropTargetsValidations(dropTargets) {
    const lookup = {};
    dropTargets.forEach(record => {
      const validationResult = {};
      const {
        fieldId,
        index
      } = record;
      let {
        field: {
          validations = []
        } = {},
        model
      } = getReferentialEntries(record);
      const collection = extractCollectionItem(model, fieldId, index);
      Object.keys(validations).forEach(key => {
        const validation = validations[key];

        switch (validation.id) {
          case 'minCount':
            {
              if (validation.value && collection.length < validation.value) {
                validationResult[validation.id] = {
                  id: validation.id,
                  level: validation.level,
                  values: {
                    min: validation.value
                  }
                };
              }

              break;
            }

          case 'maxCount':
            {
              if (validation.value && collection.length >= validation.value) {
                validationResult[validation.id] = {
                  id: validation.id,
                  level: validation.level,
                  values: {
                    max: validation.value
                  }
                };
              }

              break;
            }
        }
      });
      lookup[record.id] = validationResult;
    });
    return lookup;
  }
  function runValidation(iceId, validationId, args) {
    var _getReferentialEntrie;

    const record = getById(iceId);
    const validations = (_getReferentialEntrie = getReferentialEntries(record).field) === null || _getReferentialEntrie === void 0 ? void 0 : _getReferentialEntrie.validations;

    if (validations !== null && validations !== void 0 && validations[validationId]) {
      return validationChecks[validationId](...[...Object.values(validations[validationId]), ...args]);
    } else {
      return null;
    }
  }
  function getReferentialEntries(record) {
    var _model$craftercms$sou;

    record = typeof record === 'object' ? record : getById(record);
    let model = getCachedModel(record.modelId);
    let contentTypeId = getContentTypeId(model);
    let contentType = getCachedContentType(contentTypeId);
    let field = record.fieldId ? getField(contentType, record.fieldId, getCachedContentTypes()) : null;

    if (!field && record.fieldId && (_model$craftercms$sou = model.craftercms.sourceMap) !== null && _model$craftercms$sou !== void 0 && _model$craftercms$sou[record.fieldId]) {
      model = getContentInstanceByPath(model.craftercms.sourceMap[record.fieldId]);
      contentTypeId = getContentTypeId(model);
      contentType = getCachedContentType(contentTypeId);
      field = record.fieldId ? getField(contentType, record.fieldId) : null;
    }

    return { ...record,
      model,
      field,
      contentType,
      contentTypeId
    };
  }
  function getRecordField(record) {
    return getReferentialEntries(record).field;
  }
  function isMovable(id) {
    const {
      field
    } = getReferentialEntries(id);
    return isMovableType(id) && field.sortable;
  }
  function isMovableType(id) {
    const {
      recordType
    } = getById(id);
    return recordType === 'node-selector-item' || recordType === 'repeat-item';
  }
  function getMovableParentRecord(id) {
    const {
      recordType,
      modelId,
      index,
      fieldId
    } = getReferentialEntries(id);
    const modelHierarchyMap$1 = modelHierarchyMap;

    if (isMovableType(id)) {
      return id;
    } else if (recordType === 'field' || recordType === 'component') {
      if (isSimple(fieldId)) {
        // Can be...
        // - Field of a component (possible move target)
        // - Field of a page
        return modelHierarchyMap$1[modelId] ? exists({
          modelId: modelHierarchyMap$1[modelId].parentId,
          fieldId: modelHierarchyMap$1[modelId].parentContainerFieldPath,
          index: modelHierarchyMap$1[modelId].parentContainerFieldIndex
        }) : null;
      } else {
        // It means the field is a child of a repeat item
        // looking for the parent item of the field
        return exists({
          modelId: modelId,
          fieldId: removeLastPiece(fieldId),
          index: index
        });
      }
    }

    return null;
  }
  function collectMoveTargets() {
    const movableRecords = [];
    registry$1.forEach(record => {
      const recordType = record.recordType;

      if (recordType === 'node-selector-item' || recordType === 'repeat-item') {
        movableRecords.push(record);
      }
    });
    return movableRecords;
  }
  function checkComponentMovability(entries) {
    var _entries$field2;

    // Can't move if
    // - no other zones
    // - other zones are maxed out
    // - leaving current zone would violate minimum
    if (((_entries$field2 = entries.field) === null || _entries$field2 === void 0 ? void 0 : _entries$field2.type) !== 'node-selector') {
      return false;
    }

    const records = Array.from(registry$1.values());
    let parentField, parentModelId, parentCollection, minCount; // Find the parent field and it's respective container collection
    // The array in which this model is listed on.

    for (let i = 0, l = records.length; i < l; i++) {
      if (records[i].id === entries.id) {
        continue;
      }

      const record = getReferentialEntries(records[i]);

      if (nullOrUndefined(record.field)) {
        if (notNullOrUndefined(record.index)) ; else {
          var _contentController$mo;

          // Is a component...
          // - get model fields
          // - check if one of the fields has this value
          const children = (_contentController$mo = modelHierarchyMap[record.modelId]) === null || _contentController$mo === void 0 ? void 0 : _contentController$mo.children;

          if (children !== null && children !== void 0 && children.includes(entries.modelId)) {
            parentModelId = record.modelId;
            const containers = findComponentContainerFields(record.contentType.fields),
                  field = findContainerField(record.model, containers, entries.modelId);

            if (notNullOrUndefined(field)) {
              parentField = field;
              parentCollection = prop(record.model, field.id);
              break;
            }
          }
        }
      } else if (record.field.type === 'node-selector') {
        const value$1 = value(record.model, record.fieldId);

        if (value$1.includes(entries.modelId) || value$1 === entries.modelId) {
          parentField = record.field;
          parentModelId = record.modelId;
          parentCollection = value$1;
          break;
        }
      }
    }

    if (!parentField) {
      throw new Error(`Unable to find the parent field for instance "${entries.modelId}" of ` + `${entries.contentType.name} component${entries.fieldId ? ` (${entries.fieldId} field)` : ''}. ` + 'Did you forget to declare the field when creating the content type?\n' + 'Check the state of the model data this could mean the data is corrupted.');
    }

    const found = forEach(records, record => {
      if (record.modelId === parentModelId && record.fieldId === parentField.id) {
        return true;
      }
    }, false);

    if (!found) {
      const componentName = `'${entries.contentType.name} ${entries.contentType.name.toLowerCase().includes('component') ? "'" : "Component' "}`;
      console.warn(`Per definition the ${componentName} is sortable but a drop zone for it was not found. ` + 'Did you forget to register the zone? Please initialize the drop zone element(s) of ' + `the ${componentName} with modelId="${parentModelId}" and fieldId="${parentField.id}".`);
      return false;
    }

    minCount = parentField.validations && parentField.validations.minCount || 0;

    if (parentField.type === 'node-selector') {
      return parentField.sortable && // If there are more adjacent items on this zone to be able to
      // move current guy before/after
      parentCollection.length > 1 || // Would moving the guy away from this zone violate it's minCount?
      parentCollection.length - 1 >= minCount && // Does anybody else accept this type of component?
      getComponentItemDropTargets(entries).length > 0;
    } else {
      return (// Moving this component would make the parent field value null/blank
        // If the parent field is not required that should be ok
        !parentField.required && // Is this guy accepted elsewhere?
        getComponentItemDropTargets(entries).length > 0
      );
    }
  }
  function checkRepeatGroupMovability(entries) {
    const {
      model,
      field,
      index
    } = entries;
    return (field === null || field === void 0 ? void 0 : field.type) === 'repeat' && field.sortable && // `index` must be a valid number. nullish value
    // may mean it's not a group item but rather the group
    // container
    notNullOrUndefined(index) && // No point making movable an item that can't jump
    // zones and doesn't have any adjacent items to move it
    // next to.
    // TODO: What about DnD trashing, though?
    value(model, field.id).length > 1;
  }
  function findContainerField(model, fields, modelId) {
    return forEach(fields, field => {
      const value$1 = value(model, field.id);

      if (field.type === 'node-selector' && (value$1 === modelId || value$1.includes(modelId))) {
        return field;
      } else if (field.type === 'repeat') ;
    });
  }
  function flush$1() {
    registry$1.clear();
    refCount = {};
  }
  function findContainerRecord(modelId, fieldId, index) {
    let recordId;

    if (isSimple(fieldId)) {
      recordId = exists({
        modelId: modelId,
        fieldId: fieldId !== null && fieldId !== void 0 ? fieldId : null,
        index: null
      });
    } else {
      recordId = exists({
        modelId: modelId,
        fieldId: fieldId !== null && fieldId !== void 0 ? fieldId : null,
        index: parseInt(removeLastPiece(index))
      });
    }

    return notNullOrUndefined(recordId) ? getById(recordId) : null;
  }
  function findChildRecord(modelId, fieldId, index) {
    const hierarchyMap = modelHierarchyMap;
    const mapItem = hierarchyMap[modelId];

    if (mapItem) {
      for (const childId of mapItem.children) {
        const entry = hierarchyMap[childId];

        if (entry.parentId === modelId && entry.parentContainerFieldPath === fieldId && String(entry.parentContainerFieldIndex) === String(index)) {
          const recordId = exists({
            modelId: entry.modelId,
            fieldId: null,
            index: null
          });
          return notNullOrUndefined(recordId) ? getById(recordId) : null;
        }
      }
    }

    return null;
  }
  function getRegistry$1() {
    return registry$1;
  }

  var iceRegistry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    register: register$1,
    deregister: deregister$1,
    exists: exists,
    getById: getById,
    isRepeatGroup: isRepeatGroup,
    isRepeatGroupItem: isRepeatGroupItem,
    getMediaDropTargets: getMediaDropTargets,
    getRecordDropTargets: getRecordDropTargets,
    getRepeatGroupItemDropTargets: getRepeatGroupItemDropTargets,
    getComponentItemDropTargets: getComponentItemDropTargets,
    getContentTypeDropTargets: getContentTypeDropTargets,
    runDropTargetsValidations: runDropTargetsValidations,
    runValidation: runValidation,
    getReferentialEntries: getReferentialEntries,
    getRecordField: getRecordField,
    isMovable: isMovable,
    isMovableType: isMovableType,
    getMovableParentRecord: getMovableParentRecord,
    collectMoveTargets: collectMoveTargets,
    checkComponentMovability: checkComponentMovability,
    checkRepeatGroupMovability: checkRepeatGroupMovability,
    findContainerField: findContainerField,
    flush: flush$1,
    findContainerRecord: findContainerRecord,
    findChildRecord: findChildRecord,
    getRegistry: getRegistry$1
  });

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  // Regular click gets triggered even after loooong mouse downs or
  // when mousing-down and dragging cursor - without actually being on
  // a drag and drop of an element - and then mousing-up some other place.
  // This causes the ice zone selection to occur and the UX feels awkward.
  // This is a custom click event with a more opinionated click behaviour
  // that could be used instead of the regular click. The trade-of is that,
  // as is, won't handle preventDefault/stopPropagation correctly as it's a
  // delegate on the document (i.e. the event as bubbled all the way up).
  // Would need to add additional logic to set the delegation in a way that
  // events can still be stopped (see jQuery).
  // export function addClickListener(
  //   element: HTMLElement | Document,
  //   type: string,
  //   handler: (e: Event) => any
  // ): Subscription {
  //   if (element === document) {
  //     // TODO: set up as delegate, control event propagation & stopping accordingly
  //   }
  //
  //   const mouseDown$ = fromEvent(element, 'mousedown');
  //   const mouseUp$ = fromEvent(element, 'mouseup');
  //   return mouseDown$
  //     .pipe(
  //       switchMap(() => mouseUp$.pipe(takeUntil(interval(300)), take(1))),
  //       filter(
  //         (e: any) =>
  //           e.target.hasAttribute('data-craftercms-model-id') ||
  //           forEach(
  //             e.path,
  //             (el) =>
  //               el !== window && el !== document && el.hasAttribute('data-craftercms-model-id')
  //                 ? true
  //                 : 'continue',
  //             false
  //           )
  //       )
  //     )
  //     .subscribe(handler);
  // }
  function sibling(element, next) {
    return next ? element.nextElementSibling : element.previousElementSibling;
  }
  function getDropMarkerPosition(args) {
    const {
      // refElement,
      arrangement,
      insertPosition,
      refElementRect,
      nextOrPrevRect
    } = args,
          horizontal = arrangement === HORIZONTAL,
          before = insertPosition === 'before',
          // $elementToInsert = $(refElement),
    // This vars are just for mental clarity; to work with
    // the right semantics in the code below.
    // If inserting before the element, will be working with
    // the previous element's rect (prev rect). If inserting
    // after, will be working with the next element's rect.
    nextRect = nextOrPrevRect,
          prevRect = nextOrPrevRect; // If there is not next/prev rect, no need to account for it
    // in the position calculation - set difference to 0.

    const difference = !nextOrPrevRect ? 0 : // Account for whether the previous rect inline with current rect...
    // Only matters when working with horizontally laid-out elements
    horizontal && nextOrPrevRect.top !== refElementRect.top ? 0 : // Calculate the middle point between the two adjacent rects.
    // This avoids the drop marker moving by millimeters when switching from
    // inserting after nodes[i] to before node[i+1]
    before ? // Inserting before
    horizontal ? // Smaller number fronted to obtain a negative
    // value since wish to subtract from the position
    (prevRect.right - refElementRect.left) / 2 : (prevRect.bottom - refElementRect.top) / 2 : // Inserting after
    horizontal ? // Bigger number fronted to obtain a positive
    // value to add to the position
    (nextRect.left - refElementRect.right) / 2 : (nextRect.top - refElementRect.bottom) / 2;
    return horizontal ? {
      height: refElementRect.height,
      top: refElementRect.top,
      left: before ? refElementRect.left + difference : refElementRect.right + difference
    } : {
      width: refElementRect.width,
      top: before ? refElementRect.top + difference : refElementRect.bottom + difference,
      left: refElementRect.left
    };
  }
  function splitRect(rect, axis = X_AXIS) {
    // x, y, width, height, top, right, bottom, left
    let rect1 = {},
        rect2 = {}; // noinspection DuplicatedCode

    if (axis === X_AXIS) {
      const half = rect.height / 2;
      rect1.x = rect.x;
      rect1.y = rect.y;
      rect1.width = rect.width;
      rect1.height = half;
      rect1.top = rect.top;
      rect1.right = rect.right;
      rect1.bottom = rect.top + half;
      rect1.left = rect.left;
      rect2.x = rect.x;
      rect2.y = rect.y + half;
      rect2.width = rect.width;
      rect2.height = half;
      rect2.top = rect2.y;
      rect2.right = rect.right;
      rect2.bottom = rect.bottom;
      rect2.left = rect.left;
    } else if (axis === Y_AXIS) {
      const half = rect.width / 2;
      rect1.x = rect.x;
      rect1.y = rect.y;
      rect1.width = half;
      rect1.height = rect.height;
      rect1.top = rect.top;
      rect1.right = rect.left + half;
      rect1.bottom = rect.bottom;
      rect1.left = rect.left;
      rect2.x = rect.x + half;
      rect2.y = rect.y;
      rect2.width = half;
      rect2.height = rect.height;
      rect2.top = rect.top;
      rect2.right = rect.right;
      rect2.bottom = rect.bottom;
      rect2.left = rect.left + half;
    } else {
      throw new Error(`Invalid axis suplied. Valid values are "${X_AXIS}" or "${Y_AXIS}".`);
    }

    return [rect1, rect2];
  }
  function getDistanceBetweenPoints(p1, p2) {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  }
  function findClosestRect(parentRect, subRects, coordinates) {
    let //
    index = -1,
        distances = [];
    subRects.forEach((rect, i) => {
      const stats = getInRectStats(rect, coordinates);
      stats.inRect && (index = i);
      distances.push(getDistanceBetweenPoints(coordinates, {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      }));
      return stats;
    });

    if (index === -1) {
      index = distances.indexOf(Math.min(...distances));
    }

    return index;
  }
  function getChildArrangement(children, childrenRects, selfRect) {
    if (children.length === 0) {
      // If width is big enough, we may assume it may potentially have multiple
      // columns and HORIZONTAL arrangement may be better guess; however,
      // using the larger space to display the drop marker makes it more visible.
      // Vertical arrangement (stacked), will cause the drop marker to be across
      // the X axis, so logic is sort of flipped in the sense that it's said to be
      // vertical so that drop marker displays horizontally
      return selfRect.width > selfRect.height ? VERTICAL : HORIZONTAL;
    }

    let //
    topValues = [],
        alignedTop = false;

    for (let i = 0, l = children.length, topValue, marginTop; i < l; i++) {
      marginTop = parseInt( // jQuery is kind enough to always provide the value in pixels :)
      $(children[i]).css('margin-top').replace(/px/i, '') || '', 10);
      topValue = childrenRects[i].top - marginTop;

      if (topValues.includes(topValue)) {
        alignedTop = true;
        break;
      } else {
        topValues.push(topValue);
      }
    }

    return alignedTop ? HORIZONTAL : VERTICAL;
  }
  function getInRectStats(rect, coordinates, tolerancePercents = TOLERANCE_PERCENTS) {
    const percents = getRelativePointerPositionPercentages(coordinates, rect),
          inRectTop = coordinates.y >= rect.top,
          inRectRight = coordinates.x <= rect.right,
          inRectBottom = coordinates.y <= rect.bottom,
          inRectLeft = coordinates.x >= rect.left,
          inRect = inRectLeft && inRectRight && inRectTop && inRectBottom,
          inInnerRectTop = percents.y >= tolerancePercents.y,
          inInnerRectRight = percents.x <= 100 - tolerancePercents.x,
          inInnerRectBottom = percents.y <= 100 - tolerancePercents.y,
          inInnerRectLeft = percents.x >= tolerancePercents.x,
          inInnerRect = inInnerRectLeft && // left
    inInnerRectRight && // right
    inInnerRectTop && // top
    inInnerRectBottom; // bottom

    return {
      inRectTop,
      inRectRight,
      inRectBottom,
      inRectLeft,
      inRect,
      inInnerRectTop,
      inInnerRectRight,
      inInnerRectBottom,
      inInnerRectLeft,
      inInnerRect,
      percents
    };
  }
  function getRelativePointerPositionPercentages(mousePosition, rect) {
    const x =
    /* mouse X distance from rect left edge */
    (mousePosition.x - rect.left) /
    /* width */
    rect.width * 100,
          y =
    /* mouse X distance from rect top edge */
    (mousePosition.y - rect.top) /
    /* height */
    rect.height * 100;
    return {
      x,
      y
    };
  }
  function isElementInView(element, fullyInView) {
    const pageTop = $(window).scrollTop();
    const pageBottom = pageTop + $(window).height();
    const elementTop = $(element).offset().top;
    const elementBottom = elementTop + $(element).height();

    if (fullyInView === true) {
      return pageTop < elementTop && pageBottom > elementBottom;
    } else {
      return elementTop <= pageBottom && elementBottom >= pageTop;
    }
  }
  function addAnimation($element, animationClass) {
    const END_EVENT = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';
    $element.addClass(animationClass); // @ts-ignore

    $element.one(END_EVENT, function () {
      $element.removeClass(animationClass);
    });
  }
  function scrollToElement(element, scrollElement, animate = false) {
    const $element = $(element);

    if (!element) {
      return null;
    } else if (!isElementInView($element)) {
      $(scrollElement).animate({
        scrollTop: $element.offset().top - 100
      }, 300, function () {
        if (animate) addAnimation($element, 'craftercms-content-tree-locate');
      });
    } else if (animate) {
      addAnimation($element, 'craftercms-content-tree-locate');
    }

    return $element;
  }
  function scrollToDropTargets(dropTargets, scrollElement, getElementRegistry) {
    let elementInView;
    elementInView = forEach(dropTargets, ({
      id
    }) => {
      let elem = getElementRegistry(id);

      if (isElementInView(elem)) {
        elementInView = true;
        return 'break';
      }
    }, false);

    if (!elementInView) {
      // TODO: Do this relative to the scroll position. Don't move if things are already in viewport. Be smarter.
      let element = getElementRegistry(dropTargets[0].id);
      $(scrollElement).animate({
        scrollTop: $(element).offset().top - 100
      }, 300);
    }
  }
  function updateDropZoneValidations(dropZone, dropZones, validations) {
    const newDropZone = { ...dropZone
    };
    let newDropZones = [...dropZones];
    newDropZone.validations = validations;
    newDropZones = newDropZones.filter(item => item.elementRecordId !== newDropZone.elementRecordId);
    newDropZones.push(newDropZone);
    return newDropZones;
  }
  function getZoneMarkerStyle(rect, padding = 0) {
    const $window = $(window);
    return {
      height: rect.height + padding,
      width: rect.width + padding,
      top: rect.top + $window.scrollTop() - padding / 2,
      left: rect.left + $window.scrollLeft() - padding / 2
    };
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  let seq = 0; // Element record registry

  let db = {}; // Lookup table of element record id arrays, indexed by iceId

  let registry = {};
  function get(id) {
    const record = db[id];
    record && nullOrUndefined(record.label) && setLabel(record);
    return record;
  } // TODO: Unknown field names go by ignored. Trace the registration point to warn
  //  developers about field names that aren't found in the content type

  function setLabel(record) {
    const labels = [];
    const models = getCachedModels();
    record.iceIds.forEach(iceId => {
      const iceRecord = getById(iceId);
      const {
        model,
        field,
        fieldId,
        index,
        contentType
      } = getReferentialEntries(iceRecord);

      if (notNullOrUndefined(field)) {
        switch (field.type) {
          case 'node-selector':
            {
              if (notNullOrUndefined(index)) {
                if (isSymmetricCombination(fieldId, index)) {
                  let aux = extractCollectionItem(model, fieldId, index);
                  let component = models[aux];

                  if (component) {
                    labels.push(`${component.craftercms.label} (${getCachedContentType(component.craftercms.contentTypeId).name})`);
                  } else {
                    labels.push(`${field.name}`);
                  }
                } else {
                  labels.push(`${field.name}`);
                }
              } else {
                labels.push(`${field.name}`);
              }

              break;
            }

          case 'repeat':
            if (nou(index)) {
              labels.push(`${field.name} (Repeat Group)`);
            } else {
              if (isSymmetricCombination(fieldId, index)) {
                labels.push(`${field.name} item # ${parseInt(isSimple(index) ? String(index) : popPiece(String(index))) + 1}`);
              } else {
                labels.push(`${field.name} (Repeat Group)`);
              }
            }

            break;

          case 'text':
          case 'textarea':
            labels.push(`${field.name} (Plain Text)`);
            break;

          case 'html':
            labels.push(`${field.name} (Rich Text)`);
            break;

          default:
            labels.push(field.name);
            break;
        }
      } else {
        labels.push(`${model.craftercms.label} (${contentType.name})`);
      }
    });
    record.label = labels.join(', ');
  }
  function register(payload) {
    // @ts-ignore
    if (notNullOrUndefined(payload.id)) {
      throw new Error('Record already has id. Was it pre-registered? Please deregister first.');
    }

    const {
      element,
      modelId,
      index,
      label,
      fieldId,
      path
    } = payload;
    const id = seq++;
    const iceIds = []; // prettier-ignore

    const fieldIds = fieldId == null ? [] : Array.isArray(fieldId) ? fieldId : fieldId.split(',').map(str => str.trim());

    function create() {
      // Create/register the physical record
      db[id] = {
        id,
        element,
        modelId,
        index,
        label,
        fieldId: fieldIds,
        iceIds,
        complete: false,
        inherited: fieldIds.some(fieldId => isInheritedField(modelId, fieldId))
      };
    } // If the relevant model is loaded, complete it's registration, otherwise,
    // request it and complete registration when it does load.


    if (hasCachedModel(modelId)) {
      create();
      completeDeferredRegistration(id);
    } else {
      path && byPathFetchIfNotLoaded(path).subscribe();
      model$(modelId).pipe(take(1)).subscribe(() => {
        create();
        completeDeferredRegistration(id);
      });
    }

    return id;
  }
  function completeDeferredRegistration(id) {
    const record = db[id];
    const {
      modelId,
      index,
      fieldId: fieldIds,
      iceIds
    } = record;

    if (fieldIds.length > 0) {
      fieldIds.forEach(fieldId => {
        const iceId = register$1({
          modelId,
          index,
          fieldId
        });

        if (!registry[iceId]) {
          registry[iceId] = [];
        }

        registry[iceId].push(record.id);
        iceIds.push(iceId);
      });
    } else {
      const iceId = register$1({
        modelId,
        index
      });

      if (!registry[iceId]) {
        registry[iceId] = [];
      }

      registry[iceId].push(record.id);
      iceIds.push(iceId);
    }

    db[id].complete = true;
  }
  function deregister(id) {
    const record = db[id];

    if (notNullOrUndefined(record)) {
      const {
        iceIds
      } = record;
      iceIds.forEach(iceId => {
        if (registry[iceId].length === 1) {
          delete registry[iceId];
        } else if (registry[iceId].length > 1) {
          registry[iceId].splice(registry[iceId].indexOf(record.id), 1);
        }

        deregister$1(iceId);
      });
      delete db[id];
    }

    return record;
  }
  /**
   * Returns the ICE id of the first movable ICE record on the
   * specified element record or false if none is movable.
   * */

  function getDraggable(id) {
    const record = get(id);
    return forEach(record.iceIds, function (iceId) {
      if (isMovable(iceId)) {
        return iceId;
      }
    }, false);
  }
  function getHoverData(id) {
    const record = get(id);
    return {
      id,
      rect: record.element.getBoundingClientRect(),
      inherited: record.inherited,
      label: record.label,
      validations: {}
    };
  }
  function getRect(id) {
    return get(id).element.getBoundingClientRect();
  }
  function createIntermediateElementRecord(record, iceId) {
    if (!record) {
      return null;
    }

    const {
      id,
      element,
      label,
      modelId,
      index
    } = record;
    return {
      id,
      element,
      modelId,
      index,
      label,
      fieldId: getById(iceId).fieldId,
      iceId
    };
  }
  function fromICEId(iceId) {
    var _registry$iceId;

    const record = db[(_registry$iceId = registry[iceId]) === null || _registry$iceId === void 0 ? void 0 : _registry$iceId[0]];
    return createIntermediateElementRecord(record, iceId);
  }
  function getRecordsFromIceId(iceId) {
    const recordsIds = registry[iceId];
    const records = [];

    if (!recordsIds) {
      return null;
    } else if (recordsIds.length > 1) {
      recordsIds.forEach(recordId => {
        let record = db[recordId];
        let registry = createIntermediateElementRecord(record, iceId);

        if (registry) {
          records.push(registry);
        }
      });
      return records.length > 0 ? records : null;
    } else {
      let registry = fromICEId(iceId);
      return registry ? [registry] : null;
    }
  }

  function getDropZoneFromRegistryEntry(elementRecord, iceId) {
    const elementRecordId = elementRecord.id;
    const element = elementRecord.element;
    const children = Array.from(element.children);
    const childrenRects = children.map(child => child.getBoundingClientRect());
    const rect = element.getBoundingClientRect();
    return {
      element,
      children,
      iceId,
      elementRecordId,
      rect,
      arrangement: getChildArrangement(children, childrenRects, rect),
      childrenRects,
      validations: {}
    };
  }

  function compileDropZone(iceId) {
    const elementRecord = fromICEId(iceId);
    return getDropZoneFromRegistryEntry(elementRecord, iceId);
  }
  function compileAllDropZones(iceId) {
    const elementRecords = getRecordsFromIceId(iceId);
    return elementRecords.map(elementRecord => getDropZoneFromRegistryEntry(elementRecord, iceId));
  }
  function getSiblingRects(id) {
    let //
    record = get(id),
        element = record.element,
        nextSibling,
        prevSibling,
        next,
        prev;
    nextSibling = sibling(element, true);
    prevSibling = sibling(element, false);
    forEach(Object.values(db), record => {
      if (record.element === nextSibling) {
        next = record.element.getBoundingClientRect();
      } else if (record.element === prevSibling) {
        prev = record.element.getBoundingClientRect();
      } else if (notNullOrUndefined(next) && notNullOrUndefined(prev)) {
        return 'break';
      }
    });
    return {
      next,
      prev
    };
  }
  function fromElement(element) {
    return forEach(Object.values(db), record => {
      if (record.element === element) {
        return record;
      }
    });
  }
  function hasElement(element) {
    return forEach(Object.values(db), record => {
      if (record.element === element) {
        return true;
      }
    }, false);
  }
  function getHighlighted(dropZones) {
    return dropZones.reduce((object, {
      elementRecordId: id,
      validations
    }) => {
      object[id] = getHoverData(id);
      object[id].validations = validations;
      return object;
    }, {});
  }
  function getDragContextFromDropTargets(dropTargets, validationsLookup, currentRecord) {
    const response = {
      dropZones: [],
      siblings: [],
      players: [],
      containers: []
    };
    dropTargets.forEach(({
      id
    }) => {
      const dropZones = compileAllDropZones(id);
      const dropZonesFiltered = currentRecord ? dropZones.filter(dropZone => dropZone.children.includes(currentRecord.element)) : null;
      (dropZonesFiltered && dropZonesFiltered.length ? dropZonesFiltered : dropZones).forEach(dropZone => {
        var _validationsLookup$id;

        dropZone.origin = null;
        dropZone.origin = currentRecord ? dropZone.children.includes(currentRecord.element) : null;
        dropZone.validations = (_validationsLookup$id = validationsLookup === null || validationsLookup === void 0 ? void 0 : validationsLookup[id]) !== null && _validationsLookup$id !== void 0 ? _validationsLookup$id : {};
        response.dropZones.push(dropZone);
        response.siblings = [...response.siblings, ...dropZone.children];
        response.players = [...response.players, ...dropZone.children, dropZone.element];
        response.containers.push(dropZone.element);
      });
    });
    return response;
  }
  function getElementFromICEProps(modelId, fieldId, index) {
    const recordId = exists({
      modelId: modelId,
      fieldId: fieldId,
      index: index
    });

    if (recordId !== null) {
      const registryEntry = fromICEId(recordId);

      if (registryEntry) {
        return registryEntry.element;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  /**
   * Retrieves the parent node (drop target/zone) of an item
   */

  function getParentElementFromICEProps(modelId, fieldId, index) {
    var _findContainerRecord$, _findContainerRecord;

    const recordId = (_findContainerRecord$ = (_findContainerRecord = findContainerRecord(modelId, fieldId, index)) === null || _findContainerRecord === void 0 ? void 0 : _findContainerRecord.id) !== null && _findContainerRecord$ !== void 0 ? _findContainerRecord$ : null;
    return recordId === null ? null : $(fromICEId(recordId).element);
  }
  /**
   * Retrieves all the drop targets elements that host a give ice record
   */

  function getParentsElementFromICEProps(modelId, fieldId, index) {
    var _findContainerRecord$2, _findContainerRecord2;

    const recordId = (_findContainerRecord$2 = (_findContainerRecord2 = findContainerRecord(modelId, fieldId, index)) === null || _findContainerRecord2 === void 0 ? void 0 : _findContainerRecord2.id) !== null && _findContainerRecord$2 !== void 0 ? _findContainerRecord$2 : null;
    return recordId === null ? null : getRecordsFromIceId(recordId).map(registryEntry => $(registryEntry.element));
  }
  function flush() {
    db = {};
    registry = {};
    flush$1();
  }
  function getRegistry() {
    return db;
  }

  var elementRegistry = /*#__PURE__*/Object.freeze({
    __proto__: null,
    get: get,
    setLabel: setLabel,
    register: register,
    completeDeferredRegistration: completeDeferredRegistration,
    deregister: deregister,
    getDraggable: getDraggable,
    getHoverData: getHoverData,
    getRect: getRect,
    createIntermediateElementRecord: createIntermediateElementRecord,
    fromICEId: fromICEId,
    getRecordsFromIceId: getRecordsFromIceId,
    compileDropZone: compileDropZone,
    compileAllDropZones: compileAllDropZones,
    getSiblingRects: getSiblingRects,
    fromElement: fromElement,
    hasElement: hasElement,
    getHighlighted: getHighlighted,
    getDragContextFromDropTargets: getDragContextFromDropTargets,
    getElementFromICEProps: getElementFromICEProps,
    getParentElementFromICEProps: getParentElementFromICEProps,
    getParentsElementFromICEProps: getParentsElementFromICEProps,
    flush: flush,
    getRegistry: getRegistry
  });

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret$1 = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
  var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var ReactPropTypesSecret = ReactPropTypesSecret_1;

  function emptyFunction() {}

  function emptyFunctionWithReset() {}

  emptyFunctionWithReset.resetWarningCache = emptyFunction;

  var factoryWithThrowingShims = function () {
    function shim(props, propName, componentName, location, propFullName, secret) {
      if (secret === ReactPropTypesSecret) {
        // It is still safe when called from React.
        return;
      }

      var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
      err.name = 'Invariant Violation';
      throw err;
    }
    shim.isRequired = shim;

    function getShim() {
      return shim;
    }
    // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.

    var ReactPropTypes = {
      array: shim,
      bool: shim,
      func: shim,
      number: shim,
      object: shim,
      string: shim,
      symbol: shim,
      any: shim,
      arrayOf: getShim,
      element: shim,
      elementType: shim,
      instanceOf: getShim,
      node: shim,
      objectOf: getShim,
      oneOf: getShim,
      oneOfType: getShim,
      shape: getShim,
      exact: getShim,
      checkPropTypes: emptyFunctionWithReset,
      resetWarningCache: emptyFunction
    };
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
  };

  /**
   * Copyright (c) 2013-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  {
    // By explicitly using `prop-types` you are opting into new production behavior.
    // http://fb.me/prop-types-in-prod
    factoryWithThrowingShims();
  }

  var ReactReduxContext = /*#__PURE__*/React.createContext(null);

  // Default to a dummy "batch" implementation that just runs the callback
  function defaultNoopBatch(callback) {
    callback();
  }

  var batch = defaultNoopBatch; // Allow injecting another batching function later

  var setBatch = function setBatch(newBatch) {
    return batch = newBatch;
  }; // Supply a getter just to skip dealing with ESM bindings

  var getBatch = function getBatch() {
    return batch;
  };

  // well as nesting subscriptions of descendant components, so that we can ensure the
  // ancestor components re-render before descendants

  function createListenerCollection() {
    var batch = getBatch();
    var first = null;
    var last = null;
    return {
      clear: function clear() {
        first = null;
        last = null;
      },
      notify: function notify() {
        batch(function () {
          var listener = first;

          while (listener) {
            listener.callback();
            listener = listener.next;
          }
        });
      },
      get: function get() {
        var listeners = [];
        var listener = first;

        while (listener) {
          listeners.push(listener);
          listener = listener.next;
        }

        return listeners;
      },
      subscribe: function subscribe(callback) {
        var isSubscribed = true;
        var listener = last = {
          callback: callback,
          next: null,
          prev: last
        };

        if (listener.prev) {
          listener.prev.next = listener;
        } else {
          first = listener;
        }

        return function unsubscribe() {
          if (!isSubscribed || first === null) return;
          isSubscribed = false;

          if (listener.next) {
            listener.next.prev = listener.prev;
          } else {
            last = listener.prev;
          }

          if (listener.prev) {
            listener.prev.next = listener.next;
          } else {
            first = listener.next;
          }
        };
      }
    };
  }

  var nullListeners = {
    notify: function notify() {},
    get: function get() {
      return [];
    }
  };
  function createSubscription(store, parentSub) {
    var unsubscribe;
    var listeners = nullListeners;

    function addNestedSub(listener) {
      trySubscribe();
      return listeners.subscribe(listener);
    }

    function notifyNestedSubs() {
      listeners.notify();
    }

    function handleChangeWrapper() {
      if (subscription.onStateChange) {
        subscription.onStateChange();
      }
    }

    function isSubscribed() {
      return Boolean(unsubscribe);
    }

    function trySubscribe() {
      if (!unsubscribe) {
        unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
        listeners = createListenerCollection();
      }
    }

    function tryUnsubscribe() {
      if (unsubscribe) {
        unsubscribe();
        unsubscribe = undefined;
        listeners.clear();
        listeners = nullListeners;
      }
    }

    var subscription = {
      addNestedSub: addNestedSub,
      notifyNestedSubs: notifyNestedSubs,
      handleChangeWrapper: handleChangeWrapper,
      isSubscribed: isSubscribed,
      trySubscribe: trySubscribe,
      tryUnsubscribe: tryUnsubscribe,
      getListeners: function getListeners() {
        return listeners;
      }
    };
    return subscription;
  }

  // To get around it, we can conditionally useEffect on the server (no-op) and
  // useLayoutEffect in the browser. We need useLayoutEffect to ensure the store
  // subscription callback always has the selector from the latest render commit
  // available, otherwise a store update may happen between render and the effect,
  // which may cause missed updates; we also must ensure the store subscription
  // is created synchronously, otherwise a store update may occur before the
  // subscription is created and an inconsistent state may be observed

  var useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? react.exports.useLayoutEffect : react.exports.useEffect;

  function Provider(_ref) {
    var store = _ref.store,
        context = _ref.context,
        children = _ref.children;
    var contextValue = react.exports.useMemo(function () {
      var subscription = createSubscription(store);
      subscription.onStateChange = subscription.notifyNestedSubs;
      return {
        store: store,
        subscription: subscription
      };
    }, [store]);
    var previousState = react.exports.useMemo(function () {
      return store.getState();
    }, [store]);
    useIsomorphicLayoutEffect(function () {
      var subscription = contextValue.subscription;
      subscription.trySubscribe();

      if (previousState !== store.getState()) {
        subscription.notifyNestedSubs();
      }

      return function () {
        subscription.tryUnsubscribe();
        subscription.onStateChange = null;
      };
    }, [contextValue, previousState]);
    var Context = context || ReactReduxContext;
    return /*#__PURE__*/React.createElement(Context.Provider, {
      value: contextValue
    }, children);
  }

  function _extends$5() {
    _extends$5 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$5.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose$3(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  var reactIs$1 = {exports: {}};

  var reactIs_production_min = {};

  /** @license React v17.0.2
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var b = 60103,
      c = 60106,
      d = 60107,
      e = 60108,
      f$1 = 60114,
      g$1 = 60109,
      h$1 = 60110,
      k$1 = 60112,
      l = 60113,
      m$1 = 60120,
      n$1 = 60115,
      p$1 = 60116,
      q$1 = 60121,
      r = 60122,
      u = 60117,
      v = 60129,
      w = 60131;

  if ("function" === typeof Symbol && Symbol.for) {
    var x = Symbol.for;
    b = x("react.element");
    c = x("react.portal");
    d = x("react.fragment");
    e = x("react.strict_mode");
    f$1 = x("react.profiler");
    g$1 = x("react.provider");
    h$1 = x("react.context");
    k$1 = x("react.forward_ref");
    l = x("react.suspense");
    m$1 = x("react.suspense_list");
    n$1 = x("react.memo");
    p$1 = x("react.lazy");
    q$1 = x("react.block");
    r = x("react.server.block");
    u = x("react.fundamental");
    v = x("react.debug_trace_mode");
    w = x("react.legacy_hidden");
  }

  function y(a) {
    if ("object" === typeof a && null !== a) {
      var t = a.$$typeof;

      switch (t) {
        case b:
          switch (a = a.type, a) {
            case d:
            case f$1:
            case e:
            case l:
            case m$1:
              return a;

            default:
              switch (a = a && a.$$typeof, a) {
                case h$1:
                case k$1:
                case p$1:
                case n$1:
                case g$1:
                  return a;

                default:
                  return t;
              }

          }

        case c:
          return t;
      }
    }
  }

  var z = g$1,
      A = b,
      B = k$1,
      C = d,
      D = p$1,
      E = n$1,
      F = c,
      G = f$1,
      H = e,
      I = l;
  reactIs_production_min.ContextConsumer = h$1;
  reactIs_production_min.ContextProvider = z;
  reactIs_production_min.Element = A;
  reactIs_production_min.ForwardRef = B;
  reactIs_production_min.Fragment = C;
  reactIs_production_min.Lazy = D;
  reactIs_production_min.Memo = E;
  reactIs_production_min.Portal = F;
  reactIs_production_min.Profiler = G;
  reactIs_production_min.StrictMode = H;
  reactIs_production_min.Suspense = I;

  reactIs_production_min.isAsyncMode = function () {
    return !1;
  };

  reactIs_production_min.isConcurrentMode = function () {
    return !1;
  };

  reactIs_production_min.isContextConsumer = function (a) {
    return y(a) === h$1;
  };

  reactIs_production_min.isContextProvider = function (a) {
    return y(a) === g$1;
  };

  reactIs_production_min.isElement = function (a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
  };

  reactIs_production_min.isForwardRef = function (a) {
    return y(a) === k$1;
  };

  reactIs_production_min.isFragment = function (a) {
    return y(a) === d;
  };

  reactIs_production_min.isLazy = function (a) {
    return y(a) === p$1;
  };

  reactIs_production_min.isMemo = function (a) {
    return y(a) === n$1;
  };

  reactIs_production_min.isPortal = function (a) {
    return y(a) === c;
  };

  reactIs_production_min.isProfiler = function (a) {
    return y(a) === f$1;
  };

  reactIs_production_min.isStrictMode = function (a) {
    return y(a) === e;
  };

  reactIs_production_min.isSuspense = function (a) {
    return y(a) === l;
  };

  reactIs_production_min.isValidElementType = function (a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f$1 || a === v || a === e || a === l || a === m$1 || a === w || "object" === typeof a && null !== a && (a.$$typeof === p$1 || a.$$typeof === n$1 || a.$$typeof === g$1 || a.$$typeof === h$1 || a.$$typeof === k$1 || a.$$typeof === u || a.$$typeof === q$1 || a[0] === r) ? !0 : !1;
  };

  reactIs_production_min.typeOf = y;

  {
    reactIs$1.exports = reactIs_production_min;
  }

  var reactIs = reactIs$1.exports;
  var FORWARD_REF_STATICS = {
    '$$typeof': true,
    render: true,
    defaultProps: true,
    displayName: true,
    propTypes: true
  };
  var MEMO_STATICS = {
    '$$typeof': true,
    compare: true,
    defaultProps: true,
    displayName: true,
    propTypes: true,
    type: true
  };
  var TYPE_STATICS = {};
  TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
  TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

  /**
   * A hook to access the value of the `ReactReduxContext`. This is a low-level
   * hook that you should usually not need to call directly.
   *
   * @returns {any} the value of the `ReactReduxContext`
   *
   * @example
   *
   * import React from 'react'
   * import { useReduxContext } from 'react-redux'
   *
   * export const CounterComponent = ({ value }) => {
   *   const { store } = useReduxContext()
   *   return <div>{store.getState()}</div>
   * }
   */

  function useReduxContext() {
    var contextValue = react.exports.useContext(ReactReduxContext);

    return contextValue;
  }

  /**
   * Hook factory, which creates a `useStore` hook bound to a given context.
   *
   * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
   * @returns {Function} A `useStore` hook bound to the specified context.
   */

  function createStoreHook(context) {
    if (context === void 0) {
      context = ReactReduxContext;
    }

    var useReduxContext$1 = context === ReactReduxContext ? useReduxContext : function () {
      return react.exports.useContext(context);
    };
    return function useStore() {
      var _useReduxContext = useReduxContext$1(),
          store = _useReduxContext.store;

      return store;
    };
  }
  /**
   * A hook to access the redux store.
   *
   * @returns {any} the redux store
   *
   * @example
   *
   * import React from 'react'
   * import { useStore } from 'react-redux'
   *
   * export const ExampleComponent = () => {
   *   const store = useStore()
   *   return <div>{store.getState()}</div>
   * }
   */

  var useStore = /*#__PURE__*/createStoreHook();

  /**
   * Hook factory, which creates a `useDispatch` hook bound to a given context.
   *
   * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
   * @returns {Function} A `useDispatch` hook bound to the specified context.
   */

  function createDispatchHook(context) {
    if (context === void 0) {
      context = ReactReduxContext;
    }

    var useStore$1 = context === ReactReduxContext ? useStore : createStoreHook(context);
    return function useDispatch() {
      var store = useStore$1();
      return store.dispatch;
    };
  }

  var refEquality = function refEquality(a, b) {
    return a === b;
  };

  function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
    var _useReducer = react.exports.useReducer(function (s) {
      return s + 1;
    }, 0),
        forceRender = _useReducer[1];

    var subscription = react.exports.useMemo(function () {
      return createSubscription(store, contextSub);
    }, [store, contextSub]);
    var latestSubscriptionCallbackError = react.exports.useRef();
    var latestSelector = react.exports.useRef();
    var latestStoreState = react.exports.useRef();
    var latestSelectedState = react.exports.useRef();
    var storeState = store.getState();
    var selectedState;

    try {
      if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
        var newSelectedState = selector(storeState); // ensure latest selected state is reused so that a custom equality function can result in identical references

        if (latestSelectedState.current === undefined || !equalityFn(newSelectedState, latestSelectedState.current)) {
          selectedState = newSelectedState;
        } else {
          selectedState = latestSelectedState.current;
        }
      } else {
        selectedState = latestSelectedState.current;
      }
    } catch (err) {
      if (latestSubscriptionCallbackError.current) {
        err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
      }

      throw err;
    }

    useIsomorphicLayoutEffect(function () {
      latestSelector.current = selector;
      latestStoreState.current = storeState;
      latestSelectedState.current = selectedState;
      latestSubscriptionCallbackError.current = undefined;
    });
    useIsomorphicLayoutEffect(function () {
      function checkForUpdates() {
        try {
          var newStoreState = store.getState(); // Avoid calling selector multiple times if the store's state has not changed

          if (newStoreState === latestStoreState.current) {
            return;
          }

          var _newSelectedState = latestSelector.current(newStoreState);

          if (equalityFn(_newSelectedState, latestSelectedState.current)) {
            return;
          }

          latestSelectedState.current = _newSelectedState;
          latestStoreState.current = newStoreState;
        } catch (err) {
          // we ignore all errors here, since when the component
          // is re-rendered, the selectors are called again, and
          // will throw again, if neither props nor store state
          // changed
          latestSubscriptionCallbackError.current = err;
        }

        forceRender();
      }

      subscription.onStateChange = checkForUpdates;
      subscription.trySubscribe();
      checkForUpdates();
      return function () {
        return subscription.tryUnsubscribe();
      };
    }, [store, subscription]);
    return selectedState;
  }
  /**
   * Hook factory, which creates a `useSelector` hook bound to a given context.
   *
   * @param {React.Context} [context=ReactReduxContext] Context passed to your `<Provider>`.
   * @returns {Function} A `useSelector` hook bound to the specified context.
   */


  function createSelectorHook(context) {
    if (context === void 0) {
      context = ReactReduxContext;
    }

    var useReduxContext$1 = context === ReactReduxContext ? useReduxContext : function () {
      return react.exports.useContext(context);
    };
    return function useSelector(selector, equalityFn) {
      if (equalityFn === void 0) {
        equalityFn = refEquality;
      }

      var _useReduxContext = useReduxContext$1(),
          store = _useReduxContext.store,
          contextSub = _useReduxContext.subscription;

      var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
      react.exports.useDebugValue(selectedState);
      return selectedState;
    };
  }

  // with standard React renderers (ReactDOM, React Native)

  setBatch(reactDom.exports.unstable_batchedUpdates);

  const GuestReduxContext = /*#__PURE__*/React.createContext(null);

  const useDispatch = createDispatchHook(GuestReduxContext);
  const useSelector = createSelectorHook(GuestReduxContext);
  createStoreHook(GuestReduxContext);
  const GuestContext = /*#__PURE__*/React.createContext(null);
  function useGuestContext() {
    return react.exports.useContext(GuestContext);
  }
  function GuestContextProvider(props) {
    const value = react.exports.useMemo(() => props.value, [props.value]);
    return /*#__PURE__*/React.createElement(GuestContext.Provider, _extends$6({}, props, {
      value: value
    }));
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function CrafterCMSPortal(props) {
    const portalRef = react.exports.useRef(null);

    if (portalRef.current === null) {
      portalRef.current = document.createElement('craftercms-portal');
    }

    react.exports.useLayoutEffect(() => {
      const body = document.body;
      const portal = portalRef.current;
      body.appendChild(portal);
      return () => {
        body.removeChild(portal);
      };
    }, []);
    return /*#__PURE__*/reactDom.exports.createPortal(props.children, portalRef.current);
  }

  const common = {
    black: '#000',
    white: '#fff'
  };
  var common$1 = common;

  const red = {
    50: '#ffebee',
    100: '#ffcdd2',
    200: '#ef9a9a',
    300: '#e57373',
    400: '#ef5350',
    500: '#f44336',
    600: '#e53935',
    700: '#d32f2f',
    800: '#c62828',
    900: '#b71c1c',
    A100: '#ff8a80',
    A200: '#ff5252',
    A400: '#ff1744',
    A700: '#d50000'
  };
  var red$1 = red;

  const purple = {
    50: '#f3e5f5',
    100: '#e1bee7',
    200: '#ce93d8',
    300: '#ba68c8',
    400: '#ab47bc',
    500: '#9c27b0',
    600: '#8e24aa',
    700: '#7b1fa2',
    800: '#6a1b9a',
    900: '#4a148c',
    A100: '#ea80fc',
    A200: '#e040fb',
    A400: '#d500f9',
    A700: '#aa00ff'
  };
  var purple$1 = purple;

  const blue = {
    50: '#e3f2fd',
    100: '#bbdefb',
    200: '#90caf9',
    300: '#64b5f6',
    400: '#42a5f5',
    500: '#2196f3',
    600: '#1e88e5',
    700: '#1976d2',
    800: '#1565c0',
    900: '#0d47a1',
    A100: '#82b1ff',
    A200: '#448aff',
    A400: '#2979ff',
    A700: '#2962ff'
  };
  var blue$1 = blue;

  const lightBlue = {
    50: '#e1f5fe',
    100: '#b3e5fc',
    200: '#81d4fa',
    300: '#4fc3f7',
    400: '#29b6f6',
    500: '#03a9f4',
    600: '#039be5',
    700: '#0288d1',
    800: '#0277bd',
    900: '#01579b',
    A100: '#80d8ff',
    A200: '#40c4ff',
    A400: '#00b0ff',
    A700: '#0091ea'
  };
  var lightBlue$1 = lightBlue;

  const green = {
    50: '#e8f5e9',
    100: '#c8e6c9',
    200: '#a5d6a7',
    300: '#81c784',
    400: '#66bb6a',
    500: '#4caf50',
    600: '#43a047',
    700: '#388e3c',
    800: '#2e7d32',
    900: '#1b5e20',
    A100: '#b9f6ca',
    A200: '#69f0ae',
    A400: '#00e676',
    A700: '#00c853'
  };
  var green$1 = green;

  const orange = {
    50: '#fff3e0',
    100: '#ffe0b2',
    200: '#ffcc80',
    300: '#ffb74d',
    400: '#ffa726',
    500: '#ff9800',
    600: '#fb8c00',
    700: '#f57c00',
    800: '#ef6c00',
    900: '#e65100',
    A100: '#ffd180',
    A200: '#ffab40',
    A400: '#ff9100',
    A700: '#ff6d00'
  };
  var orange$1 = orange;

  const grey = {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#eeeeee',
    300: '#e0e0e0',
    400: '#bdbdbd',
    500: '#9e9e9e',
    600: '#757575',
    700: '#616161',
    800: '#424242',
    900: '#212121',
    A100: '#f5f5f5',
    A200: '#eeeeee',
    A400: '#bdbdbd',
    A700: '#616161'
  };
  var grey$1 = grey;

  function _extends$4() {
    _extends$4 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$4.apply(this, arguments);
  }

  function _objectWithoutPropertiesLoose$2(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function memoize$1(fn) {
    var cache = Object.create(null);
    return function (arg) {
      if (cache[arg] === undefined) cache[arg] = fn(arg);
      return cache[arg];
    };
  }

  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23

  var isPropValid = /* #__PURE__ */memoize$1(function (prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111
    /* o */
    && prop.charCodeAt(1) === 110
    /* n */
    && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
  );

  /*

  Based off glamor's StyleSheet, thanks Sunil ❤️

  high performance StyleSheet for css-in-js systems

  - uses multiple style tags behind the scenes for millions of rules
  - uses `insertRule` for appending in production for *much* faster performance

  // usage

  import { StyleSheet } from '@emotion/sheet'

  let styleSheet = new StyleSheet({ key: '', container: document.head })

  styleSheet.insert('#box { border: 1px solid red; }')
  - appends a css rule into the stylesheet

  styleSheet.flush()
  - empties the stylesheet of all its contents

  */
  // $FlowFixMe
  function sheetForTag(tag) {
    if (tag.sheet) {
      // $FlowFixMe
      return tag.sheet;
    } // this weirdness brought to you by firefox

    /* istanbul ignore next */


    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        // $FlowFixMe
        return document.styleSheets[i];
      }
    }
  }

  function createStyleElement(options) {
    var tag = document.createElement('style');
    tag.setAttribute('data-emotion', options.key);

    if (options.nonce !== undefined) {
      tag.setAttribute('nonce', options.nonce);
    }

    tag.appendChild(document.createTextNode(''));
    tag.setAttribute('data-s', '');
    return tag;
  }

  var StyleSheet = /*#__PURE__*/function () {
    function StyleSheet(options) {
      var _this = this;

      this._insertTag = function (tag) {
        var before;

        if (_this.tags.length === 0) {
          before = _this.prepend ? _this.container.firstChild : _this.before;
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }

        _this.container.insertBefore(tag, before);

        _this.tags.push(tag);
      };

      this.isSpeedy = options.speedy === undefined ? "production" === 'production' : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets

      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.before = null;
    }

    var _proto = StyleSheet.prototype;

    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };

    _proto.insert = function insert(rule) {
      // the max length is how many rules we have per style tag, it's 65000 in speedy mode
      // it's 1 in dev because we insert source maps that map a single rule to a location
      // and you can only have one source map per style tag
      if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }

      var tag = this.tags[this.tags.length - 1];

      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);

        try {
          // this is the ultrafast version, works across browsers
          // the big drawback is that the css won't be editable in devtools
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }

      this.ctr++;
    };

    _proto.flush = function flush() {
      // $FlowFixMe
      this.tags.forEach(function (tag) {
        return tag.parentNode && tag.parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };

    return StyleSheet;
  }();

  var MS = '-ms-';
  var MOZ = '-moz-';
  var WEBKIT = '-webkit-';
  var COMMENT = 'comm';
  var RULESET = 'rule';
  var DECLARATION = 'decl';
  var IMPORT = '@import';
  var KEYFRAMES = '@keyframes';

  /**
   * @param {number}
   * @return {number}
   */
  var abs = Math.abs;
  /**
   * @param {number}
   * @return {string}
   */

  var from = String.fromCharCode;
  /**
   * @param {string} value
   * @param {number} length
   * @return {number}
   */

  function hash$2(value, length) {
    return (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3);
  }
  /**
   * @param {string} value
   * @return {string}
   */

  function trim(value) {
    return value.trim();
  }
  /**
   * @param {string} value
   * @param {RegExp} pattern
   * @return {string?}
   */

  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  /**
   * @param {string} value
   * @param {(string|RegExp)} pattern
   * @param {string} replacement
   * @return {string}
   */

  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  /**
   * @param {string} value
   * @param {string} value
   * @return {number}
   */

  function indexof(value, search) {
    return value.indexOf(search);
  }
  /**
   * @param {string} value
   * @param {number} index
   * @return {number}
   */

  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  /**
   * @param {string} value
   * @param {number} begin
   * @param {number} end
   * @return {string}
   */

  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  /**
   * @param {string} value
   * @return {number}
   */

  function strlen(value) {
    return value.length;
  }
  /**
   * @param {any[]} value
   * @return {number}
   */

  function sizeof(value) {
    return value.length;
  }
  /**
   * @param {any} value
   * @param {any[]} array
   * @return {any}
   */

  function append(value, array) {
    return array.push(value), value;
  }
  /**
   * @param {string[]} array
   * @param {function} callback
   * @return {string}
   */

  function combine(array, callback) {
    return array.map(callback).join('');
  }

  var line = 1;
  var column = 1;
  var length = 0;
  var position$1 = 0;
  var character = 0;
  var characters = '';
  /**
   * @param {string} value
   * @param {object} root
   * @param {object?} parent
   * @param {string} type
   * @param {string[]} props
   * @param {object[]} children
   * @param {number} length
   */

  function node(value, root, parent, type, props, children, length) {
    return {
      value: value,
      root: root,
      parent: parent,
      type: type,
      props: props,
      children: children,
      line: line,
      column: column,
      length: length,
      return: ''
    };
  }
  /**
   * @param {string} value
   * @param {object} root
   * @param {string} type
   */

  function copy(value, root, type) {
    return node(value, root.root, root.parent, type, root.props, root.children, 0);
  }
  /**
   * @return {number}
   */

  function char() {
    return character;
  }
  /**
   * @return {number}
   */

  function prev() {
    character = position$1 > 0 ? charat(characters, --position$1) : 0;
    if (column--, character === 10) column = 1, line--;
    return character;
  }
  /**
   * @return {number}
   */

  function next() {
    character = position$1 < length ? charat(characters, position$1++) : 0;
    if (column++, character === 10) column = 1, line++;
    return character;
  }
  /**
   * @return {number}
   */

  function peek() {
    return charat(characters, position$1);
  }
  /**
   * @return {number}
   */

  function caret() {
    return position$1;
  }
  /**
   * @param {number} begin
   * @param {number} end
   * @return {string}
   */

  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  /**
   * @param {number} type
   * @return {number}
   */

  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token

      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126: // ; { } breakpoint token

      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token

      case 58:
        return 3;
      // " ' ( [ opening delimit token

      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token

      case 41:
      case 93:
        return 1;
    }

    return 0;
  }
  /**
   * @param {string} value
   * @return {any[]}
   */

  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position$1 = 0, [];
  }
  /**
   * @param {any} value
   * @return {any}
   */

  function dealloc(value) {
    return characters = '', value;
  }
  /**
   * @param {number} type
   * @return {string}
   */

  function delimit(type) {
    return trim(slice(position$1 - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  /**
   * @param {number} type
   * @return {string}
   */

  function whitespace(type) {
    while (character = peek()) if (character < 33) next();else break;

    return token(type) > 2 || token(character) > 3 ? '' : ' ';
  }
  /**
   * @param {number} index
   * @param {number} count
   * @return {string}
   */

  function escaping(index, count) {
    while (--count && next()) // not 0-9 A-F a-f
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;

    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  /**
   * @param {number} type
   * @return {number}
   */

  function delimiter(type) {
    while (next()) switch (character) {
      // ] ) " '
      case type:
        return position$1;
      // " '

      case 34:
      case 39:
        return delimiter(type === 34 || type === 39 ? type : character);
      // (

      case 40:
        if (type === 41) delimiter(type);
        break;
      // \

      case 92:
        next();
        break;
    }

    return position$1;
  }
  /**
   * @param {number} type
   * @param {number} index
   * @return {number}
   */

  function commenter(type, index) {
    while (next()) // //
    if (type + character === 47 + 10) break; // /*
    else if (type + character === 42 + 42 && peek() === 47) break;

    return '/*' + slice(index, position$1 - 1) + '*' + from(type === 47 ? type : next());
  }
  /**
   * @param {number} index
   * @return {string}
   */

  function identifier(index) {
    while (!token(peek())) next();

    return slice(index, position$1);
  }

  /**
   * @param {string} value
   * @return {object[]}
   */

  function compile(value) {
    return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value));
  }
  /**
   * @param {string} value
   * @param {object} root
   * @param {object?} parent
   * @param {string[]} rule
   * @param {string[]} rules
   * @param {string[]} rulesets
   * @param {number[]} pseudo
   * @param {number[]} points
   * @param {string[]} declarations
   * @return {object}
   */

  function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset = 0;
    var length = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character = 0;
    var type = '';
    var props = rules;
    var children = rulesets;
    var reference = rule;
    var characters = type;

    while (scanning) switch (previous = character, character = next()) {
      // " ' [ (
      case 34:
      case 39:
      case 91:
      case 40:
        characters += delimit(character);
        break;
      // \t \n \r \s

      case 9:
      case 10:
      case 13:
      case 32:
        characters += whitespace(previous);
        break;
      // \

      case 92:
        characters += escaping(caret() - 1, 7);
        continue;
      // /

      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;

          default:
            characters += '/';
        }

        break;
      // {

      case 123 * variable:
        points[index++] = strlen(characters) * ampersand;
      // } ; \0

      case 125 * variable:
      case 59:
      case 0:
        switch (character) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;

          case 59 + offset:
            if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + ';', rule, parent, length - 1) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2), declarations);
            break;
          // @ ;

          case 59:
            characters += ';';
          // { rule/at-rule

          default:
            append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);
            if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);else switch (atrule) {
              // d m s
              case 100:
              case 109:
              case 115:
                parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);
                break;

              default:
                parse(characters, reference, reference, reference, [''], children, length, points, children);
            }
        }

        index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
        break;
      // :

      case 58:
        length = 1 + strlen(characters), property = previous;

      default:
        if (variable < 1) if (character == 123) --variable;else if (character == 125 && variable++ == 0 && prev() == 125) continue;

        switch (characters += from(character), character * variable) {
          // &
          case 38:
            ampersand = offset > 0 ? 1 : (characters += '\f', -1);
            break;
          // ,

          case 44:
            points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
            break;
          // @

          case 64:
            // -
            if (peek() === 45) characters += delimit(next());
            atrule = peek(), offset = strlen(type = characters += identifier(caret())), character++;
            break;
          // -

          case 45:
            if (previous === 45 && strlen(characters) == 2) variable = 0;
        }

    }

    return rulesets;
  }
  /**
   * @param {string} value
   * @param {object} root
   * @param {object?} parent
   * @param {number} index
   * @param {number} offset
   * @param {string[]} rules
   * @param {number[]} points
   * @param {string} type
   * @param {string[]} props
   * @param {string[]} children
   * @param {number} length
   * @return {object}
   */

  function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {
    var post = offset - 1;
    var rule = offset === 0 ? rules : [''];
    var size = sizeof(rule);

    for (var i = 0, j = 0, k = 0; i < index; ++i) for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x) if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x]))) props[k++] = z;

    return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);
  }
  /**
   * @param {number} value
   * @param {object} root
   * @param {object?} parent
   * @return {object}
   */

  function comment(value, root, parent) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  /**
   * @param {string} value
   * @param {object} root
   * @param {object?} parent
   * @param {number} length
   * @return {object}
   */

  function declaration(value, root, parent, length) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);
  }

  /**
   * @param {string} value
   * @param {number} length
   * @return {string}
   */

  function prefix(value, length) {
    switch (hash$2(value, length)) {
      // color-adjust
      case 5103:
        return WEBKIT + 'print-' + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)

      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921: // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break

      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005: // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,

      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855: // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)

      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust

      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction

      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order

      case 6165:
        return WEBKIT + value + MS + 'flex-' + value + value;
      // align-items

      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + 'box-$1$2' + MS + 'flex-$1$2') + value;
      // align-self

      case 5443:
        return WEBKIT + value + MS + 'flex-item-' + replace(value, /flex-|-self/, '') + value;
      // align-content

      case 4675:
        return WEBKIT + value + MS + 'flex-line-pack' + replace(value, /align-content|flex-|-self/, '') + value;
      // flex-shrink

      case 5548:
        return WEBKIT + value + MS + replace(value, 'shrink', 'negative') + value;
      // flex-basis

      case 5292:
        return WEBKIT + value + MS + replace(value, 'basis', 'preferred-size') + value;
      // flex-grow

      case 6060:
        return WEBKIT + 'box-' + replace(value, '-grow', '') + WEBKIT + value + MS + replace(value, 'grow', 'positive') + value;
      // transition

      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, '$1' + WEBKIT + '$2') + value;
      // cursor

      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + '$1'), /(image-set)/, WEBKIT + '$1'), value, '') + value;
      // background, background-image

      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + '$1' + '$`$1');
      // justify-content

      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + 'box-pack:$3' + MS + 'flex-pack:$3'), /s.+-b[^;]+/, 'justify') + WEBKIT + value + value;
      // (margin|padding)-inline-(start|end)

      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + '$1$2') + value;
      // (min|max)?(width|height|inline-size|block-size)

      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        // stretch, max-content, min-content, fill-available
        if (strlen(value) - 1 - length > 6) switch (charat(value, length + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            // -
            if (charat(value, length + 4) !== 45) break;
          // (f)ill-available, (f)it-content

          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, '$1' + WEBKIT + '$2-$3' + '$1' + MOZ + (charat(value, length + 3) == 108 ? '$3' : '$2-$3')) + value;
          // (s)tretch

          case 115:
            return ~indexof(value, 'stretch') ? prefix(replace(value, 'stretch', 'fill-available'), length) + value : value;
        }
        break;
      // position: sticky

      case 4949:
        // (s)ticky?
        if (charat(value, length + 1) !== 115) break;
      // display: (flex|inline-flex)

      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, '!important') && 10))) {
          // stic(k)y
          case 107:
            return replace(value, ':', ':' + WEBKIT) + value;
          // (inline-)?fl(e)x

          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, '$1' + WEBKIT + (charat(value, 14) === 45 ? 'inline-' : '') + 'box$3' + '$1' + WEBKIT + '$2$3' + '$1' + MS + '$2box$3') + value;
        }

        break;
      // writing-mode

      case 5936:
        switch (charat(value, length + 11)) {
          // vertical-l(r)
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb') + value;
          // vertical-r(l)

          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'tb-rl') + value;
          // horizontal(-)tb

          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, 'lr') + value;
        }

        return WEBKIT + value + MS + value + value;
    }

    return value;
  }

  /**
   * @param {object[]} children
   * @param {function} callback
   * @return {string}
   */

  function serialize(children, callback) {
    var output = '';
    var length = sizeof(children);

    for (var i = 0; i < length; i++) output += callback(children[i], i, children, callback) || '';

    return output;
  }
  /**
   * @param {object} element
   * @param {number} index
   * @param {object[]} children
   * @param {function} callback
   * @return {string}
   */

  function stringify(element, index, children, callback) {
    switch (element.type) {
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;

      case COMMENT:
        return '';

      case RULESET:
        element.value = element.props.join(',');
    }

    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : '';
  }

  /**
   * @param {function[]} collection
   * @return {function}
   */

  function middleware(collection) {
    var length = sizeof(collection);
    return function (element, index, children, callback) {
      var output = '';

      for (var i = 0; i < length; i++) output += collection[i](element, index, children, callback) || '';

      return output;
    };
  }
  /**
   * @param {function} callback
   * @return {function}
   */

  function rulesheet(callback) {
    return function (element) {
      if (!element.root) if (element = element.return) callback(element);
    };
  }
  /**
   * @param {object} element
   * @param {number} index
   * @param {object[]} children
   * @param {function} callback
   */

  function prefixer(element, index, children, callback) {
    if (!element.return) switch (element.type) {
      case DECLARATION:
        element.return = prefix(element.value, element.length);
        break;

      case KEYFRAMES:
        return serialize([copy(replace(element.value, '@', '@' + WEBKIT), element, '')], callback);

      case RULESET:
        if (element.length) return combine(element.props, function (value) {
          switch (match(value, /(::plac\w+|:read-\w+)/)) {
            // :read-(only|write)
            case ':read-only':
            case ':read-write':
              return serialize([copy(replace(value, /:(read-\w+)/, ':' + MOZ + '$1'), element, '')], callback);
            // :placeholder

            case '::placeholder':
              return serialize([copy(replace(value, /:(plac\w+)/, ':' + WEBKIT + 'input-$1'), element, ''), copy(replace(value, /:(plac\w+)/, ':' + MOZ + '$1'), element, ''), copy(replace(value, /:(plac\w+)/, MS + 'input-$1'), element, '')], callback);
          }

          return '';
        });
    }
  }

  var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
    var previous = 0;
    var character = 0;

    while (true) {
      previous = character;
      character = peek(); // &\f

      if (previous === 38 && character === 12) {
        points[index] = 1;
      }

      if (token(character)) {
        break;
      }

      next();
    }

    return slice(begin, position$1);
  };

  var toRules = function toRules(parsed, points) {
    // pretend we've started with a comma
    var index = -1;
    var character = 44;

    do {
      switch (token(character)) {
        case 0:
          // &\f
          if (character === 38 && peek() === 12) {
            // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
            // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
            // and when it should just concatenate the outer and inner selectors
            // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
            points[index] = 1;
          }

          parsed[index] += identifierWithPointTracking(position$1 - 1, points, index);
          break;

        case 2:
          parsed[index] += delimit(character);
          break;

        case 4:
          // comma
          if (character === 44) {
            // colon
            parsed[++index] = peek() === 58 ? '&\f' : '';
            points[index] = parsed[index].length;
            break;
          }

        // fallthrough

        default:
          parsed[index] += from(character);
      }
    } while (character = next());

    return parsed;
  };

  var getRules = function getRules(value, points) {
    return dealloc(toRules(alloc(value), points));
  }; // WeakSet would be more appropriate, but only WeakMap is supported in IE11


  var fixedElements = /* #__PURE__ */new WeakMap();

  var compat = function compat(element) {
    if (element.type !== 'rule' || !element.parent || // .length indicates if this rule contains pseudo or not
    !element.length) {
      return;
    }

    var value = element.value,
        parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;

    while (parent.type !== 'rule') {
      parent = parent.parent;
      if (!parent) return;
    } // short-circuit for the simplest case


    if (element.props.length === 1 && value.charCodeAt(0) !== 58
    /* colon */
    && !fixedElements.get(parent)) {
      return;
    } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
    // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"


    if (isImplicitRule) {
      return;
    }

    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;

    for (var i = 0, k = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };

  var removeLabel = function removeLabel(element) {
    if (element.type === 'decl') {
      var value = element.value;

      if ( // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98) {
        // this ignores label
        element["return"] = '';
        element.value = '';
      }
    }
  };

  var defaultStylisPlugins = [prefixer];

  var createCache = function createCache(options) {
    var key = options.key;

    if (key === 'css') {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
      // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
      // note this very very intentionally targets all style elements regardless of the key to ensure
      // that creating a cache works inside of render of a React component

      Array.prototype.forEach.call(ssrStyles, function (node) {
        // we want to only move elements which have a space in the data-emotion attribute value
        // because that indicates that it is an Emotion 11 server-side rendered style elements
        // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
        // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
        // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
        // will not result in the Emotion 10 styles being destroyed
        var dataEmotionAttribute = node.getAttribute('data-emotion');

        if (dataEmotionAttribute.indexOf(' ') === -1) {
          return;
        }

        document.head.appendChild(node);
        node.setAttribute('data-s', '');
      });
    }

    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;

    var inserted = {}; // $FlowFixMe

    var container;
    var nodesToHydrate = [];
    {
      container = options.container || document.head;
      Array.prototype.forEach.call( // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll("style[data-emotion^=\"" + key + " \"]"), function (node) {
        var attrib = node.getAttribute("data-emotion").split(' '); // $FlowFixMe

        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }

        nodesToHydrate.push(node);
      });
    }

    var _insert;

    var omnipresentPlugins = [compat, removeLabel];

    {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function (rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));

      var stylis = function stylis(styles) {
        return serialize(compile(styles), serializer);
      };

      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;

        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);

        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    }
    var cache = {
      key: key,
      sheet: new StyleSheet({
        key: key,
        container: container,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend
      }),
      nonce: options.nonce,
      inserted: inserted,
      registered: {},
      insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };

  var isBrowser = "object" !== 'undefined';

  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = '';
    classNames.split(' ').forEach(function (className) {
      if (registered[className] !== undefined) {
        registeredStyles.push(registered[className] + ";");
      } else {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }

  var insertStyles = function insertStyles(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;

    if ( // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === undefined) {
      cache.registered[className] = serialized.styles;
    }

    if (cache.inserted[serialized.name] === undefined) {
      var current = serialized;

      do {
        cache.insert(serialized === current ? "." + className : '', current, cache.sheet, true);
        current = current.next;
      } while (current !== undefined);
    }
  };

  /* eslint-disable */
  // Inspired by https://github.com/garycourt/murmurhash-js
  // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
  function murmur2(str) {
    // 'm' and 'r' are mixing constants generated offline.
    // They're not really 'magic', they just happen to work well.
    // const m = 0x5bd1e995;
    // const r = 24;
    // Initialize the hash
    var h = 0; // Mix 4 bytes at a time into the hash

    var k,
        i = 0,
        len = str.length;

    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k =
      /* Math.imul(k, m): */
      (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
      k ^=
      /* k >>> r: */
      k >>> 24;
      h =
      /* Math.imul(k, m): */
      (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Handle the last few bytes of the input array


    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h =
        /* Math.imul(h, m): */
        (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.


    h ^= h >>> 13;
    h =
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;

  var isCustomProperty = function isCustomProperty(property) {
    return property.charCodeAt(1) === 45;
  };

  var isProcessableValue = function isProcessableValue(value) {
    return value != null && typeof value !== 'boolean';
  };

  var processStyleName = /* #__PURE__ */memoize$1(function (styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, '-$&').toLowerCase();
  });

  var processStyleValue = function processStyleValue(key, value) {
    switch (key) {
      case 'animation':
      case 'animationName':
        {
          if (typeof value === 'string') {
            return value.replace(animationRegex, function (match, p1, p2) {
              cursor = {
                name: p1,
                styles: p2,
                next: cursor
              };
              return p1;
            });
          }
        }
    }

    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === 'number' && value !== 0) {
      return value + 'px';
    }

    return value;
  };

  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return '';
    }

    if (interpolation.__emotion_styles !== undefined) {

      return interpolation;
    }

    switch (typeof interpolation) {
      case 'boolean':
        {
          return '';
        }

      case 'object':
        {
          if (interpolation.anim === 1) {
            cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            };
            return interpolation.name;
          }

          if (interpolation.styles !== undefined) {
            var next = interpolation.next;

            if (next !== undefined) {
              // not the most efficient thing ever but this is a pretty rare case
              // and there will be very few iterations of this generally
              while (next !== undefined) {
                cursor = {
                  name: next.name,
                  styles: next.styles,
                  next: cursor
                };
                next = next.next;
              }
            }

            var styles = interpolation.styles + ";";

            return styles;
          }

          return createStringFromObject(mergedProps, registered, interpolation);
        }

      case 'function':
        {
          if (mergedProps !== undefined) {
            var previousCursor = cursor;
            var result = interpolation(mergedProps);
            cursor = previousCursor;
            return handleInterpolation(mergedProps, registered, result);
          }

          break;
        }
    } // finalize string values (regular strings and functions interpolated into css calls)


    if (registered == null) {
      return interpolation;
    }

    var cached = registered[interpolation];
    return cached !== undefined ? cached : interpolation;
  }

  function createStringFromObject(mergedProps, registered, obj) {
    var string = '';

    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var _key in obj) {
        var value = obj[_key];

        if (typeof value !== 'object') {
          if (registered != null && registered[value] !== undefined) {
            string += _key + "{" + registered[value] + "}";
          } else if (isProcessableValue(value)) {
            string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
          }
        } else {
          if (_key === 'NO_COMPONENT_SELECTOR' && "production" !== 'production') {
            throw new Error('Component selectors can only be used in conjunction with @emotion/babel-plugin.');
          }

          if (Array.isArray(value) && typeof value[0] === 'string' && (registered == null || registered[value[0]] === undefined)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);

            switch (_key) {
              case 'animation':
              case 'animationName':
                {
                  string += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }

              default:
                {

                  string += _key + "{" + interpolated + "}";
                }
            }
          }
        }
      }
    }

    return string;
  }

  var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
  // keyframes are stored on the SerializedStyles object as a linked list


  var cursor;

  var serializeStyles = function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === 'object' && args[0] !== null && args[0].styles !== undefined) {
      return args[0];
    }

    var stringMode = true;
    var styles = '';
    cursor = undefined;
    var strings = args[0];

    if (strings == null || strings.raw === undefined) {
      stringMode = false;
      styles += handleInterpolation(mergedProps, registered, strings);
    } else {

      styles += strings[0];
    } // we start at 1 since we've already handled the first arg


    for (var i = 1; i < args.length; i++) {
      styles += handleInterpolation(mergedProps, registered, args[i]);

      if (stringMode) {

        styles += strings[i];
      }
    }


    labelPattern.lastIndex = 0;
    var identifierName = '';
    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5

    while ((match = labelPattern.exec(styles)) !== null) {
      identifierName += '-' + // $FlowFixMe we know it's not null
      match[1];
    }

    var name = murmur2(styles) + identifierName;

    return {
      name: name,
      styles: styles,
      next: cursor
    };
  };

  var EmotionCacheContext = /* #__PURE__ */react.exports.createContext( // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== 'undefined' ? /* #__PURE__ */createCache({
    key: 'css'
  }) : null);

  EmotionCacheContext.Provider;

  var withEmotionCache = function withEmotionCache(func) {
    // $FlowFixMe
    return /*#__PURE__*/react.exports.forwardRef(function (props, ref) {
      // the cache will never be null in the browser
      var cache = react.exports.useContext(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };

  var ThemeContext$2 = /* #__PURE__ */react.exports.createContext({});

  // initial render from browser, insertBefore context.sheet.tags[0] or if a style hasn't been inserted there yet, appendChild
  // initial client-side render from SSR, use place of hydrating tag

  var Global = /* #__PURE__ */withEmotionCache(function (props, cache) {

    var styles = props.styles;
    var serialized = serializeStyles([styles], undefined, react.exports.useContext(ThemeContext$2)); // but it is based on a constant that will never change at runtime
    // it's effectively like having two implementations and switching them out
    // so it's not actually breaking anything

    var sheetRef = react.exports.useRef();
    react.exports.useLayoutEffect(function () {
      var key = cache.key + "-global";
      var sheet = new StyleSheet({
        key: key,
        nonce: cache.sheet.nonce,
        container: cache.sheet.container,
        speedy: cache.sheet.isSpeedy
      });
      var rehydrating = false; // $FlowFixMe

      var node = document.querySelector("style[data-emotion=\"" + key + " " + serialized.name + "\"]");

      if (cache.sheet.tags.length) {
        sheet.before = cache.sheet.tags[0];
      }

      if (node !== null) {
        rehydrating = true; // clear the hash so this node won't be recognizable as rehydratable by other <Global/>s

        node.setAttribute('data-emotion', key);
        sheet.hydrate([node]);
      }

      sheetRef.current = [sheet, rehydrating];
      return function () {
        sheet.flush();
      };
    }, [cache]);
    react.exports.useLayoutEffect(function () {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0],
          rehydrating = sheetRefCurrent[1];

      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }

      if (serialized.next !== undefined) {
        // insert keyframes
        insertStyles(cache, serialized.next, true);
      }

      if (sheet.tags.length) {
        // if this doesn't exist then it will be null so the style element will be appended
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }

      cache.insert("", serialized, sheet, false);
    }, [cache, serialized.name]);
    return null;
  });

  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return serializeStyles(args);
  }

  var keyframes = function keyframes() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name; // $FlowFixMe

    return {
      name: name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  };

  var testOmitPropsOnStringTag = isPropValid;

  var testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {
    return key !== 'theme';
  };

  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {
    return typeof tag === 'string' && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };

  var composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {
    var shouldForwardProp;

    if (options) {
      var optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function (propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }

    if (typeof shouldForwardProp !== 'function' && isReal) {
      shouldForwardProp = tag.__emotion_forwardProp;
    }

    return shouldForwardProp;
  };

  var createStyled$1 = function createStyled(tag, options) {

    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;

    if (options !== undefined) {
      identifierName = options.label;
      targetClassName = options.target;
    }

    var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp('as');
    return function () {
      var args = arguments;
      var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];

      if (identifierName !== undefined) {
        styles.push("label:" + identifierName + ";");
      }

      if (args[0] == null || args[0].raw === undefined) {
        styles.push.apply(styles, args);
      } else {

        styles.push(args[0][0]);
        var len = args.length;
        var i = 1;

        for (; i < len; i++) {

          styles.push(args[i], args[0][i]);
        }
      } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class


      var Styled = withEmotionCache(function (props, cache, ref) {
        var finalTag = shouldUseAs && props.as || baseTag;
        var className = '';
        var classInterpolations = [];
        var mergedProps = props;

        if (props.theme == null) {
          mergedProps = {};

          for (var key in props) {
            mergedProps[key] = props[key];
          }

          mergedProps.theme = react.exports.useContext(ThemeContext$2);
        }

        if (typeof props.className === 'string') {
          className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }

        var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);
        insertStyles(cache, serialized, typeof finalTag === 'string');
        className += cache.key + "-" + serialized.name;

        if (targetClassName !== undefined) {
          className += " " + targetClassName;
        }

        var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(finalTag) : defaultShouldForwardProp;
        var newProps = {};

        for (var _key in props) {
          if (shouldUseAs && _key === 'as') continue;

          if ( // $FlowFixMe
          finalShouldForwardProp(_key)) {
            newProps[_key] = props[_key];
          }
        }

        newProps.className = className;
        newProps.ref = ref;
        var ele = /*#__PURE__*/react.exports.createElement(finalTag, newProps);
        return ele;
      });
      Styled.displayName = identifierName !== undefined ? identifierName : "Styled(" + (typeof baseTag === 'string' ? baseTag : baseTag.displayName || baseTag.name || 'Component') + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles;
      Styled.__emotion_forwardProp = shouldForwardProp;
      Object.defineProperty(Styled, 'toString', {
        value: function value() {
          if (targetClassName === undefined && "production" !== 'production') {
            return 'NO_COMPONENT_SELECTOR';
          } // $FlowFixMe: coerce undefined to string


          return "." + targetClassName;
        }
      });

      Styled.withComponent = function (nextTag, nextOptions) {
        return createStyled(nextTag, _extends$5({}, options, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        })).apply(void 0, styles);
      };

      return Styled;
    };
  };

  var tags = ['a', 'abbr', 'address', 'area', 'article', 'aside', 'audio', 'b', 'base', 'bdi', 'bdo', 'big', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'cite', 'code', 'col', 'colgroup', 'data', 'datalist', 'dd', 'del', 'details', 'dfn', 'dialog', 'div', 'dl', 'dt', 'em', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'iframe', 'img', 'input', 'ins', 'kbd', 'keygen', 'label', 'legend', 'li', 'link', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meta', 'meter', 'nav', 'noscript', 'object', 'ol', 'optgroup', 'option', 'output', 'p', 'param', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'script', 'section', 'select', 'small', 'source', 'span', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'thead', 'time', 'title', 'tr', 'track', 'u', 'ul', 'var', 'video', 'wbr', // SVG
  'circle', 'clipPath', 'defs', 'ellipse', 'foreignObject', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'svg', 'text', 'tspan'];
  var newStyled = createStyled$1.bind();
  tags.forEach(function (tagName) {
    // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type
    newStyled[tagName] = newStyled(tagName);
  });
  var emStyled = newStyled;

  var jsxRuntime = {exports: {}};

  var reactJsxRuntime_production_min = {};

  /** @license React v17.0.2
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */



  var f = react.exports,
      g = 60103;

  reactJsxRuntime_production_min.Fragment = 60107;

  if ("function" === typeof Symbol && Symbol.for) {
    var h = Symbol.for;
    g = h("react.element");
    reactJsxRuntime_production_min.Fragment = h("react.fragment");
  }

  var m = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
      n = Object.prototype.hasOwnProperty,
      p = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
  };

  function q(c, a, k) {
    var b,
        d = {},
        e = null,
        l = null;
    void 0 !== k && (e = "" + k);
    void 0 !== a.key && (e = "" + a.key);
    void 0 !== a.ref && (l = a.ref);

    for (b in a) n.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);

    if (c && c.defaultProps) for (b in a = c.defaultProps, a) void 0 === d[b] && (d[b] = a[b]);
    return {
      $$typeof: g,
      type: c,
      key: e,
      ref: l,
      props: d,
      _owner: m.current
    };
  }

  reactJsxRuntime_production_min.jsx = q;
  reactJsxRuntime_production_min.jsxs = q;

  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }

  function isEmpty$2(obj) {
    return obj === undefined || obj === null || Object.keys(obj).length === 0;
  }

  function GlobalStyles$1(props) {
    const {
      styles,
      defaultTheme = {}
    } = props;
    const globalStyles = typeof styles === 'function' ? themeInput => styles(isEmpty$2(themeInput) ? defaultTheme : themeInput) : styles;
    return /*#__PURE__*/jsxRuntime.exports.jsx(Global, {
      styles: globalStyles
    });
  }

  /** @license MUI v5.3.0
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  function styled$2(tag, options) {
    const stylesFactory = emStyled(tag, options);

    return stylesFactory;
  }

  function _extends$3() {
    _extends$3 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$3.apply(this, arguments);
  }

  function isPlainObject(item) {
    return item !== null && typeof item === 'object' && item.constructor === Object;
  }
  function deepmerge(target, source, options = {
    clone: true
  }) {
    const output = options.clone ? _extends$3({}, target) : target;

    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach(key => {
        // Avoid prototype pollution
        if (key === '__proto__') {
          return;
        }

        if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
          // Since `output` is a clone of `target` and we have narrowed `target` in this block we can cast to the same type.
          output[key] = deepmerge(target[key], source[key], options);
        } else {
          output[key] = source[key];
        }
      });
    }

    return output;
  }

  /**
   * WARNING: Don't import this directly.
   * Use `MuiError` from `@mui/utils/macros/MuiError.macro` instead.
   * @param {number} code
   */
  function formatMuiErrorMessage(code) {
    // Apply babel-plugin-transform-template-literals in loose mode
    // loose mode is safe iff we're concatenating primitives
    // see https://babeljs.io/docs/en/babel-plugin-transform-template-literals#loose

    /* eslint-disable prefer-template */
    let url = 'https://mui.com/production-error/?code=' + code;

    for (let i = 1; i < arguments.length; i += 1) {
      // rest params over-transpile for this case
      // eslint-disable-next-line prefer-rest-params
      url += '&args[]=' + encodeURIComponent(arguments[i]);
    }

    return 'Minified MUI error #' + code + '; visit ' + url + ' for the full message.';
    /* eslint-enable prefer-template */
  }

  //
  // A strict capitalization should uppercase the first letter of each word in the sentence.
  // We only handle the first word.

  function capitalize(string) {
    if (typeof string !== 'string') {
      throw new Error(formatMuiErrorMessage(7));
    }

    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  /**
   * Safe chained function.
   *
   * Will only create a new function if needed,
   * otherwise will pass back existing functions or null.
   */
  function createChainedFunction(...funcs) {
    return funcs.reduce((acc, func) => {
      if (func == null) {
        return acc;
      }

      return function chainedFunction(...args) {
        acc.apply(this, args);
        func.apply(this, args);
      };
    }, () => {});
  }

  // Corresponds to 10 frames at 60 Hz.
  // A few bytes payload overhead when lodash/debounce is ~3 kB and debounce ~300 B.
  function debounce$1(func, wait = 166) {
    let timeout;

    function debounced(...args) {
      const later = () => {
        func.apply(this, args);
      };

      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    }

    debounced.clear = () => {
      clearTimeout(timeout);
    };

    return debounced;
  }

  function deprecatedPropType(validator, reason) {
    {
      return () => null;
    }
  }

  function isMuiElement(element, muiNames) {
    return /*#__PURE__*/ /*#__PURE__*/react.exports.isValidElement(element) && muiNames.indexOf(element.type.muiName) !== -1;
  }

  function ownerDocument(node) {
    return node && node.ownerDocument || document;
  }

  function ownerWindow(node) {
    const doc = ownerDocument(node);
    return doc.defaultView || window;
  }

  function requirePropFactory(componentNameInError, Component) {
    {
      return () => null;
    } // eslint-disable-next-line react/forbid-foreign-prop-types
  }

  /**
   * TODO v5: consider making it private
   *
   * passes {value} to {ref}
   *
   * WARNING: Be sure to only call this inside a callback that is passed as a ref.
   * Otherwise, make sure to cleanup the previous {ref} if it changes. See
   * https://github.com/mui-org/material-ui/issues/13539
   *
   * Useful if you want to expose the ref of an inner component to the public API
   * while still using it inside the component.
   * @param ref A ref callback or ref object. If anything falsy, this is a no-op.
   */
  function setRef(ref, value) {
    if (typeof ref === 'function') {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }

  const useEnhancedEffect = typeof window !== 'undefined' ? react.exports.useLayoutEffect : react.exports.useEffect;
  var useEnhancedEffect$1 = useEnhancedEffect;

  let globalId = 0;
  function useId(idOverride) {
    const [defaultId, setDefaultId] = react.exports.useState(idOverride);
    const id = idOverride || defaultId;
    react.exports.useEffect(() => {
      if (defaultId == null) {
        // Fallback to this default id when possible.
        // Use the incrementing value for client-side rendering only.
        // We can't use it server-side.
        // If you want to use random values please consider the Birthday Problem: https://en.wikipedia.org/wiki/Birthday_problem
        globalId += 1;
        setDefaultId(`mui-${globalId}`);
      }
    }, [defaultId]);
    return id;
  }

  function unsupportedProp(props, propName, componentName, location, propFullName) {
    {
      return null;
    }
  }

  /* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */
  function useControlled({
    controlled,
    default: defaultProp,
    name,
    state = 'value'
  }) {
    // isControlled is ignored in the hook dependency lists as it should never change.
    const {
      current: isControlled
    } = react.exports.useRef(controlled !== undefined);
    const [valueState, setValue] = react.exports.useState(defaultProp);
    const value = isControlled ? controlled : valueState;

    const setValueIfUncontrolled = react.exports.useCallback(newValue => {
      if (!isControlled) {
        setValue(newValue);
      }
    }, []);
    return [value, setValueIfUncontrolled];
  }

  /**
   * https://github.com/facebook/react/issues/14099#issuecomment-440013892
   */

  function useEventCallback(fn) {
    const ref = react.exports.useRef(fn);
    useEnhancedEffect$1(() => {
      ref.current = fn;
    });
    return react.exports.useCallback((...args) => // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, ref.current)(...args), []);
  }

  function useForkRef(refA, refB) {
    /**
     * This will create a new function if the ref props change and are defined.
     * This means react will call the old forkRef with `null` and the new forkRef
     * with the ref. Cleanup naturally emerges from this behavior.
     */
    return react.exports.useMemo(() => {
      if (refA == null && refB == null) {
        return null;
      }

      return refValue => {
        setRef(refA, refValue);
        setRef(refB, refValue);
      };
    }, [refA, refB]);
  }

  // based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js
  let hadKeyboardEvent = true;
  let hadFocusVisibleRecently = false;
  let hadFocusVisibleRecentlyTimeout;
  const inputTypesWhitelist = {
    text: true,
    search: true,
    url: true,
    tel: true,
    email: true,
    password: true,
    number: true,
    date: true,
    month: true,
    week: true,
    time: true,
    datetime: true,
    'datetime-local': true
  };
  /**
   * Computes whether the given element should automatically trigger the
   * `focus-visible` class being added, i.e. whether it should always match
   * `:focus-visible` when focused.
   * @param {Element} node
   * @returns {boolean}
   */

  function focusTriggersKeyboardModality(node) {
    const {
      type,
      tagName
    } = node;

    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {
      return true;
    }

    if (tagName === 'TEXTAREA' && !node.readOnly) {
      return true;
    }

    if (node.isContentEditable) {
      return true;
    }

    return false;
  }
  /**
   * Keep track of our keyboard modality state with `hadKeyboardEvent`.
   * If the most recent user interaction was via the keyboard;
   * and the key press did not include a meta, alt/option, or control key;
   * then the modality is keyboard. Otherwise, the modality is not keyboard.
   * @param {KeyboardEvent} event
   */


  function handleKeyDown(event) {
    if (event.metaKey || event.altKey || event.ctrlKey) {
      return;
    }

    hadKeyboardEvent = true;
  }
  /**
   * If at any point a user clicks with a pointing device, ensure that we change
   * the modality away from keyboard.
   * This avoids the situation where a user presses a key on an already focused
   * element, and then clicks on a different element, focusing it with a
   * pointing device, while we still think we're in keyboard modality.
   */


  function handlePointerDown() {
    hadKeyboardEvent = false;
  }

  function handleVisibilityChange() {
    if (this.visibilityState === 'hidden') {
      // If the tab becomes active again, the browser will handle calling focus
      // on the element (Safari actually calls it twice).
      // If this tab change caused a blur on an element with focus-visible,
      // re-apply the class when the user switches back to the tab.
      if (hadFocusVisibleRecently) {
        hadKeyboardEvent = true;
      }
    }
  }

  function prepare(doc) {
    doc.addEventListener('keydown', handleKeyDown, true);
    doc.addEventListener('mousedown', handlePointerDown, true);
    doc.addEventListener('pointerdown', handlePointerDown, true);
    doc.addEventListener('touchstart', handlePointerDown, true);
    doc.addEventListener('visibilitychange', handleVisibilityChange, true);
  }

  function isFocusVisible(event) {
    const {
      target
    } = event;

    try {
      return target.matches(':focus-visible');
    } catch (error) {// Browsers not implementing :focus-visible will throw a SyntaxError.
      // We use our own heuristic for those browsers.
      // Rethrow might be better if it's not the expected error but do we really
      // want to crash if focus-visible malfunctioned?
    } // No need for validFocusTarget check. The user does that by attaching it to
    // focusable events only.


    return hadKeyboardEvent || focusTriggersKeyboardModality(target);
  }

  function useIsFocusVisible() {
    const ref = react.exports.useCallback(node => {
      if (node != null) {
        prepare(node.ownerDocument);
      }
    }, []);
    const isFocusVisibleRef = react.exports.useRef(false);
    /**
     * Should be called if a blur event is fired
     */

    function handleBlurVisible() {
      // checking against potential state variable does not suffice if we focus and blur synchronously.
      // React wouldn't have time to trigger a re-render so `focusVisible` would be stale.
      // Ideally we would adjust `isFocusVisible(event)` to look at `relatedTarget` for blur events.
      // This doesn't work in IE11 due to https://github.com/facebook/react/issues/3751
      // TODO: check again if React releases their internal changes to focus event handling (https://github.com/facebook/react/pull/19186).
      if (isFocusVisibleRef.current) {
        // To detect a tab/window switch, we look for a blur event followed
        // rapidly by a visibility change.
        // If we don't see a visibility change within 100ms, it's probably a
        // regular focus change.
        hadFocusVisibleRecently = true;
        window.clearTimeout(hadFocusVisibleRecentlyTimeout);
        hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
          hadFocusVisibleRecently = false;
        }, 100);
        isFocusVisibleRef.current = false;
        return true;
      }

      return false;
    }
    /**
     * Should be called if a blur event is fired
     */


    function handleFocusVisible(event) {
      if (isFocusVisible(event)) {
        isFocusVisibleRef.current = true;
        return true;
      }

      return false;
    }

    return {
      isFocusVisibleRef,
      onFocus: handleFocusVisible,
      onBlur: handleBlurVisible,
      ref
    };
  }

  // A change of the browser zoom change the scrollbar size.
  // Credit https://github.com/twbs/bootstrap/blob/488fd8afc535ca3a6ad4dc581f5e89217b6a36ac/js/src/util/scrollbar.js#L14-L18
  function getScrollbarSize(doc) {
    // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes
    const documentWidth = doc.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }

  /**
   * Add keys, values of `defaultProps` that does not exist in `props`
   * @param {object} defaultProps
   * @param {object} props
   * @returns {object} resolved props
   */

  function resolveProps(defaultProps, props) {
    const output = _extends$3({}, props);

    Object.keys(defaultProps).forEach(propName => {
      if (output[propName] === undefined) {
        output[propName] = defaultProps[propName];
      }
    });
    return output;
  }

  function _extends$2() {
    _extends$2 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$2.apply(this, arguments);
  }

  function merge(acc, item) {
    if (!item) {
      return acc;
    }

    return deepmerge(acc, item, {
      clone: false // No need to clone deep, it's way faster.

    });
  }

  // For instance with the first breakpoint xs: [xs, sm[.

  const values$1 = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536 // large screen

  };
  const defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ['xs', 'sm', 'md', 'lg', 'xl'],
    up: key => `@media (min-width:${values$1[key]}px)`
  };
  function handleBreakpoints(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};

    if (Array.isArray(propValue)) {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return propValue.reduce((acc, item, index) => {
        acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
        return acc;
      }, {});
    }

    if (typeof propValue === 'object') {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return Object.keys(propValue).reduce((acc, breakpoint) => {
        // key is breakpoint
        if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
          const mediaKey = themeBreakpoints.up(breakpoint);
          acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        } else {
          const cssKey = breakpoint;
          acc[cssKey] = propValue[cssKey];
        }

        return acc;
      }, {});
    }

    const output = styleFromPropValue(propValue);
    return output;
  }

  function createEmptyBreakpointObject(breakpointsInput = {}) {
    var _breakpointsInput$key;

    const breakpointsInOrder = breakpointsInput == null ? void 0 : (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
      const breakpointStyleKey = breakpointsInput.up(key);
      acc[breakpointStyleKey] = {};
      return acc;
    }, {});
    return breakpointsInOrder || {};
  }
  function removeUnusedBreakpoints(breakpointKeys, style) {
    return breakpointKeys.reduce((acc, key) => {
      const breakpointOutput = acc[key];
      const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;

      if (isBreakpointUnused) {
        delete acc[key];
      }

      return acc;
    }, style);
  }

  function getPath(obj, path) {
    if (!path || typeof path !== 'string') {
      return null;
    }

    return path.split('.').reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
  }

  function getValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
    let value;

    if (typeof themeMapping === 'function') {
      value = themeMapping(propValueFinal);
    } else if (Array.isArray(themeMapping)) {
      value = themeMapping[propValueFinal] || userValue;
    } else {
      value = getPath(themeMapping, propValueFinal) || userValue;
    }

    if (transform) {
      value = transform(value);
    }

    return value;
  }

  function style$1(options) {
    const {
      prop,
      cssProperty = options.prop,
      themeKey,
      transform
    } = options;

    const fn = props => {
      if (props[prop] == null) {
        return null;
      }

      const propValue = props[prop];
      const theme = props.theme;
      const themeMapping = getPath(theme, themeKey) || {};

      const styleFromPropValue = propValueFinal => {
        let value = getValue$1(themeMapping, transform, propValueFinal);

        if (propValueFinal === value && typeof propValueFinal === 'string') {
          // Haven't found value
          value = getValue$1(themeMapping, transform, `${prop}${propValueFinal === 'default' ? '' : capitalize(propValueFinal)}`, propValueFinal);
        }

        if (cssProperty === false) {
          return value;
        }

        return {
          [cssProperty]: value
        };
      };

      return handleBreakpoints(props, propValue, styleFromPropValue);
    };

    fn.propTypes = {};
    fn.filterProps = [prop];
    return fn;
  }

  function compose(...styles) {
    const handlers = styles.reduce((acc, style) => {
      style.filterProps.forEach(prop => {
        acc[prop] = style;
      });
      return acc;
    }, {});

    const fn = props => {
      return Object.keys(props).reduce((acc, prop) => {
        if (handlers[prop]) {
          return merge(acc, handlers[prop](props));
        }

        return acc;
      }, {});
    };

    fn.propTypes = {};
    fn.filterProps = styles.reduce((acc, style) => acc.concat(style.filterProps), []);
    return fn;
  }

  function memoize(fn) {
    const cache = {};
    return arg => {
      if (cache[arg] === undefined) {
        cache[arg] = fn(arg);
      }

      return cache[arg];
    };
  }

  const properties = {
    m: 'margin',
    p: 'padding'
  };
  const directions = {
    t: 'Top',
    r: 'Right',
    b: 'Bottom',
    l: 'Left',
    x: ['Left', 'Right'],
    y: ['Top', 'Bottom']
  };
  const aliases = {
    marginX: 'mx',
    marginY: 'my',
    paddingX: 'px',
    paddingY: 'py'
  }; // memoize() impact:
  // From 300,000 ops/sec
  // To 350,000 ops/sec

  const getCssProperties = memoize(prop => {
    // It's not a shorthand notation.
    if (prop.length > 2) {
      if (aliases[prop]) {
        prop = aliases[prop];
      } else {
        return [prop];
      }
    }

    const [a, b] = prop.split('');
    const property = properties[a];
    const direction = directions[b] || '';
    return Array.isArray(direction) ? direction.map(dir => property + dir) : [property + direction];
  });
  const marginKeys = ['m', 'mt', 'mr', 'mb', 'ml', 'mx', 'my', 'margin', 'marginTop', 'marginRight', 'marginBottom', 'marginLeft', 'marginX', 'marginY', 'marginInline', 'marginInlineStart', 'marginInlineEnd', 'marginBlock', 'marginBlockStart', 'marginBlockEnd'];
  const paddingKeys = ['p', 'pt', 'pr', 'pb', 'pl', 'px', 'py', 'padding', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft', 'paddingX', 'paddingY', 'paddingInline', 'paddingInlineStart', 'paddingInlineEnd', 'paddingBlock', 'paddingBlockStart', 'paddingBlockEnd'];
  const spacingKeys = [...marginKeys, ...paddingKeys];
  function createUnaryUnit(theme, themeKey, defaultValue, propName) {
    const themeSpacing = getPath(theme, themeKey) || defaultValue;

    if (typeof themeSpacing === 'number') {
      return abs => {
        if (typeof abs === 'string') {
          return abs;
        }

        return themeSpacing * abs;
      };
    }

    if (Array.isArray(themeSpacing)) {
      return abs => {
        if (typeof abs === 'string') {
          return abs;
        }

        return themeSpacing[abs];
      };
    }

    if (typeof themeSpacing === 'function') {
      return themeSpacing;
    }

    return () => undefined;
  }
  function createUnarySpacing(theme) {
    return createUnaryUnit(theme, 'spacing', 8);
  }
  function getValue(transformer, propValue) {
    if (typeof propValue === 'string' || propValue == null) {
      return propValue;
    }

    const abs = Math.abs(propValue);
    const transformed = transformer(abs);

    if (propValue >= 0) {
      return transformed;
    }

    if (typeof transformed === 'number') {
      return -transformed;
    }

    return `-${transformed}`;
  }
  function getStyleFromPropValue(cssProperties, transformer) {
    return propValue => cssProperties.reduce((acc, cssProperty) => {
      acc[cssProperty] = getValue(transformer, propValue);
      return acc;
    }, {});
  }

  function resolveCssProperty(props, keys, prop, transformer) {
    // Using a hash computation over an array iteration could be faster, but with only 28 items,
    // it's doesn't worth the bundle size.
    if (keys.indexOf(prop) === -1) {
      return null;
    }

    const cssProperties = getCssProperties(prop);
    const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
    const propValue = props[prop];
    return handleBreakpoints(props, propValue, styleFromPropValue);
  }

  function style(props, keys) {
    const transformer = createUnarySpacing(props.theme);
    return Object.keys(props).map(prop => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
  }

  function spacing(props) {
    return style(props, spacingKeys);
  }

  spacing.propTypes = {};
  spacing.filterProps = spacingKeys;

  function getBorder(value) {
    if (typeof value !== 'number') {
      return value;
    }

    return `${value}px solid`;
  }

  const border = style$1({
    prop: 'border',
    themeKey: 'borders',
    transform: getBorder
  });
  const borderTop = style$1({
    prop: 'borderTop',
    themeKey: 'borders',
    transform: getBorder
  });
  const borderRight = style$1({
    prop: 'borderRight',
    themeKey: 'borders',
    transform: getBorder
  });
  const borderBottom = style$1({
    prop: 'borderBottom',
    themeKey: 'borders',
    transform: getBorder
  });
  const borderLeft = style$1({
    prop: 'borderLeft',
    themeKey: 'borders',
    transform: getBorder
  });
  const borderColor = style$1({
    prop: 'borderColor',
    themeKey: 'palette'
  });
  const borderTopColor = style$1({
    prop: 'borderTopColor',
    themeKey: 'palette'
  });
  const borderRightColor = style$1({
    prop: 'borderRightColor',
    themeKey: 'palette'
  });
  const borderBottomColor = style$1({
    prop: 'borderBottomColor',
    themeKey: 'palette'
  });
  const borderLeftColor = style$1({
    prop: 'borderLeftColor',
    themeKey: 'palette'
  });
  const borderRadius = props => {
    if (props.borderRadius !== undefined && props.borderRadius !== null) {
      const transformer = createUnaryUnit(props.theme, 'shape.borderRadius', 4);

      const styleFromPropValue = propValue => ({
        borderRadius: getValue(transformer, propValue)
      });

      return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
    }

    return null;
  };
  borderRadius.propTypes = {};
  borderRadius.filterProps = ['borderRadius'];
  const borders = compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
  var borders$1 = borders;

  const displayPrint = style$1({
    prop: 'displayPrint',
    cssProperty: false,
    transform: value => ({
      '@media print': {
        display: value
      }
    })
  });
  const displayRaw = style$1({
    prop: 'display'
  });
  const overflow = style$1({
    prop: 'overflow'
  });
  const textOverflow = style$1({
    prop: 'textOverflow'
  });
  const visibility = style$1({
    prop: 'visibility'
  });
  const whiteSpace = style$1({
    prop: 'whiteSpace'
  });
  var display = compose(displayPrint, displayRaw, overflow, textOverflow, visibility, whiteSpace);

  const flexBasis = style$1({
    prop: 'flexBasis'
  });
  const flexDirection = style$1({
    prop: 'flexDirection'
  });
  const flexWrap = style$1({
    prop: 'flexWrap'
  });
  const justifyContent = style$1({
    prop: 'justifyContent'
  });
  const alignItems = style$1({
    prop: 'alignItems'
  });
  const alignContent = style$1({
    prop: 'alignContent'
  });
  const order$1 = style$1({
    prop: 'order'
  });
  const flex = style$1({
    prop: 'flex'
  });
  const flexGrow = style$1({
    prop: 'flexGrow'
  });
  const flexShrink = style$1({
    prop: 'flexShrink'
  });
  const alignSelf = style$1({
    prop: 'alignSelf'
  });
  const justifyItems = style$1({
    prop: 'justifyItems'
  });
  const justifySelf = style$1({
    prop: 'justifySelf'
  });
  const flexbox = compose(flexBasis, flexDirection, flexWrap, justifyContent, alignItems, alignContent, order$1, flex, flexGrow, flexShrink, alignSelf, justifyItems, justifySelf);
  var flexbox$1 = flexbox;

  const gap = props => {
    if (props.gap !== undefined && props.gap !== null) {
      const transformer = createUnaryUnit(props.theme, 'spacing', 8);

      const styleFromPropValue = propValue => ({
        gap: getValue(transformer, propValue)
      });

      return handleBreakpoints(props, props.gap, styleFromPropValue);
    }

    return null;
  };
  gap.propTypes = {};
  gap.filterProps = ['gap'];
  const columnGap = props => {
    if (props.columnGap !== undefined && props.columnGap !== null) {
      const transformer = createUnaryUnit(props.theme, 'spacing', 8);

      const styleFromPropValue = propValue => ({
        columnGap: getValue(transformer, propValue)
      });

      return handleBreakpoints(props, props.columnGap, styleFromPropValue);
    }

    return null;
  };
  columnGap.propTypes = {};
  columnGap.filterProps = ['columnGap'];
  const rowGap = props => {
    if (props.rowGap !== undefined && props.rowGap !== null) {
      const transformer = createUnaryUnit(props.theme, 'spacing', 8);

      const styleFromPropValue = propValue => ({
        rowGap: getValue(transformer, propValue)
      });

      return handleBreakpoints(props, props.rowGap, styleFromPropValue);
    }

    return null;
  };
  rowGap.propTypes = {};
  rowGap.filterProps = ['rowGap'];
  const gridColumn = style$1({
    prop: 'gridColumn'
  });
  const gridRow = style$1({
    prop: 'gridRow'
  });
  const gridAutoFlow = style$1({
    prop: 'gridAutoFlow'
  });
  const gridAutoColumns = style$1({
    prop: 'gridAutoColumns'
  });
  const gridAutoRows = style$1({
    prop: 'gridAutoRows'
  });
  const gridTemplateColumns = style$1({
    prop: 'gridTemplateColumns'
  });
  const gridTemplateRows = style$1({
    prop: 'gridTemplateRows'
  });
  const gridTemplateAreas = style$1({
    prop: 'gridTemplateAreas'
  });
  const gridArea = style$1({
    prop: 'gridArea'
  });
  const grid = compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
  var grid$1 = grid;

  const color = style$1({
    prop: 'color',
    themeKey: 'palette'
  });
  const bgcolor = style$1({
    prop: 'bgcolor',
    cssProperty: 'backgroundColor',
    themeKey: 'palette'
  });
  const backgroundColor = style$1({
    prop: 'backgroundColor',
    themeKey: 'palette'
  });
  const palette$1 = compose(color, bgcolor, backgroundColor);
  var palette$2 = palette$1;

  const position = style$1({
    prop: 'position'
  });
  const zIndex$2 = style$1({
    prop: 'zIndex',
    themeKey: 'zIndex'
  });
  const top$1 = style$1({
    prop: 'top'
  });
  const right$1 = style$1({
    prop: 'right'
  });
  const bottom$1 = style$1({
    prop: 'bottom'
  });
  const left$1 = style$1({
    prop: 'left'
  });
  var positions = compose(position, zIndex$2, top$1, right$1, bottom$1, left$1);

  const boxShadow = style$1({
    prop: 'boxShadow',
    themeKey: 'shadows'
  });
  var shadows$2 = boxShadow;

  function transform(value) {
    return value <= 1 && value !== 0 ? `${value * 100}%` : value;
  }

  const width = style$1({
    prop: 'width',
    transform
  });
  const maxWidth = props => {
    if (props.maxWidth !== undefined && props.maxWidth !== null) {
      const styleFromPropValue = propValue => {
        var _props$theme, _props$theme$breakpoi, _props$theme$breakpoi2;

        const breakpoint = ((_props$theme = props.theme) == null ? void 0 : (_props$theme$breakpoi = _props$theme.breakpoints) == null ? void 0 : (_props$theme$breakpoi2 = _props$theme$breakpoi.values) == null ? void 0 : _props$theme$breakpoi2[propValue]) || values$1[propValue];
        return {
          maxWidth: breakpoint || transform(propValue)
        };
      };

      return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
    }

    return null;
  };
  maxWidth.filterProps = ['maxWidth'];
  const minWidth = style$1({
    prop: 'minWidth',
    transform
  });
  const height = style$1({
    prop: 'height',
    transform
  });
  const maxHeight = style$1({
    prop: 'maxHeight',
    transform
  });
  const minHeight = style$1({
    prop: 'minHeight',
    transform
  });
  style$1({
    prop: 'size',
    cssProperty: 'width',
    transform
  });
  style$1({
    prop: 'size',
    cssProperty: 'height',
    transform
  });
  const boxSizing = style$1({
    prop: 'boxSizing'
  });
  const sizing = compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
  var sizing$1 = sizing;

  const fontFamily = style$1({
    prop: 'fontFamily',
    themeKey: 'typography'
  });
  const fontSize = style$1({
    prop: 'fontSize',
    themeKey: 'typography'
  });
  const fontStyle = style$1({
    prop: 'fontStyle',
    themeKey: 'typography'
  });
  const fontWeight = style$1({
    prop: 'fontWeight',
    themeKey: 'typography'
  });
  const letterSpacing = style$1({
    prop: 'letterSpacing'
  });
  const textTransform = style$1({
    prop: 'textTransform'
  });
  const lineHeight = style$1({
    prop: 'lineHeight'
  });
  const textAlign = style$1({
    prop: 'textAlign'
  });
  const typographyVariant = style$1({
    prop: 'typography',
    cssProperty: false,
    themeKey: 'typography'
  });
  const typography = compose(typographyVariant, fontFamily, fontSize, fontStyle, fontWeight, letterSpacing, lineHeight, textAlign, textTransform);
  var typography$1 = typography;

  const filterPropsMapping = {
    borders: borders$1.filterProps,
    display: display.filterProps,
    flexbox: flexbox$1.filterProps,
    grid: grid$1.filterProps,
    positions: positions.filterProps,
    palette: palette$2.filterProps,
    shadows: shadows$2.filterProps,
    sizing: sizing$1.filterProps,
    spacing: spacing.filterProps,
    typography: typography$1.filterProps
  };
  const styleFunctionMapping = {
    borders: borders$1,
    display,
    flexbox: flexbox$1,
    grid: grid$1,
    positions,
    palette: palette$2,
    shadows: shadows$2,
    sizing: sizing$1,
    spacing,
    typography: typography$1
  };
  const propToStyleFunction = Object.keys(filterPropsMapping).reduce((acc, styleFnName) => {
    filterPropsMapping[styleFnName].forEach(propName => {
      acc[propName] = styleFunctionMapping[styleFnName];
    });
    return acc;
  }, {});

  function getThemeValue(prop, value, theme) {
    const inputProps = {
      [prop]: value,
      theme
    };
    const styleFunction = propToStyleFunction[prop];
    return styleFunction ? styleFunction(inputProps) : {
      [prop]: value
    };
  }

  function objectsHaveSameKeys(...objects) {
    const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
    const union = new Set(allKeys);
    return objects.every(object => union.size === Object.keys(object).length);
  }

  function callIfFn(maybeFn, arg) {
    return typeof maybeFn === 'function' ? maybeFn(arg) : maybeFn;
  }

  function styleFunctionSx(props) {
    const {
      sx,
      theme = {}
    } = props || {};

    if (!sx) {
      return null; // emotion & styled-components will neglect null
    }
    /*
     * Receive `sxInput` as object or callback
     * and then recursively check keys & values to create media query object styles.
     * (the result will be used in `styled`)
     */


    function traverse(sxInput) {
      let sxObject = sxInput;

      if (typeof sxInput === 'function') {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== 'object') {
        // value
        return sxInput;
      }

      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css = emptyBreakpoints;
      Object.keys(sxObject).forEach(styleKey => {
        const value = callIfFn(sxObject[styleKey], theme);

        if (value !== null && value !== undefined) {
          if (typeof value === 'object') {
            if (propToStyleFunction[styleKey]) {
              css = merge(css, getThemeValue(styleKey, value, theme));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, x => ({
                [styleKey]: x
              }));

              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css[styleKey] = styleFunctionSx({
                  sx: value,
                  theme
                });
              } else {
                css = merge(css, breakpointsValues);
              }
            }
          } else {
            css = merge(css, getThemeValue(styleKey, value, theme));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css);
    }

    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }

  styleFunctionSx.filterProps = ['sx'];

  function _objectWithoutPropertiesLoose$1(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  const _excluded$s = ["sx"];

  const splitProps = props => {
    const result = {
      systemProps: {},
      otherProps: {}
    };
    Object.keys(props).forEach(prop => {
      if (propToStyleFunction[prop]) {
        result.systemProps[prop] = props[prop];
      } else {
        result.otherProps[prop] = props[prop];
      }
    });
    return result;
  };

  function extendSxProp(props) {
    const {
      sx: inSx
    } = props,
          other = _objectWithoutPropertiesLoose$1(props, _excluded$s);

    const {
      systemProps,
      otherProps
    } = splitProps(other);
    let finalSx;

    if (Array.isArray(inSx)) {
      finalSx = [systemProps, ...inSx];
    } else if (typeof inSx === 'function') {
      finalSx = (...args) => {
        const result = inSx(...args);

        if (!isPlainObject(result)) {
          return systemProps;
        }

        return _extends$2({}, systemProps, result);
      };
    } else {
      finalSx = _extends$2({}, systemProps, inSx);
    }

    return _extends$2({}, otherProps, {
      sx: finalSx
    });
  }

  function toVal(mix) {
    var k,
        y,
        str = '';

    if (typeof mix === 'string' || typeof mix === 'number') {
      str += mix;
    } else if (typeof mix === 'object') {
      if (Array.isArray(mix)) {
        for (k = 0; k < mix.length; k++) {
          if (mix[k]) {
            if (y = toVal(mix[k])) {
              str && (str += ' ');
              str += y;
            }
          }
        }
      } else {
        for (k in mix) {
          if (mix[k]) {
            str && (str += ' ');
            str += k;
          }
        }
      }
    }

    return str;
  }

  function clsx () {
    var i = 0,
        tmp,
        x,
        str = '';

    while (i < arguments.length) {
      if (tmp = arguments[i++]) {
        if (x = toVal(tmp)) {
          str && (str += ' ');
          str += x;
        }
      }
    }

    return str;
  }

  const _excluded$r = ["values", "unit", "step"]; // Sorted ASC by size. That's important.

  function createBreakpoints(breakpoints) {
    const {
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      values = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536 // large screen

      },
      unit = 'px',
      step = 5
    } = breakpoints,
          other = _objectWithoutPropertiesLoose$1(breakpoints, _excluded$r);

    const keys = Object.keys(values);

    function up(key) {
      const value = typeof values[key] === 'number' ? values[key] : key;
      return `@media (min-width:${value}${unit})`;
    }

    function down(key) {
      const value = typeof values[key] === 'number' ? values[key] : key;
      return `@media (max-width:${value - step / 100}${unit})`;
    }

    function between(start, end) {
      const endIndex = keys.indexOf(end);
      return `@media (min-width:${typeof values[start] === 'number' ? values[start] : start}${unit}) and ` + `(max-width:${(endIndex !== -1 && typeof values[keys[endIndex]] === 'number' ? values[keys[endIndex]] : end) - step / 100}${unit})`;
    }

    function only(key) {
      if (keys.indexOf(key) + 1 < keys.length) {
        return between(key, keys[keys.indexOf(key) + 1]);
      }

      return up(key);
    }

    function not(key) {
      // handle first and last key separately, for better readability
      const keyIndex = keys.indexOf(key);

      if (keyIndex === 0) {
        return up(keys[1]);
      }

      if (keyIndex === keys.length - 1) {
        return down(keys[keyIndex]);
      }

      return between(key, keys[keys.indexOf(key) + 1]).replace('@media', '@media not all and');
    }

    return _extends$2({
      keys,
      values,
      up,
      down,
      between,
      only,
      not,
      unit
    }, other);
  }

  const shape = {
    borderRadius: 4
  };
  var shape$1 = shape;

  /* tslint:enable:unified-signatures */

  function createSpacing(spacingInput = 8) {
    // Already transformed.
    if (spacingInput.mui) {
      return spacingInput;
    } // Material Design layouts are visually balanced. Most measurements align to an 8dp grid, which aligns both spacing and the overall layout.
    // Smaller components, such as icons, can align to a 4dp grid.
    // https://material.io/design/layout/understanding-layout.html#usage


    const transform = createUnarySpacing({
      spacing: spacingInput
    });

    const spacing = (...argsInput) => {

      const args = argsInput.length === 0 ? [1] : argsInput;
      return args.map(argument => {
        const output = transform(argument);
        return typeof output === 'number' ? `${output}px` : output;
      }).join(' ');
    };

    spacing.mui = true;
    return spacing;
  }

  const _excluded$q = ["breakpoints", "palette", "spacing", "shape"];

  function createTheme$1(options = {}, ...args) {
    const {
      breakpoints: breakpointsInput = {},
      palette: paletteInput = {},
      spacing: spacingInput,
      shape: shapeInput = {}
    } = options,
          other = _objectWithoutPropertiesLoose$1(options, _excluded$q);

    const breakpoints = createBreakpoints(breakpointsInput);
    const spacing = createSpacing(spacingInput);
    let muiTheme = deepmerge({
      breakpoints,
      direction: 'ltr',
      components: {},
      // Inject component definitions.
      palette: _extends$2({
        mode: 'light'
      }, paletteInput),
      spacing,
      shape: _extends$2({}, shape$1, shapeInput)
    }, other);
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    return muiTheme;
  }

  function _extends$1() {
    _extends$1 = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends$1.apply(this, arguments);
  }

  const ThemeContext = /*#__PURE__*/react.exports.createContext(null);

  var ThemeContext$1 = ThemeContext;

  function useTheme$3() {
    const theme = react.exports.useContext(ThemeContext$1);

    return theme;
  }

  const hasSymbol = typeof Symbol === 'function' && Symbol.for;
  var nested = hasSymbol ? Symbol.for('mui.nested') : '__THEME_NESTED__';

  function mergeOuterLocalTheme(outerTheme, localTheme) {
    if (typeof localTheme === 'function') {
      const mergedTheme = localTheme(outerTheme);

      return mergedTheme;
    }

    return _extends$1({}, outerTheme, localTheme);
  }
  /**
   * This component takes a `theme` prop.
   * It makes the `theme` available down the React tree thanks to React context.
   * This component should preferably be used at **the root of your component tree**.
   */


  function ThemeProvider$1(props) {
    const {
      children,
      theme: localTheme
    } = props;
    const outerTheme = useTheme$3();

    const theme = react.exports.useMemo(() => {
      const output = outerTheme === null ? localTheme : mergeOuterLocalTheme(outerTheme, localTheme);

      if (output != null) {
        output[nested] = outerTheme !== null;
      }

      return output;
    }, [localTheme, outerTheme]);
    return /*#__PURE__*/jsxRuntime.exports.jsx(ThemeContext$1.Provider, {
      value: theme,
      children: children
    });
  }

  function isObjectEmpty(obj) {
    return Object.keys(obj).length === 0;
  }

  function useTheme$2(defaultTheme = null) {
    const contextTheme = useTheme$3();
    return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme : contextTheme;
  }

  const systemDefaultTheme$1 = createTheme$1();

  function useTheme$1(defaultTheme = systemDefaultTheme$1) {
    return useTheme$2(defaultTheme);
  }

  const _excluded$p = ["className", "component"];
  function createBox(options = {}) {
    const {
      defaultTheme,
      defaultClassName = 'MuiBox-root',
      generateClassName
    } = options;
    const BoxRoot = styled$2('div')(styleFunctionSx);
    const Box = /*#__PURE__*/react.exports.forwardRef(function Box(inProps, ref) {
      const theme = useTheme$1(defaultTheme);

      const _extendSxProp = extendSxProp(inProps),
            {
        className,
        component = 'div'
      } = _extendSxProp,
            other = _objectWithoutPropertiesLoose$1(_extendSxProp, _excluded$p);

      return /*#__PURE__*/jsxRuntime.exports.jsx(BoxRoot, _extends$2({
        as: component,
        ref: ref,
        className: clsx(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
        theme: theme
      }, other));
    });
    return Box;
  }

  const _excluded$o = ["variant"];

  function isEmpty$1(string) {
    return string.length === 0;
  }
  /**
   * Generates string classKey based on the properties provided. It starts with the
   * variant if defined, and then it appends all other properties in alphabetical order.
   * @param {object} props - the properties for which the classKey should be created.
   */


  function propsToClassKey(props) {
    const {
      variant
    } = props,
          other = _objectWithoutPropertiesLoose$1(props, _excluded$o);

    let classKey = variant || '';
    Object.keys(other).sort().forEach(key => {
      if (key === 'color') {
        classKey += isEmpty$1(classKey) ? props[key] : capitalize(props[key]);
      } else {
        classKey += `${isEmpty$1(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
      }
    });
    return classKey;
  }

  const _excluded$n = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"],
        _excluded2$3 = ["theme"],
        _excluded3 = ["theme"];

  function isEmpty(obj) {
    return Object.keys(obj).length === 0;
  }

  const getStyleOverrides = (name, theme) => {
    if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
      return theme.components[name].styleOverrides;
    }

    return null;
  };

  const getVariantStyles = (name, theme) => {
    let variants = [];

    if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
      variants = theme.components[name].variants;
    }

    const variantsStyles = {};
    variants.forEach(definition => {
      const key = propsToClassKey(definition.props);
      variantsStyles[key] = definition.style;
    });
    return variantsStyles;
  };

  const variantsResolver = (props, styles, theme, name) => {
    var _theme$components, _theme$components$nam;

    const {
      ownerState = {}
    } = props;
    const variantsStyles = [];
    const themeVariants = theme == null ? void 0 : (_theme$components = theme.components) == null ? void 0 : (_theme$components$nam = _theme$components[name]) == null ? void 0 : _theme$components$nam.variants;

    if (themeVariants) {
      themeVariants.forEach(themeVariant => {
        let isMatch = true;
        Object.keys(themeVariant.props).forEach(key => {
          if (ownerState[key] !== themeVariant.props[key] && props[key] !== themeVariant.props[key]) {
            isMatch = false;
          }
        });

        if (isMatch) {
          variantsStyles.push(styles[propsToClassKey(themeVariant.props)]);
        }
      });
    }

    return variantsStyles;
  };

  function shouldForwardProp(prop) {
    return prop !== 'ownerState' && prop !== 'theme' && prop !== 'sx' && prop !== 'as';
  }
  const systemDefaultTheme = createTheme$1();

  function createStyled(input = {}) {
    const {
      defaultTheme = systemDefaultTheme,
      rootShouldForwardProp = shouldForwardProp,
      slotShouldForwardProp = shouldForwardProp
    } = input;
    return (tag, inputOptions = {}) => {
      const {
        name: componentName,
        slot: componentSlot,
        skipVariantsResolver: inputSkipVariantsResolver,
        skipSx: inputSkipSx,
        overridesResolver
      } = inputOptions,
            options = _objectWithoutPropertiesLoose$1(inputOptions, _excluded$n); // if skipVariantsResolver option is defined, take the value, otherwise, true for root and false for other slots.


      const skipVariantsResolver = inputSkipVariantsResolver !== undefined ? inputSkipVariantsResolver : componentSlot && componentSlot !== 'Root' || false;
      const skipSx = inputSkipSx || false;
      let label;

      let shouldForwardPropOption = shouldForwardProp;

      if (componentSlot === 'Root') {
        shouldForwardPropOption = rootShouldForwardProp;
      } else if (componentSlot) {
        // any other slot specified
        shouldForwardPropOption = slotShouldForwardProp;
      }

      const defaultStyledResolver = styled$2(tag, _extends$2({
        shouldForwardProp: shouldForwardPropOption,
        label
      }, options));

      const muiStyledResolver = (styleArg, ...expressions) => {
        const expressionsWithDefaultTheme = expressions ? expressions.map(stylesArg => {
          // On the server emotion doesn't use React.forwardRef for creating components, so the created
          // component stays as a function. This condition makes sure that we do not interpolate functions
          // which are basically components used as a selectors.
          // eslint-disable-next-line no-underscore-dangle
          return typeof stylesArg === 'function' && stylesArg.__emotion_real !== stylesArg ? _ref => {
            let {
              theme: themeInput
            } = _ref,
                other = _objectWithoutPropertiesLoose$1(_ref, _excluded2$3);

            return stylesArg(_extends$2({
              theme: isEmpty(themeInput) ? defaultTheme : themeInput
            }, other));
          } : stylesArg;
        }) : [];
        let transformedStyleArg = styleArg;

        if (componentName && overridesResolver) {
          expressionsWithDefaultTheme.push(props => {
            const theme = isEmpty(props.theme) ? defaultTheme : props.theme;
            const styleOverrides = getStyleOverrides(componentName, theme);

            if (styleOverrides) {
              const resolvedStyleOverrides = {};
              Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                resolvedStyleOverrides[slotKey] = typeof slotStyle === 'function' ? slotStyle(props) : slotStyle;
              });
              return overridesResolver(props, resolvedStyleOverrides);
            }

            return null;
          });
        }

        if (componentName && !skipVariantsResolver) {
          expressionsWithDefaultTheme.push(props => {
            const theme = isEmpty(props.theme) ? defaultTheme : props.theme;
            return variantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
          });
        }

        if (!skipSx) {
          expressionsWithDefaultTheme.push(props => {
            const theme = isEmpty(props.theme) ? defaultTheme : props.theme;
            return styleFunctionSx(_extends$2({}, props, {
              theme
            }));
          });
        }

        const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;

        if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
          const placeholders = new Array(numOfCustomFnsApplied).fill(''); // If the type is array, than we need to add placeholders in the template for the overrides, variants and the sx styles.

          transformedStyleArg = [...styleArg, ...placeholders];
          transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
        } else if (typeof styleArg === 'function') {
          // If the type is function, we need to define the default theme.
          transformedStyleArg = _ref2 => {
            let {
              theme: themeInput
            } = _ref2,
                other = _objectWithoutPropertiesLoose$1(_ref2, _excluded3);

            return styleArg(_extends$2({
              theme: isEmpty(themeInput) ? defaultTheme : themeInput
            }, other));
          };
        }

        const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);

        return Component;
      };

      if (defaultStyledResolver.withConfig) {
        muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
      }

      return muiStyledResolver;
    };
  }

  function getThemeProps(params) {
    const {
      theme,
      name,
      props
    } = params;

    if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
      return props;
    }

    return resolveProps(theme.components[name].defaultProps, props);
  }

  function useThemeProps$1({
    props,
    name,
    defaultTheme
  }) {
    const theme = useTheme$1(defaultTheme);
    const mergedProps = getThemeProps({
      theme,
      name,
      props
    });
    return mergedProps;
  }

  /**
   * Returns a number whose value is limited to the given range.
   * @param {number} value The value to be clamped
   * @param {number} min The lower boundary of the output range
   * @param {number} max The upper boundary of the output range
   * @returns {number} A number in the range [min, max]
   */

  function clamp(value, min = 0, max = 1) {

    return Math.min(Math.max(min, value), max);
  }
  /**
   * Converts a color from CSS hex format to CSS rgb format.
   * @param {string} color - Hex color, i.e. #nnn or #nnnnnn
   * @returns {string} A CSS rgb color string
   */


  function hexToRgb(color) {
    color = color.substr(1);
    const re = new RegExp(`.{1,${color.length >= 6 ? 2 : 1}}`, 'g');
    let colors = color.match(re);

    if (colors && colors[0].length === 1) {
      colors = colors.map(n => n + n);
    }

    return colors ? `rgb${colors.length === 4 ? 'a' : ''}(${colors.map((n, index) => {
    return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1000) / 1000;
  }).join(', ')})` : '';
  }
  /**
   * Returns an object with the type and values of a color.
   *
   * Note: Does not support rgb % values.
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {object} - A MUI color object: {type: string, values: number[]}
   */


  function decomposeColor(color) {
    // Idempotent
    if (color.type) {
      return color;
    }

    if (color.charAt(0) === '#') {
      return decomposeColor(hexToRgb(color));
    }

    const marker = color.indexOf('(');
    const type = color.substring(0, marker);

    if (['rgb', 'rgba', 'hsl', 'hsla', 'color'].indexOf(type) === -1) {
      throw new Error(formatMuiErrorMessage(9, color));
    }

    let values = color.substring(marker + 1, color.length - 1);
    let colorSpace;

    if (type === 'color') {
      values = values.split(' ');
      colorSpace = values.shift();

      if (values.length === 4 && values[3].charAt(0) === '/') {
        values[3] = values[3].substr(1);
      }

      if (['srgb', 'display-p3', 'a98-rgb', 'prophoto-rgb', 'rec-2020'].indexOf(colorSpace) === -1) {
        throw new Error(formatMuiErrorMessage(10, colorSpace));
      }
    } else {
      values = values.split(',');
    }

    values = values.map(value => parseFloat(value));
    return {
      type,
      values,
      colorSpace
    };
  }
  /**
   * Converts a color object with type and values to a string.
   * @param {object} color - Decomposed color
   * @param {string} color.type - One of: 'rgb', 'rgba', 'hsl', 'hsla'
   * @param {array} color.values - [n,n,n] or [n,n,n,n]
   * @returns {string} A CSS color string
   */

  function recomposeColor(color) {
    const {
      type,
      colorSpace
    } = color;
    let {
      values
    } = color;

    if (type.indexOf('rgb') !== -1) {
      // Only convert the first 3 values to int (i.e. not alpha)
      values = values.map((n, i) => i < 3 ? parseInt(n, 10) : n);
    } else if (type.indexOf('hsl') !== -1) {
      values[1] = `${values[1]}%`;
      values[2] = `${values[2]}%`;
    }

    if (type.indexOf('color') !== -1) {
      values = `${colorSpace} ${values.join(' ')}`;
    } else {
      values = `${values.join(', ')}`;
    }

    return `${type}(${values})`;
  }
  /**
   * Converts a color from hsl format to rgb format.
   * @param {string} color - HSL color values
   * @returns {string} rgb color values
   */

  function hslToRgb(color) {
    color = decomposeColor(color);
    const {
      values
    } = color;
    const h = values[0];
    const s = values[1] / 100;
    const l = values[2] / 100;
    const a = s * Math.min(l, 1 - l);

    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);

    let type = 'rgb';
    const rgb = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];

    if (color.type === 'hsla') {
      type += 'a';
      rgb.push(values[3]);
    }

    return recomposeColor({
      type,
      values: rgb
    });
  }
  /**
   * The relative brightness of any point in a color space,
   * normalized to 0 for darkest black and 1 for lightest white.
   *
   * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
   * @returns {number} The relative brightness of the color in the range 0 - 1
   */

  function getLuminance(color) {
    color = decomposeColor(color);
    let rgb = color.type === 'hsl' ? decomposeColor(hslToRgb(color)).values : color.values;
    rgb = rgb.map(val => {
      if (color.type !== 'color') {
        val /= 255; // normalized
      }

      return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    }); // Truncate at 3 digits

    return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
  }
  /**
   * Calculates the contrast ratio between two colors.
   *
   * Formula: https://www.w3.org/TR/WCAG20-TECHS/G17.html#G17-tests
   * @param {string} foreground - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @param {string} background - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla()
   * @returns {number} A contrast ratio value in the range 0 - 21.
   */

  function getContrastRatio(foreground, background) {
    const lumA = getLuminance(foreground);
    const lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  /**
   * Sets the absolute transparency of a color.
   * Any existing alpha values are overwritten.
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
   * @param {number} value - value to set the alpha channel to in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function alpha(color, value) {
    color = decomposeColor(color);
    value = clamp(value);

    if (color.type === 'rgb' || color.type === 'hsl') {
      color.type += 'a';
    }

    if (color.type === 'color') {
      color.values[3] = `/${value}`;
    } else {
      color.values[3] = value;
    }

    return recomposeColor(color);
  }
  /**
   * Darkens a color.
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
   * @param {number} coefficient - multiplier in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function darken(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);

    if (color.type.indexOf('hsl') !== -1) {
      color.values[2] *= 1 - coefficient;
    } else if (color.type.indexOf('rgb') !== -1 || color.type.indexOf('color') !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color.values[i] *= 1 - coefficient;
      }
    }

    return recomposeColor(color);
  }
  /**
   * Lightens a color.
   * @param {string} color - CSS color, i.e. one of: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color()
   * @param {number} coefficient - multiplier in the range 0 - 1
   * @returns {string} A CSS color string. Hex input values are returned as rgb
   */

  function lighten(color, coefficient) {
    color = decomposeColor(color);
    coefficient = clamp(coefficient);

    if (color.type.indexOf('hsl') !== -1) {
      color.values[2] += (100 - color.values[2]) * coefficient;
    } else if (color.type.indexOf('rgb') !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color.values[i] += (255 - color.values[i]) * coefficient;
      }
    } else if (color.type.indexOf('color') !== -1) {
      for (let i = 0; i < 3; i += 1) {
        color.values[i] += (1 - color.values[i]) * coefficient;
      }
    }

    return recomposeColor(color);
  }

  function InnerThemeProvider(props) {
    const theme = useTheme$1();
    return /*#__PURE__*/jsxRuntime.exports.jsx(ThemeContext$2.Provider, {
      value: typeof theme === 'object' ? theme : {},
      children: props.children
    });
  }
  /**
   * This component makes the `theme` available down the React tree.
   * It should preferably be used at **the root of your component tree**.
   */

  function ThemeProvider(props) {
    const {
      children,
      theme: localTheme
    } = props;
    return /*#__PURE__*/jsxRuntime.exports.jsx(ThemeProvider$1, {
      theme: localTheme,
      children: /*#__PURE__*/jsxRuntime.exports.jsx(InnerThemeProvider, {
        children: children
      })
    });
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  /**
   * Determines if a given element is a DOM element name (i.e. not a React component).
   */
  function isHostComponent(element) {
    return typeof element === 'string';
  }

  /**
   * Appends the ownerState object to the props, merging with the existing one if necessary.
   *
   * @param elementType Type of the element that owns the `existingProps`. If the element is a DOM node, `ownerState` are not applied.
   * @param existingProps Props of the element.
   * @param ownerState
   */

  function appendOwnerState(elementType, existingProps = {}, ownerState) {
    if (isHostComponent(elementType)) {
      return existingProps;
    }

    return _extends({}, existingProps, {
      ownerState: _extends({}, existingProps.ownerState, ownerState)
    });
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function composeClasses(slots, getUtilityClass, classes) {
    const output = {};
    Object.keys(slots).forEach( // `Objet.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    slot => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          if (classes && classes[key]) {
            acc.push(classes[key]);
          }

          acc.push(getUtilityClass(key));
        }

        return acc;
      }, []).join(' ');
    });
    return output;
  }

  const defaultGenerator = componentName => componentName;

  const createClassNameGenerator = () => {
    let generate = defaultGenerator;
    return {
      configure(generator) {
        generate = generator;
      },

      generate(componentName) {
        return generate(componentName);
      },

      reset() {
        generate = defaultGenerator;
      }

    };
  };

  const ClassNameGenerator = createClassNameGenerator();
  var ClassNameGenerator$1 = ClassNameGenerator;

  const globalStateClassesMapping = {
    active: 'Mui-active',
    checked: 'Mui-checked',
    completed: 'Mui-completed',
    disabled: 'Mui-disabled',
    error: 'Mui-error',
    expanded: 'Mui-expanded',
    focused: 'Mui-focused',
    focusVisible: 'Mui-focusVisible',
    required: 'Mui-required',
    selected: 'Mui-selected'
  };
  function generateUtilityClass(componentName, slot) {
    const globalStateClass = globalStateClassesMapping[slot];
    return globalStateClass || `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
  }

  function generateUtilityClasses(componentName, slots) {
    const result = {};
    slots.forEach(slot => {
      result[slot] = generateUtilityClass(componentName, slot);
    });
    return result;
  }

  function getBackdropUtilityClass(slot) {
    return generateUtilityClass('MuiBackdrop', slot);
  }
  generateUtilityClasses('MuiBackdrop', ['root', 'invisible']);

  const _excluded$m = ["classes", "className", "invisible", "component", "components", "componentsProps", "theme"];

  const useUtilityClasses$b = ownerState => {
    const {
      classes,
      invisible
    } = ownerState;
    const slots = {
      root: ['root', invisible && 'invisible']
    };
    return composeClasses(slots, getBackdropUtilityClass, classes);
  };

  const BackdropUnstyled = /*#__PURE__*/react.exports.forwardRef(function BackdropUnstyled(props, ref) {
    const {
      classes: classesProp,
      className,
      invisible = false,
      component = 'div',
      components = {},
      componentsProps = {},

      /* eslint-disable react/prop-types */
      theme
    } = props,
          other = _objectWithoutPropertiesLoose(props, _excluded$m);

    const ownerState = _extends({}, props, {
      classes: classesProp,
      invisible
    });

    const classes = useUtilityClasses$b(ownerState);
    const Root = components.Root || component;
    const rootProps = componentsProps.root || {};
    return /*#__PURE__*/jsxRuntime.exports.jsx(Root, _extends({
      "aria-hidden": true
    }, rootProps, !isHostComponent(Root) && {
      as: component,
      ownerState: _extends({}, ownerState, rootProps.ownerState),
      theme
    }, {
      ref: ref
    }, other, {
      className: clsx(classes.root, rootProps.className, className)
    }));
  });
  var BackdropUnstyled$1 = BackdropUnstyled;

  function getContainer$1(container) {
    return typeof container === 'function' ? container() : container;
  }
  /**
   * Portals provide a first-class way to render children into a DOM node
   * that exists outside the DOM hierarchy of the parent component.
   */


  const Portal = /*#__PURE__*/react.exports.forwardRef(function Portal(props, ref) {
    const {
      children,
      container,
      disablePortal = false
    } = props;
    const [mountNode, setMountNode] = react.exports.useState(null);
    const handleRef = useForkRef( /*#__PURE__*/ /*#__PURE__*/react.exports.isValidElement(children) ? children.ref : null, ref);
    useEnhancedEffect$1(() => {
      if (!disablePortal) {
        setMountNode(getContainer$1(container) || document.body);
      }
    }, [container, disablePortal]);
    useEnhancedEffect$1(() => {
      if (mountNode && !disablePortal) {
        setRef(ref, mountNode);
        return () => {
          setRef(ref, null);
        };
      }

      return undefined;
    }, [ref, mountNode, disablePortal]);

    if (disablePortal) {
      if ( /*#__PURE__*/react.exports.isValidElement(children)) {
        return /*#__PURE__*/react.exports.cloneElement(children, {
          ref: handleRef
        });
      }

      return children;
    }

    return mountNode ? /*#__PURE__*/reactDom.exports.createPortal(children, mountNode) : mountNode;
  });

  var Portal$1 = Portal;

  function isOverflowing(container) {
    const doc = ownerDocument(container);

    if (doc.body === container) {
      return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
    }

    return container.scrollHeight > container.clientHeight;
  }

  function ariaHidden(element, show) {
    if (show) {
      element.setAttribute('aria-hidden', 'true');
    } else {
      element.removeAttribute('aria-hidden');
    }
  }

  function getPaddingRight(element) {
    return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
  }

  function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude = [], show) {
    const blacklist = [mountElement, currentElement, ...elementsToExclude];
    const blacklistTagNames = ['TEMPLATE', 'SCRIPT', 'STYLE'];
    [].forEach.call(container.children, element => {
      if (blacklist.indexOf(element) === -1 && blacklistTagNames.indexOf(element.tagName) === -1) {
        ariaHidden(element, show);
      }
    });
  }

  function findIndexOf(items, callback) {
    let idx = -1;
    items.some((item, index) => {
      if (callback(item)) {
        idx = index;
        return true;
      }

      return false;
    });
    return idx;
  }

  function handleContainer(containerInfo, props) {
    const restoreStyle = [];
    const container = containerInfo.container;

    if (!props.disableScrollLock) {
      if (isOverflowing(container)) {
        // Compute the size before applying overflow hidden to avoid any scroll jumps.
        const scrollbarSize = getScrollbarSize(ownerDocument(container));
        restoreStyle.push({
          value: container.style.paddingRight,
          property: 'padding-right',
          el: container
        }); // Use computed style, here to get the real padding to add our scrollbar width.

        container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`; // .mui-fixed is a global helper.

        const fixedElements = ownerDocument(container).querySelectorAll('.mui-fixed');
        [].forEach.call(fixedElements, element => {
          restoreStyle.push({
            value: element.style.paddingRight,
            property: 'padding-right',
            el: element
          });
          element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
        });
      } // Improve Gatsby support
      // https://css-tricks.com/snippets/css/force-vertical-scrollbar/


      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      const scrollContainer = (parent == null ? void 0 : parent.nodeName) === 'HTML' && containerWindow.getComputedStyle(parent).overflowY === 'scroll' ? parent : container; // Block the scroll even if no scrollbar is visible to account for mobile keyboard
      // screensize shrink.

      restoreStyle.push({
        value: scrollContainer.style.overflow,
        property: 'overflow',
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowX,
        property: 'overflow-x',
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowY,
        property: 'overflow-y',
        el: scrollContainer
      });
      scrollContainer.style.overflow = 'hidden';
    }

    const restore = () => {
      restoreStyle.forEach(({
        value,
        el,
        property
      }) => {
        if (value) {
          el.style.setProperty(property, value);
        } else {
          el.style.removeProperty(property);
        }
      });
    };

    return restore;
  }

  function getHiddenSiblings(container) {
    const hiddenSiblings = [];
    [].forEach.call(container.children, element => {
      if (element.getAttribute('aria-hidden') === 'true') {
        hiddenSiblings.push(element);
      }
    });
    return hiddenSiblings;
  }
  /**
   * @ignore - do not document.
   *
   * Proper state management for containers and the modals in those containers.
   * Simplified, but inspired by react-overlay's ModalManager class.
   * Used by the Modal to ensure proper styling of containers.
   */


  class ModalManager {
    constructor() {
      this.containers = void 0;
      this.modals = void 0;
      this.modals = [];
      this.containers = [];
    }

    add(modal, container) {
      let modalIndex = this.modals.indexOf(modal);

      if (modalIndex !== -1) {
        return modalIndex;
      }

      modalIndex = this.modals.length;
      this.modals.push(modal); // If the modal we are adding is already in the DOM.

      if (modal.modalRef) {
        ariaHidden(modal.modalRef, false);
      }

      const hiddenSiblings = getHiddenSiblings(container);
      ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
      const containerIndex = findIndexOf(this.containers, item => item.container === container);

      if (containerIndex !== -1) {
        this.containers[containerIndex].modals.push(modal);
        return modalIndex;
      }

      this.containers.push({
        modals: [modal],
        container,
        restore: null,
        hiddenSiblings
      });
      return modalIndex;
    }

    mount(modal, props) {
      const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
      const containerInfo = this.containers[containerIndex];

      if (!containerInfo.restore) {
        containerInfo.restore = handleContainer(containerInfo, props);
      }
    }

    remove(modal) {
      const modalIndex = this.modals.indexOf(modal);

      if (modalIndex === -1) {
        return modalIndex;
      }

      const containerIndex = findIndexOf(this.containers, item => item.modals.indexOf(modal) !== -1);
      const containerInfo = this.containers[containerIndex];
      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
      this.modals.splice(modalIndex, 1); // If that was the last modal in a container, clean up the container.

      if (containerInfo.modals.length === 0) {
        // The modal might be closed before it had the chance to be mounted in the DOM.
        if (containerInfo.restore) {
          containerInfo.restore();
        }

        if (modal.modalRef) {
          // In case the modal wasn't in the DOM yet.
          ariaHidden(modal.modalRef, true);
        }

        ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
        this.containers.splice(containerIndex, 1);
      } else {
        // Otherwise make sure the next top modal is visible to a screen reader.
        const nextTop = containerInfo.modals[containerInfo.modals.length - 1]; // as soon as a modal is adding its modalRef is undefined. it can't set
        // aria-hidden because the dom element doesn't exist either
        // when modal was unmounted before modalRef gets null

        if (nextTop.modalRef) {
          ariaHidden(nextTop.modalRef, false);
        }
      }

      return modalIndex;
    }

    isTopModal(modal) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
    }

  }

  /* eslint-disable @typescript-eslint/naming-convention, consistent-return, jsx-a11y/no-noninteractive-tabindex */
  const candidatesSelector = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'].join(',');

  function getTabIndex(node) {
    const tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);

    if (!Number.isNaN(tabindexAttr)) {
      return tabindexAttr;
    } // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // https://bugs.chromium.org/p/chromium/issues/detail?id=661108&q=contenteditable%20tabindex&can=2
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    //  `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    //  yet they are still part of the regular tab order; in FF, they get a default
    //  `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    //  order, consider their tab index to be 0.


    if (node.contentEditable === 'true' || (node.nodeName === 'AUDIO' || node.nodeName === 'VIDEO' || node.nodeName === 'DETAILS') && node.getAttribute('tabindex') === null) {
      return 0;
    }

    return node.tabIndex;
  }

  function isNonTabbableRadio(node) {
    if (node.tagName !== 'INPUT' || node.type !== 'radio') {
      return false;
    }

    if (!node.name) {
      return false;
    }

    const getRadio = selector => node.ownerDocument.querySelector(`input[type="radio"]${selector}`);

    let roving = getRadio(`[name="${node.name}"]:checked`);

    if (!roving) {
      roving = getRadio(`[name="${node.name}"]`);
    }

    return roving !== node;
  }

  function isNodeMatchingSelectorFocusable(node) {
    if (node.disabled || node.tagName === 'INPUT' && node.type === 'hidden' || isNonTabbableRadio(node)) {
      return false;
    }

    return true;
  }

  function defaultGetTabbable(root) {
    const regularTabNodes = [];
    const orderedTabNodes = [];
    Array.from(root.querySelectorAll(candidatesSelector)).forEach((node, i) => {
      const nodeTabIndex = getTabIndex(node);

      if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node)) {
        return;
      }

      if (nodeTabIndex === 0) {
        regularTabNodes.push(node);
      } else {
        orderedTabNodes.push({
          documentOrder: i,
          tabIndex: nodeTabIndex,
          node
        });
      }
    });
    return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map(a => a.node).concat(regularTabNodes);
  }

  function defaultIsEnabled() {
    return true;
  }
  /**
   * Utility component that locks focus inside the component.
   */


  function Unstable_TrapFocus(props) {
    const {
      children,
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableRestoreFocus = false,
      getTabbable = defaultGetTabbable,
      isEnabled = defaultIsEnabled,
      open
    } = props;
    const ignoreNextEnforceFocus = react.exports.useRef();
    const sentinelStart = react.exports.useRef(null);
    const sentinelEnd = react.exports.useRef(null);
    const nodeToRestore = react.exports.useRef(null);
    const reactFocusEventTarget = react.exports.useRef(null); // This variable is useful when disableAutoFocus is true.
    // It waits for the active element to move into the component to activate.

    const activated = react.exports.useRef(false);
    const rootRef = react.exports.useRef(null);
    const handleRef = useForkRef(children.ref, rootRef);
    const lastKeydown = react.exports.useRef(null);
    react.exports.useEffect(() => {
      // We might render an empty child.
      if (!open || !rootRef.current) {
        return;
      }

      activated.current = !disableAutoFocus;
    }, [disableAutoFocus, open]);
    react.exports.useEffect(() => {
      // We might render an empty child.
      if (!open || !rootRef.current) {
        return;
      }

      const doc = ownerDocument(rootRef.current);

      if (!rootRef.current.contains(doc.activeElement)) {
        if (!rootRef.current.hasAttribute('tabIndex')) {

          rootRef.current.setAttribute('tabIndex', -1);
        }

        if (activated.current) {
          rootRef.current.focus();
        }
      }

      return () => {
        // restoreLastFocus()
        if (!disableRestoreFocus) {
          // In IE11 it is possible for document.activeElement to be null resulting
          // in nodeToRestore.current being null.
          // Not all elements in IE11 have a focus method.
          // Once IE11 support is dropped the focus() call can be unconditional.
          if (nodeToRestore.current && nodeToRestore.current.focus) {
            ignoreNextEnforceFocus.current = true;
            nodeToRestore.current.focus();
          }

          nodeToRestore.current = null;
        }
      }; // Missing `disableRestoreFocus` which is fine.
      // We don't support changing that prop on an open TrapFocus
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [open]);
    react.exports.useEffect(() => {
      // We might render an empty child.
      if (!open || !rootRef.current) {
        return;
      }

      const doc = ownerDocument(rootRef.current);

      const contain = nativeEvent => {
        const {
          current: rootElement
        } = rootRef; // Cleanup functions are executed lazily in React 17.
        // Contain can be called between the component being unmounted and its cleanup function being run.

        if (rootElement === null) {
          return;
        }

        if (!doc.hasFocus() || disableEnforceFocus || !isEnabled() || ignoreNextEnforceFocus.current) {
          ignoreNextEnforceFocus.current = false;
          return;
        }

        if (!rootElement.contains(doc.activeElement)) {
          // if the focus event is not coming from inside the children's react tree, reset the refs
          if (nativeEvent && reactFocusEventTarget.current !== nativeEvent.target || doc.activeElement !== reactFocusEventTarget.current) {
            reactFocusEventTarget.current = null;
          } else if (reactFocusEventTarget.current !== null) {
            return;
          }

          if (!activated.current) {
            return;
          }

          let tabbable = [];

          if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
            tabbable = getTabbable(rootRef.current);
          }

          if (tabbable.length > 0) {
            var _lastKeydown$current, _lastKeydown$current2;

            const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === 'Tab');
            const focusNext = tabbable[0];
            const focusPrevious = tabbable[tabbable.length - 1];

            if (isShiftTab) {
              focusPrevious.focus();
            } else {
              focusNext.focus();
            }
          } else {
            rootElement.focus();
          }
        }
      };

      const loopFocus = nativeEvent => {
        lastKeydown.current = nativeEvent;

        if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== 'Tab') {
          return;
        } // Make sure the next tab starts from the right place.
        // doc.activeElement referes to the origin.


        if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
          // We need to ignore the next contain as
          // it will try to move the focus back to the rootRef element.
          ignoreNextEnforceFocus.current = true;
          sentinelEnd.current.focus();
        }
      };

      doc.addEventListener('focusin', contain);
      doc.addEventListener('keydown', loopFocus, true); // With Edge, Safari and Firefox, no focus related events are fired when the focused area stops being a focused area.
      // e.g. https://bugzilla.mozilla.org/show_bug.cgi?id=559561.
      // Instead, we can look if the active element was restored on the BODY element.
      //
      // The whatwg spec defines how the browser should behave but does not explicitly mention any events:
      // https://html.spec.whatwg.org/multipage/interaction.html#focus-fixup-rule.

      const interval = setInterval(() => {
        if (doc.activeElement.tagName === 'BODY') {
          contain();
        }
      }, 50);
      return () => {
        clearInterval(interval);
        doc.removeEventListener('focusin', contain);
        doc.removeEventListener('keydown', loopFocus, true);
      };
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);

    const onFocus = event => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }

      activated.current = true;
      reactFocusEventTarget.current = event.target;
      const childrenPropsHandler = children.props.onFocus;

      if (childrenPropsHandler) {
        childrenPropsHandler(event);
      }
    };

    const handleFocusSentinel = event => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }

      activated.current = true;
    };

    return /*#__PURE__*/jsxRuntime.exports.jsxs(react.exports.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.exports.jsx("div", {
        tabIndex: 0,
        onFocus: handleFocusSentinel,
        ref: sentinelStart,
        "data-test": "sentinelStart"
      }), /*#__PURE__*/react.exports.cloneElement(children, {
        ref: handleRef,
        onFocus
      }), /*#__PURE__*/jsxRuntime.exports.jsx("div", {
        tabIndex: 0,
        onFocus: handleFocusSentinel,
        ref: sentinelEnd,
        "data-test": "sentinelEnd"
      })]
    });
  }

  function getModalUtilityClass(slot) {
    return generateUtilityClass('MuiModal', slot);
  }
  generateUtilityClasses('MuiModal', ['root', 'hidden']);

  const _excluded$l = ["BackdropComponent", "BackdropProps", "children", "classes", "className", "closeAfterTransition", "component", "components", "componentsProps", "container", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "manager", "onBackdropClick", "onClose", "onKeyDown", "open", "theme", "onTransitionEnter", "onTransitionExited"];

  const useUtilityClasses$a = ownerState => {
    const {
      open,
      exited,
      classes
    } = ownerState;
    const slots = {
      root: ['root', !open && exited && 'hidden']
    };
    return composeClasses(slots, getModalUtilityClass, classes);
  };

  function getContainer(container) {
    return typeof container === 'function' ? container() : container;
  }

  function getHasTransition(props) {
    return props.children ? props.children.props.hasOwnProperty('in') : false;
  } // A modal manager used to track and manage the state of open Modals.
  // Modals don't open on the server so this won't conflict with concurrent requests.


  const defaultManager = new ModalManager();
  /**
   * Modal is a lower-level construct that is leveraged by the following components:
   *
   * - [Dialog](/api/dialog/)
   * - [Drawer](/api/drawer/)
   * - [Menu](/api/menu/)
   * - [Popover](/api/popover/)
   *
   * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
   * rather than directly using Modal.
   *
   * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
   */

  const ModalUnstyled = /*#__PURE__*/react.exports.forwardRef(function ModalUnstyled(props, ref) {
    const {
      BackdropComponent,
      BackdropProps,
      children,
      classes: classesProp,
      className,
      closeAfterTransition = false,
      component = 'div',
      components = {},
      componentsProps = {},
      container,
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableEscapeKeyDown = false,
      disablePortal = false,
      disableRestoreFocus = false,
      disableScrollLock = false,
      hideBackdrop = false,
      keepMounted = false,
      // private
      // eslint-disable-next-line react/prop-types
      manager = defaultManager,
      onBackdropClick,
      onClose,
      onKeyDown,
      open,

      /* eslint-disable react/prop-types */
      theme,
      onTransitionEnter,
      onTransitionExited
    } = props,
          other = _objectWithoutPropertiesLoose(props, _excluded$l);

    const [exited, setExited] = react.exports.useState(true);
    const modal = react.exports.useRef({});
    const mountNodeRef = react.exports.useRef(null);
    const modalRef = react.exports.useRef(null);
    const handleRef = useForkRef(modalRef, ref);
    const hasTransition = getHasTransition(props);

    const getDoc = () => ownerDocument(mountNodeRef.current);

    const getModal = () => {
      modal.current.modalRef = modalRef.current;
      modal.current.mountNode = mountNodeRef.current;
      return modal.current;
    };

    const handleMounted = () => {
      manager.mount(getModal(), {
        disableScrollLock
      }); // Fix a bug on Chrome where the scroll isn't initially 0.

      modalRef.current.scrollTop = 0;
    };

    const handleOpen = useEventCallback(() => {
      const resolvedContainer = getContainer(container) || getDoc().body;
      manager.add(getModal(), resolvedContainer); // The element was already mounted.

      if (modalRef.current) {
        handleMounted();
      }
    });
    const isTopModal = react.exports.useCallback(() => manager.isTopModal(getModal()), [manager]);
    const handlePortalRef = useEventCallback(node => {
      mountNodeRef.current = node;

      if (!node) {
        return;
      }

      if (open && isTopModal()) {
        handleMounted();
      } else {
        ariaHidden(modalRef.current, true);
      }
    });
    const handleClose = react.exports.useCallback(() => {
      manager.remove(getModal());
    }, [manager]);
    react.exports.useEffect(() => {
      return () => {
        handleClose();
      };
    }, [handleClose]);
    react.exports.useEffect(() => {
      if (open) {
        handleOpen();
      } else if (!hasTransition || !closeAfterTransition) {
        handleClose();
      }
    }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);

    const ownerState = _extends({}, props, {
      classes: classesProp,
      closeAfterTransition,
      disableAutoFocus,
      disableEnforceFocus,
      disableEscapeKeyDown,
      disablePortal,
      disableRestoreFocus,
      disableScrollLock,
      exited,
      hideBackdrop,
      keepMounted
    });

    const classes = useUtilityClasses$a(ownerState);

    if (!keepMounted && !open && (!hasTransition || exited)) {
      return null;
    }

    const handleEnter = () => {
      setExited(false);

      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };

    const handleExited = () => {
      setExited(true);

      if (onTransitionExited) {
        onTransitionExited();
      }

      if (closeAfterTransition) {
        handleClose();
      }
    };

    const handleBackdropClick = event => {
      if (event.target !== event.currentTarget) {
        return;
      }

      if (onBackdropClick) {
        onBackdropClick(event);
      }

      if (onClose) {
        onClose(event, 'backdropClick');
      }
    };

    const handleKeyDown = event => {
      if (onKeyDown) {
        onKeyDown(event);
      } // The handler doesn't take event.defaultPrevented into account:
      //
      // event.preventDefault() is meant to stop default behaviors like
      // clicking a checkbox to check it, hitting a button to submit a form,
      // and hitting left arrow to move the cursor in a text input etc.
      // Only special HTML elements have these default behaviors.


      if (event.key !== 'Escape' || !isTopModal()) {
        return;
      }

      if (!disableEscapeKeyDown) {
        // Swallow the event, in case someone is listening for the escape key on the body.
        event.stopPropagation();

        if (onClose) {
          onClose(event, 'escapeKeyDown');
        }
      }
    };

    const childProps = {};

    if (children.props.tabIndex === undefined) {
      childProps.tabIndex = '-1';
    } // It's a Transition like component


    if (hasTransition) {
      childProps.onEnter = createChainedFunction(handleEnter, children.props.onEnter);
      childProps.onExited = createChainedFunction(handleExited, children.props.onExited);
    }

    const Root = components.Root || component;
    const rootProps = componentsProps.root || {};
    return /*#__PURE__*/jsxRuntime.exports.jsx(Portal$1, {
      ref: handlePortalRef,
      container: container,
      disablePortal: disablePortal,
      children: /*#__PURE__*/jsxRuntime.exports.jsxs(Root, _extends({
        role: "presentation"
      }, rootProps, !isHostComponent(Root) && {
        as: component,
        ownerState: _extends({}, ownerState, rootProps.ownerState),
        theme
      }, other, {
        ref: handleRef,
        onKeyDown: handleKeyDown,
        className: clsx(classes.root, rootProps.className, className),
        children: [!hideBackdrop && BackdropComponent ? /*#__PURE__*/jsxRuntime.exports.jsx(BackdropComponent, _extends({
          open: open,
          onClick: handleBackdropClick
        }, BackdropProps)) : null, /*#__PURE__*/jsxRuntime.exports.jsx(Unstable_TrapFocus, {
          disableEnforceFocus: disableEnforceFocus,
          disableAutoFocus: disableAutoFocus,
          disableRestoreFocus: disableRestoreFocus,
          isEnabled: isTopModal,
          open: open,
          children: /*#__PURE__*/react.exports.cloneElement(children, childProps)
        })]
      }))
    });
  });
  var ModalUnstyled$1 = ModalUnstyled;

  var top = 'top';
  var bottom = 'bottom';
  var right = 'right';
  var left = 'left';
  var auto = 'auto';
  var basePlacements = [top, bottom, right, left];
  var start = 'start';
  var end = 'end';
  var clippingParents = 'clippingParents';
  var viewport = 'viewport';
  var popper = 'popper';
  var reference = 'reference';
  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []); // modifiers that need to read the DOM

  var beforeRead = 'beforeRead';
  var read = 'read';
  var afterRead = 'afterRead'; // pure-logic modifiers

  var beforeMain = 'beforeMain';
  var main = 'main';
  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)

  var beforeWrite = 'beforeWrite';
  var write = 'write';
  var afterWrite = 'afterWrite';
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  function getNodeName(element) {
    return element ? (element.nodeName || '').toLowerCase() : null;
  }

  function getWindow(node) {
    if (node == null) {
      return window;
    }

    if (node.toString() !== '[object Window]') {
      var ownerDocument = node.ownerDocument;
      return ownerDocument ? ownerDocument.defaultView || window : window;
    }

    return node;
  }

  function isElement(node) {
    var OwnElement = getWindow(node).Element;
    return node instanceof OwnElement || node instanceof Element;
  }

  function isHTMLElement(node) {
    var OwnElement = getWindow(node).HTMLElement;
    return node instanceof OwnElement || node instanceof HTMLElement;
  }

  function isShadowRoot(node) {
    // IE 11 has no ShadowRoot
    if (typeof ShadowRoot === 'undefined') {
      return false;
    }

    var OwnElement = getWindow(node).ShadowRoot;
    return node instanceof OwnElement || node instanceof ShadowRoot;
  }

  // and applies them to the HTMLElements such as popper and arrow

  function applyStyles(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function (name) {
      var style = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name]; // arrow is optional + virtual elements

      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      } // Flow doesn't support to extend this property, but it's the most
      // effective way to apply styles to an HTMLElement
      // $FlowFixMe[cannot-write]


      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function (name) {
        var value = attributes[name];

        if (value === false) {
          element.removeAttribute(name);
        } else {
          element.setAttribute(name, value === true ? '' : value);
        }
      });
    });
  }

  function effect$2(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: '0',
        top: '0',
        margin: '0'
      },
      arrow: {
        position: 'absolute'
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;

    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }

    return function () {
      Object.keys(state.elements).forEach(function (name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them

        var style = styleProperties.reduce(function (style, property) {
          style[property] = '';
          return style;
        }, {}); // arrow is optional + virtual elements

        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }

        Object.assign(element.style, style);
        Object.keys(attributes).forEach(function (attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  } // eslint-disable-next-line import/no-unused-modules


  var applyStyles$1 = {
    name: 'applyStyles',
    enabled: true,
    phase: 'write',
    fn: applyStyles,
    effect: effect$2,
    requires: ['computeStyles']
  };

  function getBasePlacement(placement) {
    return placement.split('-')[0];
  }

  // import { isHTMLElement } from './instanceOf';
  function getBoundingClientRect(element, // eslint-disable-next-line unused-imports/no-unused-vars
  includeScale) {

    var rect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1; // FIXME:
    // `offsetWidth` returns an integer while `getBoundingClientRect`
    // returns a float. This results in `scaleX` or `scaleY` being
    // non-1 when it should be for elements that aren't a full pixel in
    // width or height.
    // if (isHTMLElement(element) && includeScale) {
    //   const offsetHeight = element.offsetHeight;
    //   const offsetWidth = element.offsetWidth;
    //   // Do not attempt to divide by 0, otherwise we get `Infinity` as scale
    //   // Fallback to 1 in case both values are `0`
    //   if (offsetWidth > 0) {
    //     scaleX = rect.width / offsetWidth || 1;
    //   }
    //   if (offsetHeight > 0) {
    //     scaleY = rect.height / offsetHeight || 1;
    //   }
    // }

    return {
      width: rect.width / scaleX,
      height: rect.height / scaleY,
      top: rect.top / scaleY,
      right: rect.right / scaleX,
      bottom: rect.bottom / scaleY,
      left: rect.left / scaleX,
      x: rect.left / scaleX,
      y: rect.top / scaleY
    };
  }

  // means it doesn't take into account transforms.

  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.
    // Fixes https://github.com/popperjs/popper-core/issues/1223

    var width = element.offsetWidth;
    var height = element.offsetHeight;

    if (Math.abs(clientRect.width - width) <= 1) {
      width = clientRect.width;
    }

    if (Math.abs(clientRect.height - height) <= 1) {
      height = clientRect.height;
    }

    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width,
      height: height
    };
  }

  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method

    if (parent.contains(child)) {
      return true;
    } // then fallback to custom implementation with Shadow DOM support
    else if (rootNode && isShadowRoot(rootNode)) {
      var next = child;

      do {
        if (next && parent.isSameNode(next)) {
          return true;
        } // $FlowFixMe[prop-missing]: need a better way to handle this...


        next = next.parentNode || next.host;
      } while (next);
    } // Give up, the result is false


    return false;
  }

  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  function isTableElement(element) {
    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;
  }

  function getDocumentElement(element) {
    // $FlowFixMe[incompatible-return]: assume body is always available
    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]
    element.document) || window.document).documentElement;
  }

  function getParentNode(element) {
    if (getNodeName(element) === 'html') {
      return element;
    }

    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || ( // DOM Element detected
      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element) // fallback

    );
  }

  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === 'fixed') {
      return null;
    }

    return element.offsetParent;
  } // `.offsetParent` reports `null` for fixed elements, while absolute elements
  // return the containing block


  function getContainingBlock(element) {
    var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') !== -1;
    var isIE = navigator.userAgent.indexOf('Trident') !== -1;

    if (isIE && isHTMLElement(element)) {
      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport
      var elementCss = getComputedStyle(element);

      if (elementCss.position === 'fixed') {
        return null;
      }
    }

    var currentNode = getParentNode(element);

    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {
      var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that
      // create a containing block.
      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block

      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }

    return null;
  } // Gets the closest ancestor positioned element. Handles some edge cases,
  // such as table ancestors and cross browser bugs.


  function getOffsetParent(element) {
    var window = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);

    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {
      offsetParent = getTrueOffsetParent(offsetParent);
    }

    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {
      return window;
    }

    return offsetParent || getContainingBlock(element) || window;
  }

  function getMainAxisFromPlacement(placement) {
    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';
  }

  var max = Math.max;
  var min = Math.min;
  var round$2 = Math.round;

  function within(min$1, value, max$1) {
    return max(min$1, min(value, max$1));
  }

  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  function expandToHashMap(value, keys) {
    return keys.reduce(function (hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  var toPaddingObject = function toPaddingObject(padding, state) {
    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding;
    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
  };

  function arrow(_ref) {
    var _state$modifiersData$;

    var state = _ref.state,
        name = _ref.name,
        options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? 'height' : 'width';

    if (!arrowElement || !popperOffsets) {
      return;
    }

    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === 'y' ? top : left;
    var maxProp = axis === 'y' ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
    var startDiff = popperOffsets[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is
    // outside of the popper bounds

    var min = paddingObject[minProp];
    var max = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset = within(min, center, max); // Prevents breaking syntax highlighting...

    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
  }

  function effect$1(_ref2) {
    var state = _ref2.state,
        options = _ref2.options;
    var _options$element = options.element,
        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;

    if (arrowElement == null) {
      return;
    } // CSS selector


    if (typeof arrowElement === 'string') {
      arrowElement = state.elements.popper.querySelector(arrowElement);

      if (!arrowElement) {
        return;
      }
    }

    if (!contains(state.elements.popper, arrowElement)) {

      return;
    }

    state.elements.arrow = arrowElement;
  } // eslint-disable-next-line import/no-unused-modules


  var arrow$1 = {
    name: 'arrow',
    enabled: true,
    phase: 'main',
    fn: arrow,
    effect: effect$1,
    requires: ['popperOffsets'],
    requiresIfExists: ['preventOverflow']
  };

  function getVariation(placement) {
    return placement.split('-')[1];
  }

  var unsetSides = {
    top: 'auto',
    right: 'auto',
    bottom: 'auto',
    left: 'auto'
  }; // Round the offsets to the nearest suitable subpixel based on the DPR.
  // Zooming can change the DPR, but it seems to report a value that will
  // cleanly divide the values into the appropriate subpixels.

  function roundOffsetsByDPR(_ref) {
    var x = _ref.x,
        y = _ref.y;
    var win = window;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round$2(round$2(x * dpr) / dpr) || 0,
      y: round$2(round$2(y * dpr) / dpr) || 0
    };
  }

  function mapToStyles(_ref2) {
    var _Object$assign2;

    var popper = _ref2.popper,
        popperRect = _ref2.popperRect,
        placement = _ref2.placement,
        variation = _ref2.variation,
        offsets = _ref2.offsets,
        position = _ref2.position,
        gpuAcceleration = _ref2.gpuAcceleration,
        adaptive = _ref2.adaptive,
        roundOffsets = _ref2.roundOffsets;

    var _ref3 = roundOffsets === true ? roundOffsetsByDPR(offsets) : typeof roundOffsets === 'function' ? roundOffsets(offsets) : offsets,
        _ref3$x = _ref3.x,
        x = _ref3$x === void 0 ? 0 : _ref3$x,
        _ref3$y = _ref3.y,
        y = _ref3$y === void 0 ? 0 : _ref3$y;

    var hasX = offsets.hasOwnProperty('x');
    var hasY = offsets.hasOwnProperty('y');
    var sideX = left;
    var sideY = top;
    var win = window;

    if (adaptive) {
      var offsetParent = getOffsetParent(popper);
      var heightProp = 'clientHeight';
      var widthProp = 'clientWidth';

      if (offsetParent === getWindow(popper)) {
        offsetParent = getDocumentElement(popper);

        if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {
          heightProp = 'scrollHeight';
          widthProp = 'scrollWidth';
        }
      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it


      offsetParent = offsetParent;

      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom; // $FlowFixMe[prop-missing]

        y -= offsetParent[heightProp] - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }

      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right; // $FlowFixMe[prop-missing]

        x -= offsetParent[widthProp] - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }

    var commonStyles = Object.assign({
      position: position
    }, adaptive && unsetSides);

    if (gpuAcceleration) {
      var _Object$assign;

      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }

    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : '', _Object$assign2[sideX] = hasX ? x + "px" : '', _Object$assign2.transform = '', _Object$assign2));
  }

  function computeStyles(_ref4) {
    var state = _ref4.state,
        options = _ref4.options;
    var _options$gpuAccelerat = options.gpuAcceleration,
        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
        _options$adaptive = options.adaptive,
        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
        _options$roundOffsets = options.roundOffsets,
        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;

    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration: gpuAcceleration
    };

    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive: adaptive,
        roundOffsets: roundOffsets
      })));
    }

    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: 'absolute',
        adaptive: false,
        roundOffsets: roundOffsets
      })));
    }

    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-placement': state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var computeStyles$1 = {
    name: 'computeStyles',
    enabled: true,
    phase: 'beforeWrite',
    fn: computeStyles,
    data: {}
  };

  var passive = {
    passive: true
  };

  function effect(_ref) {
    var state = _ref.state,
        instance = _ref.instance,
        options = _ref.options;
    var _options$scroll = options.scroll,
        scroll = _options$scroll === void 0 ? true : _options$scroll,
        _options$resize = options.resize,
        resize = _options$resize === void 0 ? true : _options$resize;
    var window = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);

    if (scroll) {
      scrollParents.forEach(function (scrollParent) {
        scrollParent.addEventListener('scroll', instance.update, passive);
      });
    }

    if (resize) {
      window.addEventListener('resize', instance.update, passive);
    }

    return function () {
      if (scroll) {
        scrollParents.forEach(function (scrollParent) {
          scrollParent.removeEventListener('scroll', instance.update, passive);
        });
      }

      if (resize) {
        window.removeEventListener('resize', instance.update, passive);
      }
    };
  } // eslint-disable-next-line import/no-unused-modules


  var eventListeners = {
    name: 'eventListeners',
    enabled: true,
    phase: 'write',
    fn: function fn() {},
    effect: effect,
    data: {}
  };

  var hash$1 = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash$1[matched];
    });
  }

  var hash = {
    start: 'end',
    end: 'start'
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function (matched) {
      return hash[matched];
    });
  }

  function getWindowScroll(node) {
    var win = getWindow(node);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft: scrollLeft,
      scrollTop: scrollTop
    };
  }

  function getWindowScrollBarX(element) {
    // If <html> has a CSS width greater than the viewport, then this will be
    // incorrect for RTL.
    // Popper 1 is broken in this case and never had a bug report so let's assume
    // it's not an issue. I don't think anyone ever specifies width on <html>
    // anyway.
    // Browsers where the left scrollbar doesn't cause an issue report `0` for
    // this (e.g. Edge 2019, IE11, Safari)
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  function getViewportRect(element) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width = html.clientWidth;
    var height = html.clientHeight;
    var x = 0;
    var y = 0; // NB: This isn't supported on iOS <= 12. If the keyboard is open, the popper
    // can be obscured underneath it.
    // Also, `html.clientHeight` adds the bottom bar height in Safari iOS, even
    // if it isn't open, so if this isn't available, the popper will be detected
    // to overflow the bottom of the screen too early.

    if (visualViewport) {
      width = visualViewport.width;
      height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)
      // In Chrome, it returns a value very close to 0 (+/-) but contains rounding
      // errors due to floating point numbers, so we need to check precision.
      // Safari returns a number <= 0, usually < -1 when pinch-zoomed
      // Feature detection fails in mobile emulation mode in Chrome.
      // Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) <
      // 0.001
      // Fallback here: "Not Safari" userAgent

      if (!/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }

    return {
      width: width,
      height: height,
      x: x + getWindowScrollBarX(element),
      y: y
    };
  }

  // of the `<html>` and `<body>` rect bounds if horizontally scrollable

  function getDocumentRect(element) {
    var _element$ownerDocumen;

    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;

    if (getComputedStyle(body || html).direction === 'rtl') {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
    }

    return {
      width: width,
      height: height,
      x: x,
      y: y
    };
  }

  function isScrollParent(element) {
    // Firefox wants us to check `-x` and `-y` variations as well
    var _getComputedStyle = getComputedStyle(element),
        overflow = _getComputedStyle.overflow,
        overflowX = _getComputedStyle.overflowX,
        overflowY = _getComputedStyle.overflowY;

    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  function getScrollParent(node) {
    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {
      // $FlowFixMe[incompatible-return]: assume body is always available
      return node.ownerDocument.body;
    }

    if (isHTMLElement(node) && isScrollParent(node)) {
      return node;
    }

    return getScrollParent(getParentNode(node));
  }

  /*
  given a DOM element, return the list of all scroll parents, up the list of ancesors
  until we get to the top window object. This list is what we attach scroll listeners
  to, because if any of these parent elements scroll, we'll need to re-calculate the
  reference element's position.
  */

  function listScrollParents(element, list) {
    var _element$ownerDocumen;

    if (list === void 0) {
      list = [];
    }

    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)));
  }

  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  function getInnerBoundingClientRect(element) {
    var rect = getBoundingClientRect(element);
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }

  function getClientRectFromMixedType(element, clippingParent) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getInnerBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  } // A "clipping parent" is an overflowable container with the characteristic of
  // clipping (or hiding) overflowing elements with a position different from
  // `initial`


  function getClippingParents(element) {
    var clippingParents = listScrollParents(getParentNode(element));
    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;

    if (!isElement(clipperElement)) {
      return [];
    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414


    return clippingParents.filter(function (clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';
    });
  } // Gets the maximum area that the element is visible in due to any number of
  // clipping parents


  function getClippingRect(element, boundary, rootBoundary) {
    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);
    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents[0];
    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  function computeOffsets(_ref) {
    var reference = _ref.reference,
        element = _ref.element,
        placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference.x + reference.width / 2 - element.width / 2;
    var commonY = reference.y + reference.height / 2 - element.height / 2;
    var offsets;

    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference.y - element.height
        };
        break;

      case bottom:
        offsets = {
          x: commonX,
          y: reference.y + reference.height
        };
        break;

      case right:
        offsets = {
          x: reference.x + reference.width,
          y: commonY
        };
        break;

      case left:
        offsets = {
          x: reference.x - element.width,
          y: commonY
        };
        break;

      default:
        offsets = {
          x: reference.x,
          y: reference.y
        };
    }

    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;

    if (mainAxis != null) {
      var len = mainAxis === 'y' ? 'height' : 'width';

      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
          break;

        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
          break;
      }
    }

    return offsets;
  }

  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        _options$placement = _options.placement,
        placement = _options$placement === void 0 ? state.placement : _options$placement,
        _options$boundary = _options.boundary,
        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,
        _options$rootBoundary = _options.rootBoundary,
        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,
        _options$elementConte = _options.elementContext,
        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,
        _options$altBoundary = _options.altBoundary,
        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,
        _options$padding = _options.padding,
        padding = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: 'absolute',
      placement: placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect
    // 0 or negative = within the clipping rect

    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element

    if (elementContext === popper && offsetData) {
      var offset = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function (key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';
        overflowOffsets[key] += offset[axis] * multiply;
      });
    }

    return overflowOffsets;
  }

  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        placement = _options.placement,
        boundary = _options.boundary,
        rootBoundary = _options.rootBoundary,
        padding = _options.padding,
        flipVariations = _options.flipVariations,
        _options$allowedAutoP = _options.allowedAutoPlacements,
        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {
      return getVariation(placement) === variation;
    }) : basePlacements;
    var allowedPlacements = placements$1.filter(function (placement) {
      return allowedAutoPlacements.indexOf(placement) >= 0;
    });

    if (allowedPlacements.length === 0) {
      allowedPlacements = placements$1;
    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...


    var overflows = allowedPlacements.reduce(function (acc, placement) {
      acc[placement] = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding
      })[getBasePlacement(placement)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function (a, b) {
      return overflows[a] - overflows[b];
    });
  }

  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }

    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }

  function flip(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;

    if (state.modifiersData[name]._skip) {
      return;
    }

    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,
        specifiedFallbackPlacements = options.fallbackPlacements,
        padding = options.padding,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        _options$flipVariatio = options.flipVariations,
        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,
        allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {
      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        padding: padding,
        flipVariations: flipVariations,
        allowedAutoPlacements: allowedAutoPlacements
      }) : placement);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements[0];

    for (var i = 0; i < placements.length; i++) {
      var placement = placements[i];

      var _basePlacement = getBasePlacement(placement);

      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? 'width' : 'height';
      var overflow = detectOverflow(state, {
        placement: placement,
        boundary: boundary,
        rootBoundary: rootBoundary,
        altBoundary: altBoundary,
        padding: padding
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;

      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }

      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];

      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }

      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }

      if (checks.every(function (check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }

      checksMap.set(placement, checks);
    }

    if (makeFallbackChecks) {
      // `2` may be desired in some cases – research later
      var numberOfChecks = flipVariations ? 3 : 1;

      var _loop = function _loop(_i) {
        var fittingPlacement = placements.find(function (placement) {
          var checks = checksMap.get(placement);

          if (checks) {
            return checks.slice(0, _i).every(function (check) {
              return check;
            });
          }
        });

        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };

      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);

        if (_ret === "break") break;
      }
    }

    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  } // eslint-disable-next-line import/no-unused-modules


  var flip$1 = {
    name: 'flip',
    enabled: true,
    phase: 'main',
    fn: flip,
    requiresIfExists: ['offset'],
    data: {
      _skip: false
    }
  };

  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }

    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }

  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function (side) {
      return overflow[side] >= 0;
    });
  }

  function hide(_ref) {
    var state = _ref.state,
        name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: 'reference'
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets: referenceClippingOffsets,
      popperEscapeOffsets: popperEscapeOffsets,
      isReferenceHidden: isReferenceHidden,
      hasPopperEscaped: hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      'data-popper-reference-hidden': isReferenceHidden,
      'data-popper-escaped': hasPopperEscaped
    });
  } // eslint-disable-next-line import/no-unused-modules


  var hide$1 = {
    name: 'hide',
    enabled: true,
    phase: 'main',
    requiresIfExists: ['preventOverflow'],
    fn: hide
  };

  function distanceAndSkiddingToXY(placement, rects, offset) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;

    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {
      placement: placement
    })) : offset,
        skidding = _ref[0],
        distance = _ref[1];

    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }

  function offset(_ref2) {
    var state = _ref2.state,
        options = _ref2.options,
        name = _ref2.name;
    var _options$offset = options.offset,
        offset = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function (acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement],
        x = _data$state$placement.x,
        y = _data$state$placement.y;

    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var offset$1 = {
    name: 'offset',
    enabled: true,
    phase: 'main',
    requires: ['popperOffsets'],
    fn: offset
  };

  function popperOffsets(_ref) {
    var state = _ref.state,
        name = _ref.name; // Offsets are the actual position the popper needs to have to be
    // properly positioned near its reference element
    // This is the most basic placement, and will be adjusted by
    // the modifiers in the next step

    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: 'absolute',
      placement: state.placement
    });
  } // eslint-disable-next-line import/no-unused-modules


  var popperOffsets$1 = {
    name: 'popperOffsets',
    enabled: true,
    phase: 'read',
    fn: popperOffsets,
    data: {}
  };

  function getAltAxis(axis) {
    return axis === 'x' ? 'y' : 'x';
  }

  function preventOverflow(_ref) {
    var state = _ref.state,
        options = _ref.options,
        name = _ref.name;
    var _options$mainAxis = options.mainAxis,
        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,
        _options$altAxis = options.altAxis,
        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,
        boundary = options.boundary,
        rootBoundary = options.rootBoundary,
        altBoundary = options.altBoundary,
        padding = options.padding,
        _options$tether = options.tether,
        tether = _options$tether === void 0 ? true : _options$tether,
        _options$tetherOffset = options.tetherOffset,
        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary: boundary,
      rootBoundary: rootBoundary,
      padding: padding,
      altBoundary: altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var data = {
      x: 0,
      y: 0
    };

    if (!popperOffsets) {
      return;
    }

    if (checkMainAxis || checkAltAxis) {
      var mainSide = mainAxis === 'y' ? top : left;
      var altSide = mainAxis === 'y' ? bottom : right;
      var len = mainAxis === 'y' ? 'height' : 'width';
      var offset = popperOffsets[mainAxis];
      var min$1 = popperOffsets[mainAxis] + overflow[mainSide];
      var max$1 = popperOffsets[mainAxis] - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go
      // outside the reference bounds

      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want
      // to include its full size in the calculation. If the reference is small
      // and near the edge of a boundary, the popper can overflow even if the
      // reference is not overflowing as well (e.g. virtual elements with no
      // width or height)

      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;
      var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;

      if (checkMainAxis) {
        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);
        popperOffsets[mainAxis] = preventedOffset;
        data[mainAxis] = preventedOffset - offset;
      }

      if (checkAltAxis) {
        var _mainSide = mainAxis === 'x' ? top : left;

        var _altSide = mainAxis === 'x' ? bottom : right;

        var _offset = popperOffsets[altAxis];

        var _min = _offset + overflow[_mainSide];

        var _max = _offset - overflow[_altSide];

        var _preventedOffset = within(tether ? min(_min, tetherMin) : _min, _offset, tether ? max(_max, tetherMax) : _max);

        popperOffsets[altAxis] = _preventedOffset;
        data[altAxis] = _preventedOffset - _offset;
      }
    }

    state.modifiersData[name] = data;
  } // eslint-disable-next-line import/no-unused-modules


  var preventOverflow$1 = {
    name: 'preventOverflow',
    enabled: true,
    phase: 'main',
    fn: preventOverflow,
    requiresIfExists: ['offset']
  };

  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  function getNodeScroll(node) {
    if (node === getWindow(node) || !isHTMLElement(node)) {
      return getWindowScroll(node);
    } else {
      return getHTMLElementScroll(node);
    }
  }

  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = rect.width / element.offsetWidth || 1;
    var scaleY = rect.height / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  } // Returns the composite rect of an element relative to its offsetParent.
  // Composite means it takes into account transforms as well as layout.


  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }

    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };

    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }

      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }

    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  function order(modifiers) {
    var map = new Map();
    var visited = new Set();
    var result = [];
    modifiers.forEach(function (modifier) {
      map.set(modifier.name, modifier);
    }); // On visiting object, check for its dependencies and visit them recursively

    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function (dep) {
        if (!visited.has(dep)) {
          var depModifier = map.get(dep);

          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }

    modifiers.forEach(function (modifier) {
      if (!visited.has(modifier.name)) {
        // check for visited object
        sort(modifier);
      }
    });
    return result;
  }

  function orderModifiers(modifiers) {
    // order based on dependencies
    var orderedModifiers = order(modifiers); // order based on phase

    return modifierPhases.reduce(function (acc, phase) {
      return acc.concat(orderedModifiers.filter(function (modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  function debounce(fn) {
    var pending;
    return function () {
      if (!pending) {
        pending = new Promise(function (resolve) {
          Promise.resolve().then(function () {
            pending = undefined;
            resolve(fn());
          });
        });
      }

      return pending;
    };
  }

  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function (merged, current) {
      var existing = merged[current.name];
      merged[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged;
    }, {}); // IE11 does not support Object.values

    return Object.keys(merged).map(function (key) {
      return merged[key];
    });
  }

  var DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
  };

  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return !args.some(function (element) {
      return !(element && typeof element.getBoundingClientRect === 'function');
    });
  }

  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }

    var _generatorOptions = generatorOptions,
        _generatorOptions$def = _generatorOptions.defaultModifiers,
        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,
        _generatorOptions$def2 = _generatorOptions.defaultOptions,
        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper(reference, popper, options) {
      if (options === void 0) {
        options = defaultOptions;
      }

      var state = {
        placement: 'bottom',
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference,
          popper: popper
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance = {
        state: state,
        setOptions: function setOptions(setOptionsAction) {
          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options);
          state.scrollParents = {
            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
            popper: listScrollParents(popper)
          }; // Orders the modifiers based on their dependencies and `phase`
          // properties

          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

          state.orderedModifiers = orderedModifiers.filter(function (m) {
            return m.enabled;
          }); // Validate the provided modifiers so that the consumer will get warned

          runModifierEffects();
          return instance.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }

          var _state$elements = state.elements,
              reference = _state$elements.reference,
              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements
          // anymore

          if (!areValidElements(reference, popper)) {

            return;
          } // Store the reference and popper rects to be read by modifiers


          state.rects = {
            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),
            popper: getLayoutRect(popper)
          }; // Modifiers have the ability to reset the current update cycle. The
          // most common use case for this is the `flip` modifier changing the
          // placement, which then needs to re-run all the modifiers, because the
          // logic was previously ran for the previous placement and is therefore
          // stale/incorrect

          state.reset = false;
          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier
          // is filled with the initial data specified by the modifier. This means
          // it doesn't persist and is fresh on each update.
          // To ensure persistent data, use `${name}#persistent`

          state.orderedModifiers.forEach(function (modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });

          for (var index = 0; index < state.orderedModifiers.length; index++) {

            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }

            var _state$orderedModifie = state.orderedModifiers[index],
                fn = _state$orderedModifie.fn,
                _state$orderedModifie2 = _state$orderedModifie.options,
                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,
                name = _state$orderedModifie.name;

            if (typeof fn === 'function') {
              state = fn({
                state: state,
                options: _options,
                name: name,
                instance: instance
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function () {
          return new Promise(function (resolve) {
            instance.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };

      if (!areValidElements(reference, popper)) {

        return instance;
      }

      instance.setOptions(options).then(function (state) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state);
        }
      }); // Modifiers have the ability to execute arbitrary code before the first
      // update cycle runs. They will be executed in the same order as the update
      // cycle. This is useful when a modifier adds some persistent data that
      // other modifiers need to use, but the modifier is run after the dependent
      // one.

      function runModifierEffects() {
        state.orderedModifiers.forEach(function (_ref3) {
          var name = _ref3.name,
              _ref3$options = _ref3.options,
              options = _ref3$options === void 0 ? {} : _ref3$options,
              effect = _ref3.effect;

          if (typeof effect === 'function') {
            var cleanupFn = effect({
              state: state,
              name: name,
              instance: instance,
              options: options
            });

            var noopFn = function noopFn() {};

            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }

      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function (fn) {
          return fn();
        });
        effectCleanupFns = [];
      }

      return instance;
    };
  }

  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
  var createPopper = /*#__PURE__*/popperGenerator({
    defaultModifiers: defaultModifiers
  }); // eslint-disable-next-line import/no-unused-modules

  const _excluded$k = ["anchorEl", "children", "direction", "disablePortal", "modifiers", "open", "placement", "popperOptions", "popperRef", "TransitionProps"],
        _excluded2$2 = ["anchorEl", "children", "container", "direction", "disablePortal", "keepMounted", "modifiers", "open", "placement", "popperOptions", "popperRef", "style", "transition"];

  function flipPlacement(placement, direction) {
    if (direction === 'ltr') {
      return placement;
    }

    switch (placement) {
      case 'bottom-end':
        return 'bottom-start';

      case 'bottom-start':
        return 'bottom-end';

      case 'top-end':
        return 'top-start';

      case 'top-start':
        return 'top-end';

      default:
        return placement;
    }
  }

  function resolveAnchorEl$1(anchorEl) {
    return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
  }

  const defaultPopperOptions = {};
  /* eslint-disable react/prop-types */

  const PopperTooltip = /*#__PURE__*/react.exports.forwardRef(function PopperTooltip(props, ref) {
    const {
      anchorEl,
      children,
      direction,
      disablePortal,
      modifiers,
      open,
      placement: initialPlacement,
      popperOptions,
      popperRef: popperRefProp,
      TransitionProps
    } = props,
          other = _objectWithoutPropertiesLoose(props, _excluded$k);

    const tooltipRef = react.exports.useRef(null);
    const ownRef = useForkRef(tooltipRef, ref);
    const popperRef = react.exports.useRef(null);
    const handlePopperRef = useForkRef(popperRef, popperRefProp);
    const handlePopperRefRef = react.exports.useRef(handlePopperRef);
    useEnhancedEffect$1(() => {
      handlePopperRefRef.current = handlePopperRef;
    }, [handlePopperRef]);
    react.exports.useImperativeHandle(popperRefProp, () => popperRef.current, []);
    const rtlPlacement = flipPlacement(initialPlacement, direction);
    /**
     * placement initialized from prop but can change during lifetime if modifiers.flip.
     * modifiers.flip is essentially a flip for controlled/uncontrolled behavior
     */

    const [placement, setPlacement] = react.exports.useState(rtlPlacement);
    react.exports.useEffect(() => {
      if (popperRef.current) {
        popperRef.current.forceUpdate();
      }
    });
    useEnhancedEffect$1(() => {
      if (!anchorEl || !open) {
        return undefined;
      }

      const handlePopperUpdate = data => {
        setPlacement(data.placement);
      };

      resolveAnchorEl$1(anchorEl);

      let popperModifiers = [{
        name: 'preventOverflow',
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: 'flip',
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: 'onUpdate',
        enabled: true,
        phase: 'afterWrite',
        fn: ({
          state
        }) => {
          handlePopperUpdate(state);
        }
      }];

      if (modifiers != null) {
        popperModifiers = popperModifiers.concat(modifiers);
      }

      if (popperOptions && popperOptions.modifiers != null) {
        popperModifiers = popperModifiers.concat(popperOptions.modifiers);
      }

      const popper = createPopper(resolveAnchorEl$1(anchorEl), tooltipRef.current, _extends({
        placement: rtlPlacement
      }, popperOptions, {
        modifiers: popperModifiers
      }));
      handlePopperRefRef.current(popper);
      return () => {
        popper.destroy();
        handlePopperRefRef.current(null);
      };
    }, [anchorEl, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
    const childProps = {
      placement
    };

    if (TransitionProps !== null) {
      childProps.TransitionProps = TransitionProps;
    }

    return /*#__PURE__*/jsxRuntime.exports.jsx("div", _extends({
      ref: ownRef,
      role: "tooltip"
    }, other, {
      children: typeof children === 'function' ? children(childProps) : children
    }));
  });
  /* eslint-enable react/prop-types */

  /**
   * Poppers rely on the 3rd party library [Popper.js](https://popper.js.org/docs/v2/) for positioning.
   */

  const PopperUnstyled = /*#__PURE__*/react.exports.forwardRef(function PopperUnstyled(props, ref) {
    const {
      anchorEl,
      children,
      container: containerProp,
      direction = 'ltr',
      disablePortal = false,
      keepMounted = false,
      modifiers,
      open,
      placement = 'bottom',
      popperOptions = defaultPopperOptions,
      popperRef,
      style,
      transition = false
    } = props,
          other = _objectWithoutPropertiesLoose(props, _excluded2$2);

    const [exited, setExited] = react.exports.useState(true);

    const handleEnter = () => {
      setExited(false);
    };

    const handleExited = () => {
      setExited(true);
    };

    if (!keepMounted && !open && (!transition || exited)) {
      return null;
    } // If the container prop is provided, use that
    // If the anchorEl prop is provided, use its parent body element as the container
    // If neither are provided let the Modal take care of choosing the container


    const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl$1(anchorEl)).body : undefined);
    return /*#__PURE__*/jsxRuntime.exports.jsx(Portal$1, {
      disablePortal: disablePortal,
      container: container,
      children: /*#__PURE__*/jsxRuntime.exports.jsx(PopperTooltip, _extends({
        anchorEl: anchorEl,
        direction: direction,
        disablePortal: disablePortal,
        modifiers: modifiers,
        ref: ref,
        open: transition ? !exited : open,
        placement: placement,
        popperOptions: popperOptions,
        popperRef: popperRef
      }, other, {
        style: _extends({
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: 'fixed',
          // Fix Popper.js display issue
          top: 0,
          left: 0,
          display: !open && keepMounted && (!transition || exited) ? 'none' : null
        }, style),
        TransitionProps: transition ? {
          in: open,
          onEnter: handleEnter,
          onExited: handleExited
        } : null,
        children: children
      }))
    });
  });
  var PopperUnstyled$1 = PopperUnstyled;

  function createMixins(breakpoints, spacing, mixins) {
    return _extends$4({
      toolbar: {
        minHeight: 56,
        [`${breakpoints.up('xs')} and (orientation: landscape)`]: {
          minHeight: 48
        },
        [breakpoints.up('sm')]: {
          minHeight: 64
        }
      }
    }, mixins);
  }

  const _excluded$j = ["mode", "contrastThreshold", "tonalOffset"];
  const light = {
    // The colors used to style the text.
    text: {
      // The most important text.
      primary: 'rgba(0, 0, 0, 0.87)',
      // Secondary text.
      secondary: 'rgba(0, 0, 0, 0.6)',
      // Disabled text have even lower visual prominence.
      disabled: 'rgba(0, 0, 0, 0.38)'
    },
    // The color used to divide different elements.
    divider: 'rgba(0, 0, 0, 0.12)',
    // The background colors used to style the surfaces.
    // Consistency between these values is important.
    background: {
      paper: common$1.white,
      default: common$1.white
    },
    // The colors used to style the action elements.
    action: {
      // The color of an active action like an icon button.
      active: 'rgba(0, 0, 0, 0.54)',
      // The color of an hovered action.
      hover: 'rgba(0, 0, 0, 0.04)',
      hoverOpacity: 0.04,
      // The color of a selected action.
      selected: 'rgba(0, 0, 0, 0.08)',
      selectedOpacity: 0.08,
      // The color of a disabled action.
      disabled: 'rgba(0, 0, 0, 0.26)',
      // The background color of a disabled action.
      disabledBackground: 'rgba(0, 0, 0, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(0, 0, 0, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    }
  };
  const dark = {
    text: {
      primary: common$1.white,
      secondary: 'rgba(255, 255, 255, 0.7)',
      disabled: 'rgba(255, 255, 255, 0.5)',
      icon: 'rgba(255, 255, 255, 0.5)'
    },
    divider: 'rgba(255, 255, 255, 0.12)',
    background: {
      paper: '#121212',
      default: '#121212'
    },
    action: {
      active: common$1.white,
      hover: 'rgba(255, 255, 255, 0.08)',
      hoverOpacity: 0.08,
      selected: 'rgba(255, 255, 255, 0.16)',
      selectedOpacity: 0.16,
      disabled: 'rgba(255, 255, 255, 0.3)',
      disabledBackground: 'rgba(255, 255, 255, 0.12)',
      disabledOpacity: 0.38,
      focus: 'rgba(255, 255, 255, 0.12)',
      focusOpacity: 0.12,
      activatedOpacity: 0.24
    }
  };

  function addLightOrDark(intent, direction, shade, tonalOffset) {
    const tonalOffsetLight = tonalOffset.light || tonalOffset;
    const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;

    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === 'light') {
        intent.light = lighten(intent.main, tonalOffsetLight);
      } else if (direction === 'dark') {
        intent.dark = darken(intent.main, tonalOffsetDark);
      }
    }
  }

  function getDefaultPrimary(mode = 'light') {
    if (mode === 'dark') {
      return {
        main: blue$1[200],
        light: blue$1[50],
        dark: blue$1[400]
      };
    }

    return {
      main: blue$1[700],
      light: blue$1[400],
      dark: blue$1[800]
    };
  }

  function getDefaultSecondary(mode = 'light') {
    if (mode === 'dark') {
      return {
        main: purple$1[200],
        light: purple$1[50],
        dark: purple$1[400]
      };
    }

    return {
      main: purple$1[500],
      light: purple$1[300],
      dark: purple$1[700]
    };
  }

  function getDefaultError(mode = 'light') {
    if (mode === 'dark') {
      return {
        main: red$1[500],
        light: red$1[300],
        dark: red$1[700]
      };
    }

    return {
      main: red$1[700],
      light: red$1[400],
      dark: red$1[800]
    };
  }

  function getDefaultInfo(mode = 'light') {
    if (mode === 'dark') {
      return {
        main: lightBlue$1[400],
        light: lightBlue$1[300],
        dark: lightBlue$1[700]
      };
    }

    return {
      main: lightBlue$1[700],
      light: lightBlue$1[500],
      dark: lightBlue$1[900]
    };
  }

  function getDefaultSuccess(mode = 'light') {
    if (mode === 'dark') {
      return {
        main: green$1[400],
        light: green$1[300],
        dark: green$1[700]
      };
    }

    return {
      main: green$1[800],
      light: green$1[500],
      dark: green$1[900]
    };
  }

  function getDefaultWarning(mode = 'light') {
    if (mode === 'dark') {
      return {
        main: orange$1[400],
        light: orange$1[300],
        dark: orange$1[700]
      };
    }

    return {
      main: '#ed6c02',
      // closest to orange[800] that pass 3:1.
      light: orange$1[500],
      dark: orange$1[900]
    };
  }

  function createPalette(palette) {
    const {
      mode = 'light',
      contrastThreshold = 3,
      tonalOffset = 0.2
    } = palette,
          other = _objectWithoutPropertiesLoose$2(palette, _excluded$j);

    const primary = palette.primary || getDefaultPrimary(mode);
    const secondary = palette.secondary || getDefaultSecondary(mode);
    const error = palette.error || getDefaultError(mode);
    const info = palette.info || getDefaultInfo(mode);
    const success = palette.success || getDefaultSuccess(mode);
    const warning = palette.warning || getDefaultWarning(mode); // Use the same logic as
    // Bootstrap: https://github.com/twbs/bootstrap/blob/1d6e3710dd447de1a200f29e8fa521f8a0908f70/scss/_functions.scss#L59
    // and material-components-web https://github.com/material-components/material-components-web/blob/ac46b8863c4dab9fc22c4c662dc6bd1b65dd652f/packages/mdc-theme/_functions.scss#L54

    function getContrastText(background) {
      const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;

      return contrastText;
    }

    const augmentColor = ({
      color,
      name,
      mainShade = 500,
      lightShade = 300,
      darkShade = 700
    }) => {
      color = _extends$4({}, color);

      if (!color.main && color[mainShade]) {
        color.main = color[mainShade];
      }

      if (!color.hasOwnProperty('main')) {
        throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : '', mainShade));
      }

      if (typeof color.main !== 'string') {
        throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : '', JSON.stringify(color.main)));
      }

      addLightOrDark(color, 'light', lightShade, tonalOffset);
      addLightOrDark(color, 'dark', darkShade, tonalOffset);

      if (!color.contrastText) {
        color.contrastText = getContrastText(color.main);
      }

      return color;
    };

    const modes = {
      dark,
      light
    };

    const paletteOutput = deepmerge(_extends$4({
      // A collection of common colors.
      common: common$1,
      // The palette mode, can be light or dark.
      mode,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor({
        color: primary,
        name: 'primary'
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor({
        color: secondary,
        name: 'secondary',
        mainShade: 'A400',
        lightShade: 'A200',
        darkShade: 'A700'
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor({
        color: error,
        name: 'error'
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: augmentColor({
        color: warning,
        name: 'warning'
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: augmentColor({
        color: info,
        name: 'info'
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: augmentColor({
        color: success,
        name: 'success'
      }),
      // The grey colors.
      grey: grey$1,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText,
      // Generate a rich color object.
      augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset
    }, modes[mode]), other);
    return paletteOutput;
  }

  const _excluded$i = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];

  function round$1(value) {
    return Math.round(value * 1e5) / 1e5;
  }

  const caseAllCaps = {
    textTransform: 'uppercase'
  };
  const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  /**
   * @see @link{https://material.io/design/typography/the-type-system.html}
   * @see @link{https://material.io/design/typography/understanding-typography.html}
   */

  function createTypography(palette, typography) {
    const _ref = typeof typography === 'function' ? typography(palette) : typography,
          {
      fontFamily = defaultFontFamily,
      // The default font size of the Material Specification.
      fontSize = 14,
      // px
      fontWeightLight = 300,
      fontWeightRegular = 400,
      fontWeightMedium = 500,
      fontWeightBold = 700,
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      htmlFontSize = 16,
      // Apply the CSS properties to all the variants.
      allVariants,
      pxToRem: pxToRem2
    } = _ref,
          other = _objectWithoutPropertiesLoose$2(_ref, _excluded$i);

    const coef = fontSize / 14;

    const pxToRem = pxToRem2 || (size => `${size / htmlFontSize * coef}rem`);

    const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$4({
      fontFamily,
      fontWeight,
      fontSize: pxToRem(size),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight
    }, fontFamily === defaultFontFamily ? {
      letterSpacing: `${round$1(letterSpacing / size)}em`
    } : {}, casing, allVariants);

    const variants = {
      h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps)
    };
    return deepmerge(_extends$4({
      htmlFontSize,
      pxToRem,
      fontFamily,
      fontSize,
      fontWeightLight,
      fontWeightRegular,
      fontWeightMedium,
      fontWeightBold
    }, variants), other, {
      clone: false // No need to clone deep

    });
  }

  const shadowKeyUmbraOpacity = 0.2;
  const shadowKeyPenumbraOpacity = 0.14;
  const shadowAmbientShadowOpacity = 0.12;

  function createShadow(...px) {
    return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(',');
  } // Values from https://github.com/material-components/material-components-web/blob/be8747f94574669cb5e7add1a7c54fa41a89cec7/packages/mdc-elevation/_variables.scss


  const shadows = ['none', createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  var shadows$1 = shadows;

  const _excluded$h = ["duration", "easing", "delay"]; // Follow https://material.google.com/motion/duration-easing.html#duration-easing-natural-easing-curves
  // to learn the context in which each easing should be used.

  const easing = {
    // This is the most common easing curve.
    easeInOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: 'cubic-bezier(0.0, 0, 0.2, 1)',
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: 'cubic-bezier(0.4, 0, 1, 1)',
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: 'cubic-bezier(0.4, 0, 0.6, 1)'
  }; // Follow https://material.io/guidelines/motion/duration-easing.html#duration-easing-common-durations
  // to learn when use what timing

  const duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };

  function formatMs(milliseconds) {
    return `${Math.round(milliseconds)}ms`;
  }

  function getAutoHeightDuration(height) {
    if (!height) {
      return 0;
    }

    const constant = height / 36; // https://www.wolframalpha.com/input/?i=(4+%2B+15+*+(x+%2F+36+)+**+0.25+%2B+(x+%2F+36)+%2F+5)+*+10

    return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
  }

  function createTransitions(inputTransitions) {
    const mergedEasing = _extends$4({}, easing, inputTransitions.easing);

    const mergedDuration = _extends$4({}, duration, inputTransitions.duration);

    const create = (props = ['all'], options = {}) => {
      const {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0
      } = options;
            _objectWithoutPropertiesLoose$2(options, _excluded$h);

      return (Array.isArray(props) ? props : [props]).map(animatedProp => `${animatedProp} ${typeof durationOption === 'string' ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === 'string' ? delay : formatMs(delay)}`).join(',');
    };

    return _extends$4({
      getAutoHeightDuration,
      create
    }, inputTransitions, {
      easing: mergedEasing,
      duration: mergedDuration
    });
  }

  // We need to centralize the zIndex definitions as they work
  // like global values in the browser.
  const zIndex = {
    mobileStepper: 1000,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  var zIndex$1 = zIndex;

  const _excluded$g = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];

  function createTheme(options = {}, ...args) {
    const {
      mixins: mixinsInput = {},
      palette: paletteInput = {},
      transitions: transitionsInput = {},
      typography: typographyInput = {}
    } = options,
          other = _objectWithoutPropertiesLoose$2(options, _excluded$g);

    const palette = createPalette(paletteInput);
    const systemTheme = createTheme$1(options);
    let muiTheme = deepmerge(systemTheme, {
      mixins: createMixins(systemTheme.breakpoints, systemTheme.spacing, mixinsInput),
      palette,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: shadows$1.slice(),
      typography: createTypography(palette, typographyInput),
      transitions: createTransitions(transitionsInput),
      zIndex: _extends$4({}, zIndex$1)
    });
    muiTheme = deepmerge(muiTheme, other);
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);

    return muiTheme;
  }

  const defaultTheme$1 = createTheme();
  var defaultTheme$2 = defaultTheme$1;

  function useTheme() {
    const theme = useTheme$1(defaultTheme$2);

    return theme;
  }

  function useThemeProps({
    props,
    name
  }) {
    return useThemeProps$1({
      props,
      name,
      defaultTheme: defaultTheme$2
    });
  }

  const rootShouldForwardProp = prop => shouldForwardProp(prop) && prop !== 'classes';
  const styled = createStyled({
    defaultTheme: defaultTheme$2,
    rootShouldForwardProp
  });
  var styled$1 = styled;

  function getSvgIconUtilityClass(slot) {
    return generateUtilityClass('MuiSvgIcon', slot);
  }
  generateUtilityClasses('MuiSvgIcon', ['root', 'colorPrimary', 'colorSecondary', 'colorAction', 'colorError', 'colorDisabled', 'fontSizeInherit', 'fontSizeSmall', 'fontSizeMedium', 'fontSizeLarge']);

  const _excluded$f = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];

  const useUtilityClasses$9 = ownerState => {
    const {
      color,
      fontSize,
      classes
    } = ownerState;
    const slots = {
      root: ['root', color !== 'inherit' && `color${capitalize(color)}`, `fontSize${capitalize(fontSize)}`]
    };
    return composeClasses(slots, getSvgIconUtilityClass, classes);
  };

  const SvgIconRoot = styled$1('svg', {
    name: 'MuiSvgIcon',
    slot: 'Root',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.root, ownerState.color !== 'inherit' && styles[`color${capitalize(ownerState.color)}`], styles[`fontSize${capitalize(ownerState.fontSize)}`]];
    }
  })(({
    theme,
    ownerState
  }) => {
    var _theme$palette$ownerS, _theme$palette$ownerS2;

    return {
      userSelect: 'none',
      width: '1em',
      height: '1em',
      display: 'inline-block',
      fill: 'currentColor',
      flexShrink: 0,
      transition: theme.transitions.create('fill', {
        duration: theme.transitions.duration.shorter
      }),
      fontSize: {
        inherit: 'inherit',
        small: theme.typography.pxToRem(20),
        medium: theme.typography.pxToRem(24),
        large: theme.typography.pxToRem(35)
      }[ownerState.fontSize],
      // TODO v5 deprecate, v6 remove for sx
      color: (_theme$palette$ownerS = (_theme$palette$ownerS2 = theme.palette[ownerState.color]) == null ? void 0 : _theme$palette$ownerS2.main) != null ? _theme$palette$ownerS : {
        action: theme.palette.action.active,
        disabled: theme.palette.action.disabled,
        inherit: undefined
      }[ownerState.color]
    };
  });
  const SvgIcon = /*#__PURE__*/react.exports.forwardRef(function SvgIcon(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiSvgIcon'
    });

    const {
      children,
      className,
      color = 'inherit',
      component = 'svg',
      fontSize = 'medium',
      htmlColor,
      inheritViewBox = false,
      titleAccess,
      viewBox = '0 0 24 24'
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$f);

    const ownerState = _extends$4({}, props, {
      color,
      component,
      fontSize,
      inheritViewBox,
      viewBox
    });

    const more = {};

    if (!inheritViewBox) {
      more.viewBox = viewBox;
    }

    const classes = useUtilityClasses$9(ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsxs(SvgIconRoot, _extends$4({
      as: component,
      className: clsx(classes.root, className),
      ownerState: ownerState,
      focusable: "false",
      color: htmlColor,
      "aria-hidden": titleAccess ? undefined : true,
      role: titleAccess ? 'img' : undefined,
      ref: ref
    }, more, other, {
      children: [children, titleAccess ? /*#__PURE__*/jsxRuntime.exports.jsx("title", {
        children: titleAccess
      }) : null]
    }));
  });
  SvgIcon.muiName = 'SvgIcon';
  var SvgIcon$1 = SvgIcon;

  function createSvgIcon$1(path, displayName) {
    const Component = (props, ref) => /*#__PURE__*/jsxRuntime.exports.jsx(SvgIcon$1, _extends$4({
      "data-testid": `${displayName}Icon`,
      ref: ref
    }, props, {
      children: path
    }));

    Component.muiName = SvgIcon$1.muiName;
    return /*#__PURE__*/react.exports.memo( /*#__PURE__*/react.exports.forwardRef(Component));
  }

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    capitalize: capitalize,
    createChainedFunction: createChainedFunction,
    createSvgIcon: createSvgIcon$1,
    debounce: debounce$1,
    deprecatedPropType: deprecatedPropType,
    isMuiElement: isMuiElement,
    ownerDocument: ownerDocument,
    ownerWindow: ownerWindow,
    requirePropFactory: requirePropFactory,
    setRef: setRef,
    unstable_useEnhancedEffect: useEnhancedEffect$1,
    unstable_useId: useId,
    unsupportedProp: unsupportedProp,
    useControlled: useControlled,
    useEventCallback: useEventCallback,
    useForkRef: useForkRef,
    useIsFocusVisible: useIsFocusVisible,
    unstable_ClassNameGenerator: ClassNameGenerator$1
  });

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }

  var config = {
    disabled: false
  };

  var TransitionGroupContext = /*#__PURE__*/React.createContext(null);

  var UNMOUNTED = 'unmounted';
  var EXITED = 'exited';
  var ENTERING = 'entering';
  var ENTERED = 'entered';
  var EXITING = 'exiting';
  /**
   * The Transition component lets you describe a transition from one component
   * state to another _over time_ with a simple declarative API. Most commonly
   * it's used to animate the mounting and unmounting of a component, but can also
   * be used to describe in-place transition states as well.
   *
   * ---
   *
   * **Note**: `Transition` is a platform-agnostic base component. If you're using
   * transitions in CSS, you'll probably want to use
   * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
   * instead. It inherits all the features of `Transition`, but contains
   * additional features necessary to play nice with CSS transitions (hence the
   * name of the component).
   *
   * ---
   *
   * By default the `Transition` component does not alter the behavior of the
   * component it renders, it only tracks "enter" and "exit" states for the
   * components. It's up to you to give meaning and effect to those states. For
   * example we can add styles to a component when it enters or exits:
   *
   * ```jsx
   * import { Transition } from 'react-transition-group';
   *
   * const duration = 300;
   *
   * const defaultStyle = {
   *   transition: `opacity ${duration}ms ease-in-out`,
   *   opacity: 0,
   * }
   *
   * const transitionStyles = {
   *   entering: { opacity: 1 },
   *   entered:  { opacity: 1 },
   *   exiting:  { opacity: 0 },
   *   exited:  { opacity: 0 },
   * };
   *
   * const Fade = ({ in: inProp }) => (
   *   <Transition in={inProp} timeout={duration}>
   *     {state => (
   *       <div style={{
   *         ...defaultStyle,
   *         ...transitionStyles[state]
   *       }}>
   *         I'm a fade Transition!
   *       </div>
   *     )}
   *   </Transition>
   * );
   * ```
   *
   * There are 4 main states a Transition can be in:
   *  - `'entering'`
   *  - `'entered'`
   *  - `'exiting'`
   *  - `'exited'`
   *
   * Transition state is toggled via the `in` prop. When `true` the component
   * begins the "Enter" stage. During this stage, the component will shift from
   * its current transition state, to `'entering'` for the duration of the
   * transition and then to the `'entered'` stage once it's complete. Let's take
   * the following example (we'll use the
   * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
   *
   * ```jsx
   * function App() {
   *   const [inProp, setInProp] = useState(false);
   *   return (
   *     <div>
   *       <Transition in={inProp} timeout={500}>
   *         {state => (
   *           // ...
   *         )}
   *       </Transition>
   *       <button onClick={() => setInProp(true)}>
   *         Click to Enter
   *       </button>
   *     </div>
   *   );
   * }
   * ```
   *
   * When the button is clicked the component will shift to the `'entering'` state
   * and stay there for 500ms (the value of `timeout`) before it finally switches
   * to `'entered'`.
   *
   * When `in` is `false` the same thing happens except the state moves from
   * `'exiting'` to `'exited'`.
   */

  var Transition = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(Transition, _React$Component);

    function Transition(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;

      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }

      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }

    Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;

      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }

      return null;
    } // getSnapshotBeforeUpdate(prevProps) {
    //   let nextStatus = null
    //   if (prevProps !== this.props) {
    //     const { status } = this.state
    //     if (this.props.in) {
    //       if (status !== ENTERING && status !== ENTERED) {
    //         nextStatus = ENTERING
    //       }
    //     } else {
    //       if (status === ENTERING || status === ENTERED) {
    //         nextStatus = EXITING
    //       }
    //     }
    //   }
    //   return { nextStatus }
    // }
    ;

    var _proto = Transition.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };

    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;

      if (prevProps !== this.props) {
        var status = this.state.status;

        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }

      this.updateStatus(false, nextStatus);
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };

    _proto.getTimeouts = function getTimeouts() {
      var timeout = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout;

      if (timeout != null && typeof timeout !== 'number') {
        exit = timeout.exit;
        enter = timeout.enter; // TODO: remove fallback for next major

        appear = timeout.appear !== undefined ? timeout.appear : enter;
      }

      return {
        exit: exit,
        enter: enter,
        appear: appear
      };
    };

    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }

      if (nextStatus !== null) {
        // nextStatus will always be ENTERING or EXITING.
        this.cancelNextCallback();

        if (nextStatus === ENTERING) {
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };

    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;

      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;

      var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing],
          maybeNode = _ref2[0],
          maybeAppearing = _ref2[1];

      var timeouts = this.getTimeouts();
      var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
      // if we are mounting and running this it means appear _must_ be set

      if (!mounting && !enter || config.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }

      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function () {
        _this2.props.onEntering(maybeNode, maybeAppearing);

        _this2.onTransitionEnd(enterTimeout, function () {
          _this2.safeSetState({
            status: ENTERED
          }, function () {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };

    _proto.performExit = function performExit() {
      var _this3 = this;

      var exit = this.props.exit;
      var timeouts = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? undefined : ReactDOM.findDOMNode(this); // no exit animation skip right to EXITED

      if (!exit || config.disabled) {
        this.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
        return;
      }

      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function () {
        _this3.props.onExiting(maybeNode);

        _this3.onTransitionEnd(timeouts.exit, function () {
          _this3.safeSetState({
            status: EXITED
          }, function () {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };

    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };

    _proto.safeSetState = function safeSetState(nextState, callback) {
      // This shouldn't be necessary, but there are weird race conditions with
      // setState callbacks and unmounting in testing, so always make sure that
      // we can cancel any pending setState callbacks after we unmount.
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };

    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;

      var active = true;

      this.nextCallback = function (event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };

      this.nextCallback.cancel = function () {
        active = false;
      };

      return this.nextCallback;
    };

    _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
      this.setNextCallback(handler);
      var node = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

      if (!node || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }

      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
            maybeNode = _ref3[0],
            maybeNextCallback = _ref3[1];

        this.props.addEndListener(maybeNode, maybeNextCallback);
      }

      if (timeout != null) {
        setTimeout(this.nextCallback, timeout);
      }
    };

    _proto.render = function render() {
      var status = this.state.status;

      if (status === UNMOUNTED) {
        return null;
      }

      var _this$props = this.props,
          children = _this$props.children;
          _this$props.in;
          _this$props.mountOnEnter;
          _this$props.unmountOnExit;
          _this$props.appear;
          _this$props.enter;
          _this$props.exit;
          _this$props.timeout;
          _this$props.addEndListener;
          _this$props.onEnter;
          _this$props.onEntering;
          _this$props.onEntered;
          _this$props.onExit;
          _this$props.onExiting;
          _this$props.onExited;
          _this$props.nodeRef;
          var childProps = _objectWithoutPropertiesLoose$3(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

      return (
        /*#__PURE__*/
        // allows for nested Transitions
        React.createElement(TransitionGroupContext.Provider, {
          value: null
        }, typeof children === 'function' ? children(status, childProps) : /*#__PURE__*/React.cloneElement(React.Children.only(children), childProps))
      );
    };

    return Transition;
  }(React.Component);

  Transition.contextType = TransitionGroupContext;

  // Name the function so it is clearer in the documentation
  function noop() {}

  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var Transition$1 = Transition;

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  /**
   * Given `this.props.children`, return an object mapping key to child.
   *
   * @param {*} children `this.props.children`
   * @return {object} Mapping of key to child
   */

  function getChildMapping(children, mapFn) {
    var mapper = function mapper(child) {
      return mapFn && /*#__PURE__*/react.exports.isValidElement(child) ? mapFn(child) : child;
    };

    var result = Object.create(null);
    if (children) react.exports.Children.map(children, function (c) {
      return c;
    }).forEach(function (child) {
      // run the map function here instead so that the key is the computed one
      result[child.key] = mapper(child);
    });
    return result;
  }
  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */

  function mergeChildMappings(prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      return key in next ? next[key] : prev[key];
    } // For each key of `next`, the list of keys to insert before that key in
    // the combined list


    var nextKeysPending = Object.create(null);
    var pendingKeys = [];

    for (var prevKey in prev) {
      if (prevKey in next) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};

    for (var nextKey in next) {
      if (nextKeysPending[nextKey]) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }

      childMapping[nextKey] = getValueForKey(nextKey);
    } // Finally, add the keys which didn't appear before any key in `next`


    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }

  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }

  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function (child) {
      return /*#__PURE__*/react.exports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, 'appear', props),
        enter: getProp(child, 'enter', props),
        exit: getProp(child, 'exit', props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function (key) {
      var child = children[key];
      if (! /*#__PURE__*/react.exports.isValidElement(child)) return;
      var hasPrev = (key in prevChildMapping);
      var hasNext = (key in nextChildMapping);
      var prevChild = prevChildMapping[key];
      var isLeaving = /*#__PURE__*/react.exports.isValidElement(prevChild) && !prevChild.props.in; // item is new (entering)

      if (hasNext && (!hasPrev || isLeaving)) {
        // console.log('entering', key)
        children[key] = /*#__PURE__*/react.exports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        // item is old (exiting)
        // console.log('leaving', key)
        children[key] = /*#__PURE__*/react.exports.cloneElement(child, {
          in: false
        });
      } else if (hasNext && hasPrev && /*#__PURE__*/react.exports.isValidElement(prevChild)) {
        // item hasn't changed transition states
        // copy over the last transition props;
        // console.log('unchanged', key)
        children[key] = /*#__PURE__*/react.exports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, 'exit', nextProps),
          enter: getProp(child, 'enter', nextProps)
        });
      }
    });
    return children;
  }

  var values = Object.values || function (obj) {
    return Object.keys(obj).map(function (k) {
      return obj[k];
    });
  };

  var defaultProps = {
    component: 'div',
    childFactory: function childFactory(child) {
      return child;
    }
  };
  /**
   * The `<TransitionGroup>` component manages a set of transition components
   * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
   * components, `<TransitionGroup>` is a state machine for managing the mounting
   * and unmounting of components over time.
   *
   * Consider the example below. As items are removed or added to the TodoList the
   * `in` prop is toggled automatically by the `<TransitionGroup>`.
   *
   * Note that `<TransitionGroup>`  does not define any animation behavior!
   * Exactly _how_ a list item animates is up to the individual transition
   * component. This means you can mix and match animations across different list
   * items.
   */

  var TransitionGroup = /*#__PURE__*/function (_React$Component) {
    _inheritsLoose(TransitionGroup, _React$Component);

    function TransitionGroup(props, context) {
      var _this;

      _this = _React$Component.call(this, props, context) || this;

      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this)); // Initial children should all be entering, dependent on appear


      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited: handleExited,
        firstRender: true
      };
      return _this;
    }

    var _proto = TransitionGroup.prototype;

    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };

    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };

    TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children,
          handleExited = _ref.handleExited,
          firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    } // node is `undefined` when user provided `nodeRef` prop
    ;

    _proto.handleExited = function handleExited(child, node) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping) return;

      if (child.props.onExited) {
        child.props.onExited(node);
      }

      if (this.mounted) {
        this.setState(function (state) {
          var children = _extends$5({}, state.children);

          delete children[child.key];
          return {
            children: children
          };
        });
      }
    };

    _proto.render = function render() {
      var _this$props = this.props,
          Component = _this$props.component,
          childFactory = _this$props.childFactory,
          props = _objectWithoutPropertiesLoose$3(_this$props, ["component", "childFactory"]);

      var contextValue = this.state.contextValue;
      var children = values(this.state.children).map(childFactory);
      delete props.appear;
      delete props.enter;
      delete props.exit;

      if (Component === null) {
        return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, children);
      }

      return /*#__PURE__*/React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, /*#__PURE__*/React.createElement(Component, props, children));
    };

    return TransitionGroup;
  }(React.Component);

  TransitionGroup.defaultProps = defaultProps;
  var TransitionGroup$1 = TransitionGroup;

  const reflow = node => node.scrollTop;
  function getTransitionProps(props, options) {
    var _style$transitionDura, _style$transitionTimi;

    const {
      timeout,
      easing,
      style = {}
    } = props;
    return {
      duration: (_style$transitionDura = style.transitionDuration) != null ? _style$transitionDura : typeof timeout === 'number' ? timeout : timeout[options.mode] || 0,
      easing: (_style$transitionTimi = style.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing === 'object' ? easing[options.mode] : easing,
      delay: style.transitionDelay
    };
  }

  function getPaperUtilityClass(slot) {
    return generateUtilityClass('MuiPaper', slot);
  }
  generateUtilityClasses('MuiPaper', ['root', 'rounded', 'outlined', 'elevation', 'elevation0', 'elevation1', 'elevation2', 'elevation3', 'elevation4', 'elevation5', 'elevation6', 'elevation7', 'elevation8', 'elevation9', 'elevation10', 'elevation11', 'elevation12', 'elevation13', 'elevation14', 'elevation15', 'elevation16', 'elevation17', 'elevation18', 'elevation19', 'elevation20', 'elevation21', 'elevation22', 'elevation23', 'elevation24']);

  const _excluded$e = ["className", "component", "elevation", "square", "variant"];

  const getOverlayAlpha = elevation => {
    let alphaValue;

    if (elevation < 1) {
      alphaValue = 5.11916 * elevation ** 2;
    } else {
      alphaValue = 4.5 * Math.log(elevation + 1) + 2;
    }

    return (alphaValue / 100).toFixed(2);
  };

  const useUtilityClasses$8 = ownerState => {
    const {
      square,
      elevation,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ['root', variant, !square && 'rounded', variant === 'elevation' && `elevation${elevation}`]
    };
    return composeClasses(slots, getPaperUtilityClass, classes);
  };

  const PaperRoot = styled$1('div', {
    name: 'MuiPaper',
    slot: 'Root',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.root, styles[ownerState.variant], !ownerState.square && styles.rounded, ownerState.variant === 'elevation' && styles[`elevation${ownerState.elevation}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends$4({
    backgroundColor: theme.palette.background.paper,
    color: theme.palette.text.primary,
    transition: theme.transitions.create('box-shadow')
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === 'outlined' && {
    border: `1px solid ${theme.palette.divider}`
  }, ownerState.variant === 'elevation' && _extends$4({
    boxShadow: theme.shadows[ownerState.elevation]
  }, theme.palette.mode === 'dark' && {
    backgroundImage: `linear-gradient(${alpha('#fff', getOverlayAlpha(ownerState.elevation))}, ${alpha('#fff', getOverlayAlpha(ownerState.elevation))})`
  })));
  const Paper = /*#__PURE__*/react.exports.forwardRef(function Paper(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiPaper'
    });

    const {
      className,
      component = 'div',
      elevation = 1,
      square = false,
      variant = 'elevation'
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$e);

    const ownerState = _extends$4({}, props, {
      component,
      elevation,
      square,
      variant
    });

    const classes = useUtilityClasses$8(ownerState);

    return /*#__PURE__*/jsxRuntime.exports.jsx(PaperRoot, _extends$4({
      as: component,
      ownerState: ownerState,
      className: clsx(classes.root, className),
      ref: ref
    }, other));
  });
  var Paper$1 = Paper;

  function Ripple(props) {
    const {
      className,
      classes,
      pulsate = false,
      rippleX,
      rippleY,
      rippleSize,
      in: inProp,
      onExited,
      timeout
    } = props;
    const [leaving, setLeaving] = react.exports.useState(false);
    const rippleClassName = clsx(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    const rippleStyles = {
      width: rippleSize,
      height: rippleSize,
      top: -(rippleSize / 2) + rippleY,
      left: -(rippleSize / 2) + rippleX
    };
    const childClassName = clsx(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);

    if (!inProp && !leaving) {
      setLeaving(true);
    }

    react.exports.useEffect(() => {
      if (!inProp && onExited != null) {
        // react-transition-group#onExited
        const timeoutId = setTimeout(onExited, timeout);
        return () => {
          clearTimeout(timeoutId);
        };
      }

      return undefined;
    }, [onExited, inProp, timeout]);
    return /*#__PURE__*/jsxRuntime.exports.jsx("span", {
      className: rippleClassName,
      style: rippleStyles,
      children: /*#__PURE__*/jsxRuntime.exports.jsx("span", {
        className: childClassName
      })
    });
  }

  const touchRippleClasses = generateUtilityClasses('MuiTouchRipple', ['root', 'ripple', 'rippleVisible', 'ripplePulsate', 'child', 'childLeaving', 'childPulsate']);
  var touchRippleClasses$1 = touchRippleClasses;

  const _excluded$d = ["center", "classes", "className"];

  let _ = t => t,
      _t,
      _t2,
      _t3,
      _t4;
  const DURATION = 550;
  const DELAY_RIPPLE = 80;
  const enterKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
  const exitKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
  const pulsateKeyframe = keyframes(_t3 || (_t3 = _`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
  const TouchRippleRoot = styled$1('span', {
    name: 'MuiTouchRipple',
    slot: 'Root',
    skipSx: true
  })({
    overflow: 'hidden',
    pointerEvents: 'none',
    position: 'absolute',
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: 'inherit'
  }); // This `styled()` function invokes keyframes. `styled-components` only supports keyframes
  // in string templates. Do not convert these styles in JS object as it will break.

  const TouchRippleRipple = styled$1(Ripple, {
    name: 'MuiTouchRipple',
    slot: 'Ripple'
  })(_t4 || (_t4 = _`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
    theme
  }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
    theme
  }) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
    theme
  }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
    theme
  }) => theme.transitions.easing.easeInOut);
  /**
   * @ignore - internal component.
   *
   * TODO v5: Make private
   */

  const TouchRipple = /*#__PURE__*/react.exports.forwardRef(function TouchRipple(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiTouchRipple'
    });

    const {
      center: centerProp = false,
      classes = {},
      className
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$d);

    const [ripples, setRipples] = react.exports.useState([]);
    const nextKey = react.exports.useRef(0);
    const rippleCallback = react.exports.useRef(null);
    react.exports.useEffect(() => {
      if (rippleCallback.current) {
        rippleCallback.current();
        rippleCallback.current = null;
      }
    }, [ripples]); // Used to filter out mouse emulated events on mobile.

    const ignoringMouseDown = react.exports.useRef(false); // We use a timer in order to only show the ripples for touch "click" like events.
    // We don't want to display the ripple for touch scroll events.

    const startTimer = react.exports.useRef(null); // This is the hook called once the previous timeout is ready.

    const startTimerCommit = react.exports.useRef(null);
    const container = react.exports.useRef(null);
    react.exports.useEffect(() => {
      return () => {
        clearTimeout(startTimer.current);
      };
    }, []);
    const startCommit = react.exports.useCallback(params => {
      const {
        pulsate,
        rippleX,
        rippleY,
        rippleSize,
        cb
      } = params;
      setRipples(oldRipples => [...oldRipples, /*#__PURE__*/jsxRuntime.exports.jsx(TouchRippleRipple, {
        classes: {
          ripple: clsx(classes.ripple, touchRippleClasses$1.ripple),
          rippleVisible: clsx(classes.rippleVisible, touchRippleClasses$1.rippleVisible),
          ripplePulsate: clsx(classes.ripplePulsate, touchRippleClasses$1.ripplePulsate),
          child: clsx(classes.child, touchRippleClasses$1.child),
          childLeaving: clsx(classes.childLeaving, touchRippleClasses$1.childLeaving),
          childPulsate: clsx(classes.childPulsate, touchRippleClasses$1.childPulsate)
        },
        timeout: DURATION,
        pulsate: pulsate,
        rippleX: rippleX,
        rippleY: rippleY,
        rippleSize: rippleSize
      }, nextKey.current)]);
      nextKey.current += 1;
      rippleCallback.current = cb;
    }, [classes]);
    const start = react.exports.useCallback((event = {}, options = {}, cb) => {
      const {
        pulsate = false,
        center = centerProp || options.pulsate,
        fakeElement = false // For test purposes

      } = options;

      if (event.type === 'mousedown' && ignoringMouseDown.current) {
        ignoringMouseDown.current = false;
        return;
      }

      if (event.type === 'touchstart') {
        ignoringMouseDown.current = true;
      }

      const element = fakeElement ? null : container.current;
      const rect = element ? element.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      }; // Get the size of the ripple

      let rippleX;
      let rippleY;
      let rippleSize;

      if (center || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
        rippleX = Math.round(rect.width / 2);
        rippleY = Math.round(rect.height / 2);
      } else {
        const {
          clientX,
          clientY
        } = event.touches ? event.touches[0] : event;
        rippleX = Math.round(clientX - rect.left);
        rippleY = Math.round(clientY - rect.top);
      }

      if (center) {
        rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3); // For some reason the animation is broken on Mobile Chrome if the size is even.

        if (rippleSize % 2 === 0) {
          rippleSize += 1;
        }
      } else {
        const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
        const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
        rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
      } // Touche devices


      if (event.touches) {
        // check that this isn't another touchstart due to multitouch
        // otherwise we will only clear a single timer when unmounting while two
        // are running
        if (startTimerCommit.current === null) {
          // Prepare the ripple effect.
          startTimerCommit.current = () => {
            startCommit({
              pulsate,
              rippleX,
              rippleY,
              rippleSize,
              cb
            });
          }; // Delay the execution of the ripple effect.


          startTimer.current = setTimeout(() => {
            if (startTimerCommit.current) {
              startTimerCommit.current();
              startTimerCommit.current = null;
            }
          }, DELAY_RIPPLE); // We have to make a tradeoff with this value.
        }
      } else {
        startCommit({
          pulsate,
          rippleX,
          rippleY,
          rippleSize,
          cb
        });
      }
    }, [centerProp, startCommit]);
    const pulsate = react.exports.useCallback(() => {
      start({}, {
        pulsate: true
      });
    }, [start]);
    const stop = react.exports.useCallback((event, cb) => {
      clearTimeout(startTimer.current); // The touch interaction occurs too quickly.
      // We still want to show ripple effect.

      if (event.type === 'touchend' && startTimerCommit.current) {
        startTimerCommit.current();
        startTimerCommit.current = null;
        startTimer.current = setTimeout(() => {
          stop(event, cb);
        });
        return;
      }

      startTimerCommit.current = null;
      setRipples(oldRipples => {
        if (oldRipples.length > 0) {
          return oldRipples.slice(1);
        }

        return oldRipples;
      });
      rippleCallback.current = cb;
    }, []);
    react.exports.useImperativeHandle(ref, () => ({
      pulsate,
      start,
      stop
    }), [pulsate, start, stop]);
    return /*#__PURE__*/jsxRuntime.exports.jsx(TouchRippleRoot, _extends$4({
      className: clsx(classes.root, touchRippleClasses$1.root, className),
      ref: container
    }, other, {
      children: /*#__PURE__*/jsxRuntime.exports.jsx(TransitionGroup$1, {
        component: null,
        exit: true,
        children: ripples
      })
    }));
  });
  var TouchRipple$1 = TouchRipple;

  function getButtonBaseUtilityClass(slot) {
    return generateUtilityClass('MuiButtonBase', slot);
  }
  const buttonBaseClasses = generateUtilityClasses('MuiButtonBase', ['root', 'disabled', 'focusVisible']);
  var buttonBaseClasses$1 = buttonBaseClasses;

  const _excluded$c = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "type"];

  const useUtilityClasses$7 = ownerState => {
    const {
      disabled,
      focusVisible,
      focusVisibleClassName,
      classes
    } = ownerState;
    const slots = {
      root: ['root', disabled && 'disabled', focusVisible && 'focusVisible']
    };
    const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);

    if (focusVisible && focusVisibleClassName) {
      composedClasses.root += ` ${focusVisibleClassName}`;
    }

    return composedClasses;
  };

  const ButtonBaseRoot = styled$1('button', {
    name: 'MuiButtonBase',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root
  })({
    display: 'inline-flex',
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    boxSizing: 'border-box',
    WebkitTapHighlightColor: 'transparent',
    backgroundColor: 'transparent',
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: 'pointer',
    userSelect: 'none',
    verticalAlign: 'middle',
    MozAppearance: 'none',
    // Reset
    WebkitAppearance: 'none',
    // Reset
    textDecoration: 'none',
    // So we take precedent over the style of a native <a /> element.
    color: 'inherit',
    '&::-moz-focus-inner': {
      borderStyle: 'none' // Remove Firefox dotted outline.

    },
    [`&.${buttonBaseClasses$1.disabled}`]: {
      pointerEvents: 'none',
      // Disable link interactions
      cursor: 'default'
    },
    '@media print': {
      colorAdjust: 'exact'
    }
  });
  /**
   * `ButtonBase` contains as few styles as possible.
   * It aims to be a simple building block for creating a button.
   * It contains a load of style reset and some focus/ripple logic.
   */

  const ButtonBase = /*#__PURE__*/react.exports.forwardRef(function ButtonBase(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiButtonBase'
    });

    const {
      action,
      centerRipple = false,
      children,
      className,
      component = 'button',
      disabled = false,
      disableRipple = false,
      disableTouchRipple = false,
      focusRipple = false,
      LinkComponent = 'a',
      onBlur,
      onClick,
      onContextMenu,
      onDragLeave,
      onFocus,
      onFocusVisible,
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseLeave,
      onMouseUp,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      tabIndex = 0,
      TouchRippleProps,
      type
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$c);

    const buttonRef = react.exports.useRef(null);
    const rippleRef = react.exports.useRef(null);
    const {
      isFocusVisibleRef,
      onFocus: handleFocusVisible,
      onBlur: handleBlurVisible,
      ref: focusVisibleRef
    } = useIsFocusVisible();
    const [focusVisible, setFocusVisible] = react.exports.useState(false);

    if (disabled && focusVisible) {
      setFocusVisible(false);
    }

    react.exports.useImperativeHandle(action, () => ({
      focusVisible: () => {
        setFocusVisible(true);
        buttonRef.current.focus();
      }
    }), []);
    react.exports.useEffect(() => {
      if (focusVisible && focusRipple && !disableRipple) {
        rippleRef.current.pulsate();
      }
    }, [disableRipple, focusRipple, focusVisible]);

    function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
      return useEventCallback(event => {
        if (eventCallback) {
          eventCallback(event);
        }

        const ignore = skipRippleAction;

        if (!ignore && rippleRef.current) {
          rippleRef.current[rippleAction](event);
        }

        return true;
      });
    }

    const handleMouseDown = useRippleHandler('start', onMouseDown);
    const handleContextMenu = useRippleHandler('stop', onContextMenu);
    const handleDragLeave = useRippleHandler('stop', onDragLeave);
    const handleMouseUp = useRippleHandler('stop', onMouseUp);
    const handleMouseLeave = useRippleHandler('stop', event => {
      if (focusVisible) {
        event.preventDefault();
      }

      if (onMouseLeave) {
        onMouseLeave(event);
      }
    });
    const handleTouchStart = useRippleHandler('start', onTouchStart);
    const handleTouchEnd = useRippleHandler('stop', onTouchEnd);
    const handleTouchMove = useRippleHandler('stop', onTouchMove);
    const handleBlur = useRippleHandler('stop', event => {
      handleBlurVisible(event);

      if (isFocusVisibleRef.current === false) {
        setFocusVisible(false);
      }

      if (onBlur) {
        onBlur(event);
      }
    }, false);
    const handleFocus = useEventCallback(event => {
      // Fix for https://github.com/facebook/react/issues/7769
      if (!buttonRef.current) {
        buttonRef.current = event.currentTarget;
      }

      handleFocusVisible(event);

      if (isFocusVisibleRef.current === true) {
        setFocusVisible(true);

        if (onFocusVisible) {
          onFocusVisible(event);
        }
      }

      if (onFocus) {
        onFocus(event);
      }
    });

    const isNonNativeButton = () => {
      const button = buttonRef.current;
      return component && component !== 'button' && !(button.tagName === 'A' && button.href);
    };
    /**
     * IE11 shim for https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/repeat
     */


    const keydownRef = react.exports.useRef(false);
    const handleKeyDown = useEventCallback(event => {
      // Check if key is already down to avoid repeats being counted as multiple activations
      if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === ' ') {
        keydownRef.current = true;
        rippleRef.current.stop(event, () => {
          rippleRef.current.start(event);
        });
      }

      if (event.target === event.currentTarget && isNonNativeButton() && event.key === ' ') {
        event.preventDefault();
      }

      if (onKeyDown) {
        onKeyDown(event);
      } // Keyboard accessibility for non interactive elements


      if (event.target === event.currentTarget && isNonNativeButton() && event.key === 'Enter' && !disabled) {
        event.preventDefault();

        if (onClick) {
          onClick(event);
        }
      }
    });
    const handleKeyUp = useEventCallback(event => {
      // calling preventDefault in keyUp on a <button> will not dispatch a click event if Space is pressed
      // https://codesandbox.io/s/button-keyup-preventdefault-dn7f0
      if (focusRipple && event.key === ' ' && rippleRef.current && focusVisible && !event.defaultPrevented) {
        keydownRef.current = false;
        rippleRef.current.stop(event, () => {
          rippleRef.current.pulsate(event);
        });
      }

      if (onKeyUp) {
        onKeyUp(event);
      } // Keyboard accessibility for non interactive elements


      if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === ' ' && !event.defaultPrevented) {
        onClick(event);
      }
    });
    let ComponentProp = component;

    if (ComponentProp === 'button' && (other.href || other.to)) {
      ComponentProp = LinkComponent;
    }

    const buttonProps = {};

    if (ComponentProp === 'button') {
      buttonProps.type = type === undefined ? 'button' : type;
      buttonProps.disabled = disabled;
    } else {
      if (!other.href && !other.to) {
        buttonProps.role = 'button';
      }

      if (disabled) {
        buttonProps['aria-disabled'] = disabled;
      }
    }

    const handleOwnRef = useForkRef(focusVisibleRef, buttonRef);
    const handleRef = useForkRef(ref, handleOwnRef);
    const [mountedState, setMountedState] = react.exports.useState(false);
    react.exports.useEffect(() => {
      setMountedState(true);
    }, []);
    const enableTouchRipple = mountedState && !disableRipple && !disabled;

    const ownerState = _extends$4({}, props, {
      centerRipple,
      component,
      disabled,
      disableRipple,
      disableTouchRipple,
      focusRipple,
      tabIndex,
      focusVisible
    });

    const classes = useUtilityClasses$7(ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsxs(ButtonBaseRoot, _extends$4({
      as: ComponentProp,
      className: clsx(classes.root, className),
      ownerState: ownerState,
      onBlur: handleBlur,
      onClick: onClick,
      onContextMenu: handleContextMenu,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      onMouseLeave: handleMouseLeave,
      onMouseUp: handleMouseUp,
      onDragLeave: handleDragLeave,
      onTouchEnd: handleTouchEnd,
      onTouchMove: handleTouchMove,
      onTouchStart: handleTouchStart,
      ref: handleRef,
      tabIndex: disabled ? -1 : tabIndex,
      type: type
    }, buttonProps, other, {
      children: [children, enableTouchRipple ?
      /*#__PURE__*/

      /* TouchRipple is only needed client-side, x2 boost on the server. */
      jsxRuntime.exports.jsx(TouchRipple$1, _extends$4({
        ref: rippleRef,
        center: centerRipple
      }, TouchRippleProps)) : null]
    }));
  });
  var ButtonBase$1 = ButtonBase;

  function getIconButtonUtilityClass(slot) {
    return generateUtilityClass('MuiIconButton', slot);
  }
  const iconButtonClasses = generateUtilityClasses('MuiIconButton', ['root', 'disabled', 'colorInherit', 'colorPrimary', 'colorSecondary', 'edgeStart', 'edgeEnd', 'sizeSmall', 'sizeMedium', 'sizeLarge']);
  var iconButtonClasses$1 = iconButtonClasses;

  const _excluded$b = ["edge", "children", "className", "color", "disabled", "disableFocusRipple", "size"];

  const useUtilityClasses$6 = ownerState => {
    const {
      classes,
      disabled,
      color,
      edge,
      size
    } = ownerState;
    const slots = {
      root: ['root', disabled && 'disabled', color !== 'default' && `color${capitalize(color)}`, edge && `edge${capitalize(edge)}`, `size${capitalize(size)}`]
    };
    return composeClasses(slots, getIconButtonUtilityClass, classes);
  };

  const IconButtonRoot = styled$1(ButtonBase$1, {
    name: 'MuiIconButton',
    slot: 'Root',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.root, ownerState.color !== 'default' && styles[`color${capitalize(ownerState.color)}`], ownerState.edge && styles[`edge${capitalize(ownerState.edge)}`], styles[`size${capitalize(ownerState.size)}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends$4({
    textAlign: 'center',
    flex: '0 0 auto',
    fontSize: theme.typography.pxToRem(24),
    padding: 8,
    borderRadius: '50%',
    overflow: 'visible',
    // Explicitly set the default value to solve a bug on IE11.
    color: theme.palette.action.active,
    transition: theme.transitions.create('background-color', {
      duration: theme.transitions.duration.shortest
    })
  }, !ownerState.disableRipple && {
    '&:hover': {
      backgroundColor: alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: 'transparent'
      }
    }
  }, ownerState.edge === 'start' && {
    marginLeft: ownerState.size === 'small' ? -3 : -12
  }, ownerState.edge === 'end' && {
    marginRight: ownerState.size === 'small' ? -3 : -12
  }), ({
    theme,
    ownerState
  }) => _extends$4({}, ownerState.color === 'inherit' && {
    color: 'inherit'
  }, ownerState.color !== 'inherit' && ownerState.color !== 'default' && _extends$4({
    color: theme.palette[ownerState.color].main
  }, !ownerState.disableRipple && {
    '&:hover': {
      backgroundColor: alpha(theme.palette[ownerState.color].main, theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: 'transparent'
      }
    }
  }), ownerState.size === 'small' && {
    padding: 5,
    fontSize: theme.typography.pxToRem(18)
  }, ownerState.size === 'large' && {
    padding: 12,
    fontSize: theme.typography.pxToRem(28)
  }, {
    [`&.${iconButtonClasses$1.disabled}`]: {
      backgroundColor: 'transparent',
      color: theme.palette.action.disabled
    }
  }));
  /**
   * Refer to the [Icons](/components/icons/) section of the documentation
   * regarding the available icon options.
   */

  const IconButton = /*#__PURE__*/react.exports.forwardRef(function IconButton(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiIconButton'
    });

    const {
      edge = false,
      children,
      className,
      color = 'default',
      disabled = false,
      disableFocusRipple = false,
      size = 'medium'
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$b);

    const ownerState = _extends$4({}, props, {
      edge,
      color,
      disabled,
      disableFocusRipple,
      size
    });

    const classes = useUtilityClasses$6(ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsx(IconButtonRoot, _extends$4({
      className: clsx(classes.root, className),
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled: disabled,
      ref: ref,
      ownerState: ownerState
    }, other, {
      children: children
    }));
  });
  var IconButton$1 = IconButton;

  function getTypographyUtilityClass(slot) {
    return generateUtilityClass('MuiTypography', slot);
  }
  generateUtilityClasses('MuiTypography', ['root', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'inherit', 'button', 'caption', 'overline', 'alignLeft', 'alignRight', 'alignCenter', 'alignJustify', 'noWrap', 'gutterBottom', 'paragraph']);

  const _excluded$a = ["align", "className", "component", "gutterBottom", "noWrap", "paragraph", "variant", "variantMapping"];

  const useUtilityClasses$5 = ownerState => {
    const {
      align,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ['root', variant, ownerState.align !== 'inherit' && `align${capitalize(align)}`, gutterBottom && 'gutterBottom', noWrap && 'noWrap', paragraph && 'paragraph']
    };
    return composeClasses(slots, getTypographyUtilityClass, classes);
  };

  const TypographyRoot = styled$1('span', {
    name: 'MuiTypography',
    slot: 'Root',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.root, ownerState.variant && styles[ownerState.variant], ownerState.align !== 'inherit' && styles[`align${capitalize(ownerState.align)}`], ownerState.noWrap && styles.noWrap, ownerState.gutterBottom && styles.gutterBottom, ownerState.paragraph && styles.paragraph];
    }
  })(({
    theme,
    ownerState
  }) => _extends$4({
    margin: 0
  }, ownerState.variant && theme.typography[ownerState.variant], ownerState.align !== 'inherit' && {
    textAlign: ownerState.align
  }, ownerState.noWrap && {
    overflow: 'hidden',
    textOverflow: 'ellipsis',
    whiteSpace: 'nowrap'
  }, ownerState.gutterBottom && {
    marginBottom: '0.35em'
  }, ownerState.paragraph && {
    marginBottom: 16
  }));
  const defaultVariantMapping = {
    h1: 'h1',
    h2: 'h2',
    h3: 'h3',
    h4: 'h4',
    h5: 'h5',
    h6: 'h6',
    subtitle1: 'h6',
    subtitle2: 'h6',
    body1: 'p',
    body2: 'p',
    inherit: 'p'
  }; // TODO v6: deprecate these color values in v5.x and remove the transformation in v6

  const colorTransformations = {
    primary: 'primary.main',
    textPrimary: 'text.primary',
    secondary: 'secondary.main',
    textSecondary: 'text.secondary',
    error: 'error.main'
  };

  const transformDeprecatedColors = color => {
    return colorTransformations[color] || color;
  };

  const Typography = /*#__PURE__*/react.exports.forwardRef(function Typography(inProps, ref) {
    const themeProps = useThemeProps({
      props: inProps,
      name: 'MuiTypography'
    });
    const color = transformDeprecatedColors(themeProps.color);
    const props = extendSxProp(_extends$4({}, themeProps, {
      color
    }));

    const {
      align = 'inherit',
      className,
      component,
      gutterBottom = false,
      noWrap = false,
      paragraph = false,
      variant = 'body1',
      variantMapping = defaultVariantMapping
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$a);

    const ownerState = _extends$4({}, props, {
      align,
      color,
      className,
      component,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      variantMapping
    });

    const Component = component || (paragraph ? 'p' : variantMapping[variant] || defaultVariantMapping[variant]) || 'span';
    const classes = useUtilityClasses$5(ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsx(TypographyRoot, _extends$4({
      as: Component,
      ref: ref,
      ownerState: ownerState,
      className: clsx(classes.root, className)
    }, other));
  });
  var Typography$1 = Typography;

  /**
   *
   * Demos:
   *
   * - [Autocomplete](https://mui.com/components/autocomplete/)
   * - [Menus](https://mui.com/components/menus/)
   * - [Popper](https://mui.com/components/popper/)
   *
   * API:
   *
   * - [Popper API](https://mui.com/api/popper/)
   */

  const Popper = /*#__PURE__*/react.exports.forwardRef(function Popper(props, ref) {
    const theme = useTheme$2();
    return /*#__PURE__*/jsxRuntime.exports.jsx(PopperUnstyled$1, _extends$4({
      direction: theme == null ? void 0 : theme.direction
    }, props, {
      ref: ref
    }));
  });
  var Popper$1 = Popper;

  const _excluded$9 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
  const styles$2 = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  };
  const defaultTimeout = {
    enter: duration.enteringScreen,
    exit: duration.leavingScreen
  };
  /**
   * The Fade transition is used by the [Modal](/components/modal/) component.
   * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
   */

  const Fade = /*#__PURE__*/react.exports.forwardRef(function Fade(props, ref) {
    const {
      addEndListener,
      appear = true,
      children,
      easing,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style,
      timeout = defaultTimeout,
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition$1
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$9);

    const theme = useTheme();
    const nodeRef = react.exports.useRef(null);
    const foreignRef = useForkRef(children.ref, ref);
    const handleRef = useForkRef(nodeRef, foreignRef);

    const normalizedTransitionCallback = callback => maybeIsAppearing => {
      if (callback) {
        const node = nodeRef.current; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.

        if (maybeIsAppearing === undefined) {
          callback(node);
        } else {
          callback(node, maybeIsAppearing);
        }
      }
    };

    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
      reflow(node); // So the animation always start from the start.

      const transitionProps = getTransitionProps({
        style,
        timeout,
        easing
      }, {
        mode: 'enter'
      });
      node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
      node.style.transition = theme.transitions.create('opacity', transitionProps);

      if (onEnter) {
        onEnter(node, isAppearing);
      }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback(node => {
      const transitionProps = getTransitionProps({
        style,
        timeout,
        easing
      }, {
        mode: 'exit'
      });
      node.style.webkitTransition = theme.transitions.create('opacity', transitionProps);
      node.style.transition = theme.transitions.create('opacity', transitionProps);

      if (onExit) {
        onExit(node);
      }
    });
    const handleExited = normalizedTransitionCallback(onExited);

    const handleAddEndListener = next => {
      if (addEndListener) {
        // Old call signature before `react-transition-group` implemented `nodeRef`
        addEndListener(nodeRef.current, next);
      }
    };

    return /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends$4({
      appear: appear,
      in: inProp,
      nodeRef: nodeRef ,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: handleAddEndListener,
      timeout: timeout
    }, other, {
      children: (state, childProps) => {
        return /*#__PURE__*/react.exports.cloneElement(children, _extends$4({
          style: _extends$4({
            opacity: 0,
            visibility: state === 'exited' && !inProp ? 'hidden' : undefined
          }, styles$2[state], style, children.props.style),
          ref: handleRef
        }, childProps));
      }
    }));
  });
  var Fade$1 = Fade;

  const _excluded$8 = ["children", "components", "componentsProps", "className", "invisible", "open", "transitionDuration", "TransitionComponent"];

  const extendUtilityClasses$1 = ownerState => {
    const {
      classes
    } = ownerState;
    return classes;
  };

  const BackdropRoot = styled$1('div', {
    name: 'MuiBackdrop',
    slot: 'Root',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.root, ownerState.invisible && styles.invisible];
    }
  })(({
    ownerState
  }) => _extends$4({
    position: 'fixed',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    WebkitTapHighlightColor: 'transparent'
  }, ownerState.invisible && {
    backgroundColor: 'transparent'
  }));
  const Backdrop = /*#__PURE__*/react.exports.forwardRef(function Backdrop(inProps, ref) {
    var _componentsProps$root;

    const props = useThemeProps({
      props: inProps,
      name: 'MuiBackdrop'
    });

    const {
      children,
      components = {},
      componentsProps = {},
      className,
      invisible = false,
      open,
      transitionDuration,
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Fade$1
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$8);

    const ownerState = _extends$4({}, props, {
      invisible
    });

    const classes = extendUtilityClasses$1(ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends$4({
      in: open,
      timeout: transitionDuration
    }, other, {
      children: /*#__PURE__*/jsxRuntime.exports.jsx(BackdropUnstyled$1, {
        className: className,
        invisible: invisible,
        components: _extends$4({
          Root: BackdropRoot
        }, components),
        componentsProps: {
          root: _extends$4({}, componentsProps.root, (!components.Root || !isHostComponent(components.Root)) && {
            ownerState: _extends$4({}, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.ownerState)
          })
        },
        classes: classes,
        ref: ref,
        children: children
      })
    }));
  });
  var Backdrop$1 = Backdrop;

  const defaultTheme = createTheme();
  /**
   * @ignore - do not document.
   */

  const Box = createBox({
    defaultTheme,
    defaultClassName: 'MuiBox-root',
    generateClassName: ClassNameGenerator$1.generate
  });
  var Box$1 = Box;

  function GlobalStyles(props) {
    return /*#__PURE__*/jsxRuntime.exports.jsx(GlobalStyles$1, _extends$4({}, props, {
      defaultTheme: defaultTheme$2
    }));
  }

  const _excluded$7 = ["BackdropComponent", "closeAfterTransition", "children", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted"];

  const extendUtilityClasses = ownerState => {
    return ownerState.classes;
  };

  const ModalRoot = styled$1('div', {
    name: 'MuiModal',
    slot: 'Root',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.root, !ownerState.open && ownerState.exited && styles.hidden];
    }
  })(({
    theme,
    ownerState
  }) => _extends$4({
    position: 'fixed',
    zIndex: theme.zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0
  }, !ownerState.open && ownerState.exited && {
    visibility: 'hidden'
  }));
  const ModalBackdrop = styled$1(Backdrop$1, {
    name: 'MuiModal',
    slot: 'Backdrop',
    overridesResolver: (props, styles) => {
      return styles.backdrop;
    }
  })({
    zIndex: -1
  });
  /**
   * Modal is a lower-level construct that is leveraged by the following components:
   *
   * - [Dialog](/api/dialog/)
   * - [Drawer](/api/drawer/)
   * - [Menu](/api/menu/)
   * - [Popover](/api/popover/)
   *
   * If you are creating a modal dialog, you probably want to use the [Dialog](/api/dialog/) component
   * rather than directly using Modal.
   *
   * This component shares many concepts with [react-overlays](https://react-bootstrap.github.io/react-overlays/#modals).
   */

  const Modal = /*#__PURE__*/react.exports.forwardRef(function Modal(inProps, ref) {
    var _componentsProps$root;

    const props = useThemeProps({
      name: 'MuiModal',
      props: inProps
    });

    const {
      BackdropComponent = ModalBackdrop,
      closeAfterTransition = false,
      children,
      components = {},
      componentsProps = {},
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableEscapeKeyDown = false,
      disablePortal = false,
      disableRestoreFocus = false,
      disableScrollLock = false,
      hideBackdrop = false,
      keepMounted = false
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$7);

    const [exited, setExited] = react.exports.useState(true);
    const commonProps = {
      closeAfterTransition,
      disableAutoFocus,
      disableEnforceFocus,
      disableEscapeKeyDown,
      disablePortal,
      disableRestoreFocus,
      disableScrollLock,
      hideBackdrop,
      keepMounted
    };

    const ownerState = _extends$4({}, props, commonProps, {
      exited
    });

    const classes = extendUtilityClasses(ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsx(ModalUnstyled$1, _extends$4({
      components: _extends$4({
        Root: ModalRoot
      }, components),
      componentsProps: {
        root: _extends$4({}, componentsProps.root, (!components.Root || !isHostComponent(components.Root)) && {
          ownerState: _extends$4({}, (_componentsProps$root = componentsProps.root) == null ? void 0 : _componentsProps$root.ownerState)
        })
      },
      BackdropComponent: BackdropComponent,
      onTransitionEnter: () => setExited(false),
      onTransitionExited: () => setExited(true),
      ref: ref
    }, other, {
      classes: classes
    }, commonProps, {
      children: children
    }));
  });
  var Modal$1 = Modal;

  const dividerClasses = generateUtilityClasses('MuiDivider', ['root', 'absolute', 'fullWidth', 'inset', 'middle', 'flexItem', 'light', 'vertical', 'withChildren', 'withChildrenVertical', 'textAlignRight', 'textAlignLeft', 'wrapper', 'wrapperVertical']);
  var dividerClasses$1 = dividerClasses;

  const _excluded$6 = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];

  function getScale(value) {
    return `scale(${value}, ${value ** 2})`;
  }

  const styles$1 = {
    entering: {
      opacity: 1,
      transform: getScale(1)
    },
    entered: {
      opacity: 1,
      transform: 'none'
    }
  };
  /**
   * The Grow transition is used by the [Tooltip](/components/tooltips/) and
   * [Popover](/components/popover/) components.
   * It uses [react-transition-group](https://github.com/reactjs/react-transition-group) internally.
   */

  const Grow = /*#__PURE__*/react.exports.forwardRef(function Grow(props, ref) {
    const {
      addEndListener,
      appear = true,
      children,
      easing,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style,
      timeout = 'auto',
      // eslint-disable-next-line react/prop-types
      TransitionComponent = Transition$1
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$6);

    const timer = react.exports.useRef();
    const autoTimeout = react.exports.useRef();
    const theme = useTheme();
    const nodeRef = react.exports.useRef(null);
    const foreignRef = useForkRef(children.ref, ref);
    const handleRef = useForkRef(nodeRef, foreignRef);

    const normalizedTransitionCallback = callback => maybeIsAppearing => {
      if (callback) {
        const node = nodeRef.current; // onEnterXxx and onExitXxx callbacks have a different arguments.length value.

        if (maybeIsAppearing === undefined) {
          callback(node);
        } else {
          callback(node, maybeIsAppearing);
        }
      }
    };

    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node, isAppearing) => {
      reflow(node); // So the animation always start from the start.

      const {
        duration: transitionDuration,
        delay,
        easing: transitionTimingFunction
      } = getTransitionProps({
        style,
        timeout,
        easing
      }, {
        mode: 'enter'
      });
      let duration;

      if (timeout === 'auto') {
        duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
        autoTimeout.current = duration;
      } else {
        duration = transitionDuration;
      }

      node.style.transition = [theme.transitions.create('opacity', {
        duration,
        delay
      }), theme.transitions.create('transform', {
        duration: duration * 0.666,
        delay,
        easing: transitionTimingFunction
      })].join(',');

      if (onEnter) {
        onEnter(node, isAppearing);
      }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback(node => {
      const {
        duration: transitionDuration,
        delay,
        easing: transitionTimingFunction
      } = getTransitionProps({
        style,
        timeout,
        easing
      }, {
        mode: 'exit'
      });
      let duration;

      if (timeout === 'auto') {
        duration = theme.transitions.getAutoHeightDuration(node.clientHeight);
        autoTimeout.current = duration;
      } else {
        duration = transitionDuration;
      }

      node.style.transition = [theme.transitions.create('opacity', {
        duration,
        delay
      }), theme.transitions.create('transform', {
        duration: duration * 0.666,
        delay: delay || duration * 0.333,
        easing: transitionTimingFunction
      })].join(',');
      node.style.opacity = '0';
      node.style.transform = getScale(0.75);

      if (onExit) {
        onExit(node);
      }
    });
    const handleExited = normalizedTransitionCallback(onExited);

    const handleAddEndListener = next => {
      if (timeout === 'auto') {
        timer.current = setTimeout(next, autoTimeout.current || 0);
      }

      if (addEndListener) {
        // Old call signature before `react-transition-group` implemented `nodeRef`
        addEndListener(nodeRef.current, next);
      }
    };

    react.exports.useEffect(() => {
      return () => {
        clearTimeout(timer.current);
      };
    }, []);
    return /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends$4({
      appear: appear,
      in: inProp,
      nodeRef: nodeRef,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: handleAddEndListener,
      timeout: timeout === 'auto' ? null : timeout
    }, other, {
      children: (state, childProps) => {
        return /*#__PURE__*/react.exports.cloneElement(children, _extends$4({
          style: _extends$4({
            opacity: 0,
            transform: getScale(0.75),
            visibility: state === 'exited' && !inProp ? 'hidden' : undefined
          }, styles$1[state], style, children.props.style),
          ref: handleRef
        }, childProps));
      }
    }));
  });
  Grow.muiSupportAuto = true;
  var Grow$1 = Grow;

  /**
   * @deprecated Not used internally. Use `MediaQueryListEvent` from lib.dom.d.ts instead.
   */

  function useMediaQuery(queryInput, options = {}) {
    const theme = useTheme$2(); // Wait for jsdom to support the match media feature.
    // All the browsers MUI support have this built-in.
    // This defensive check is here for simplicity.
    // Most of the time, the match media logic isn't central to people tests.

    const supportMatchMedia = typeof window !== 'undefined' && typeof window.matchMedia !== 'undefined';
    const {
      defaultMatches = false,
      matchMedia = supportMatchMedia ? window.matchMedia : null,
      noSsr = false,
      ssrMatchMedia = null
    } = getThemeProps({
      name: 'MuiUseMediaQuery',
      props: options,
      theme
    });

    let query = typeof queryInput === 'function' ? queryInput(theme) : queryInput;
    query = query.replace(/^@media( ?)/m, '');
    const [match, setMatch] = react.exports.useState(() => {
      if (noSsr && supportMatchMedia) {
        return matchMedia(query).matches;
      }

      if (ssrMatchMedia) {
        return ssrMatchMedia(query).matches;
      } // Once the component is mounted, we rely on the
      // event listeners to return the correct matches value.


      return defaultMatches;
    });
    useEnhancedEffect$1(() => {
      let active = true;

      if (!supportMatchMedia) {
        return undefined;
      }

      const queryList = matchMedia(query);

      const updateMatch = () => {
        // Workaround Safari wrong implementation of matchMedia
        // TODO can we remove it?
        // https://github.com/mui-org/material-ui/pull/17315#issuecomment-528286677
        if (active) {
          setMatch(queryList.matches);
        }
      };

      updateMatch();
      queryList.addListener(updateMatch);
      return () => {
        active = false;
        queryList.removeListener(updateMatch);
      };
    }, [query, matchMedia, supportMatchMedia]);

    return match;
  }

  /**
   * @ignore - internal component.
   */

  const ListContext = /*#__PURE__*/react.exports.createContext({});

  var ListContext$1 = ListContext;

  function getListUtilityClass(slot) {
    return generateUtilityClass('MuiList', slot);
  }
  generateUtilityClasses('MuiList', ['root', 'padding', 'dense', 'subheader']);

  const _excluded$5 = ["children", "className", "component", "dense", "disablePadding", "subheader"];

  const useUtilityClasses$4 = ownerState => {
    const {
      classes,
      disablePadding,
      dense,
      subheader
    } = ownerState;
    const slots = {
      root: ['root', !disablePadding && 'padding', dense && 'dense', subheader && 'subheader']
    };
    return composeClasses(slots, getListUtilityClass, classes);
  };

  const ListRoot = styled$1('ul', {
    name: 'MuiList',
    slot: 'Root',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.root, !ownerState.disablePadding && styles.padding, ownerState.dense && styles.dense, ownerState.subheader && styles.subheader];
    }
  })(({
    ownerState
  }) => _extends$4({
    listStyle: 'none',
    margin: 0,
    padding: 0,
    position: 'relative'
  }, !ownerState.disablePadding && {
    paddingTop: 8,
    paddingBottom: 8
  }, ownerState.subheader && {
    paddingTop: 0
  }));
  const List = /*#__PURE__*/react.exports.forwardRef(function List(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiList'
    });

    const {
      children,
      className,
      component = 'ul',
      dense = false,
      disablePadding = false,
      subheader
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$5);

    const context = react.exports.useMemo(() => ({
      dense
    }), [dense]);

    const ownerState = _extends$4({}, props, {
      component,
      dense,
      disablePadding
    });

    const classes = useUtilityClasses$4(ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsx(ListContext$1.Provider, {
      value: context,
      children: /*#__PURE__*/jsxRuntime.exports.jsxs(ListRoot, _extends$4({
        as: component,
        className: clsx(classes.root, className),
        ref: ref,
        ownerState: ownerState
      }, other, {
        children: [subheader, children]
      }))
    });
  });
  var List$1 = List;

  const listItemIconClasses = generateUtilityClasses('MuiListItemIcon', ['root', 'alignItemsFlexStart']);
  var listItemIconClasses$1 = listItemIconClasses;

  const listItemTextClasses = generateUtilityClasses('MuiListItemText', ['root', 'multiline', 'dense', 'inset', 'primary', 'secondary']);
  var listItemTextClasses$1 = listItemTextClasses;

  const _excluded$4 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];

  function nextItem(list, item, disableListWrap) {
    if (list === item) {
      return list.firstChild;
    }

    if (item && item.nextElementSibling) {
      return item.nextElementSibling;
    }

    return disableListWrap ? null : list.firstChild;
  }

  function previousItem(list, item, disableListWrap) {
    if (list === item) {
      return disableListWrap ? list.firstChild : list.lastChild;
    }

    if (item && item.previousElementSibling) {
      return item.previousElementSibling;
    }

    return disableListWrap ? null : list.lastChild;
  }

  function textCriteriaMatches(nextFocus, textCriteria) {
    if (textCriteria === undefined) {
      return true;
    }

    let text = nextFocus.innerText;

    if (text === undefined) {
      // jsdom doesn't support innerText
      text = nextFocus.textContent;
    }

    text = text.trim().toLowerCase();

    if (text.length === 0) {
      return false;
    }

    if (textCriteria.repeating) {
      return text[0] === textCriteria.keys[0];
    }

    return text.indexOf(textCriteria.keys.join('')) === 0;
  }

  function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
    let wrappedOnce = false;
    let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);

    while (nextFocus) {
      // Prevent infinite loop.
      if (nextFocus === list.firstChild) {
        if (wrappedOnce) {
          return false;
        }

        wrappedOnce = true;
      } // Same logic as useAutocomplete.js


      const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute('aria-disabled') === 'true';

      if (!nextFocus.hasAttribute('tabindex') || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
        // Move to the next element.
        nextFocus = traversalFunction(list, nextFocus, disableListWrap);
      } else {
        nextFocus.focus();
        return true;
      }
    }

    return false;
  }
  /**
   * A permanently displayed menu following https://www.w3.org/TR/wai-aria-practices/#menubutton.
   * It's exposed to help customization of the [`Menu`](/api/menu/) component if you
   * use it separately you need to move focus into the component manually. Once
   * the focus is placed inside the component it is fully keyboard accessible.
   */


  const MenuList = /*#__PURE__*/react.exports.forwardRef(function MenuList(props, ref) {
    const {
      // private
      // eslint-disable-next-line react/prop-types
      actions,
      autoFocus = false,
      autoFocusItem = false,
      children,
      className,
      disabledItemsFocusable = false,
      disableListWrap = false,
      onKeyDown,
      variant = 'selectedMenu'
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$4);

    const listRef = react.exports.useRef(null);
    const textCriteriaRef = react.exports.useRef({
      keys: [],
      repeating: true,
      previousKeyMatched: true,
      lastTime: null
    });
    useEnhancedEffect$1(() => {
      if (autoFocus) {
        listRef.current.focus();
      }
    }, [autoFocus]);
    react.exports.useImperativeHandle(actions, () => ({
      adjustStyleForScrollbar: (containerElement, theme) => {
        // Let's ignore that piece of logic if users are already overriding the width
        // of the menu.
        const noExplicitWidth = !listRef.current.style.width;

        if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
          const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
          listRef.current.style[theme.direction === 'rtl' ? 'paddingLeft' : 'paddingRight'] = scrollbarSize;
          listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
        }

        return listRef.current;
      }
    }), []);

    const handleKeyDown = event => {
      const list = listRef.current;
      const key = event.key;
      /**
       * @type {Element} - will always be defined since we are in a keydown handler
       * attached to an element. A keydown event is either dispatched to the activeElement
       * or document.body or document.documentElement. Only the first case will
       * trigger this specific handler.
       */

      const currentFocus = ownerDocument(list).activeElement;

      if (key === 'ArrowDown') {
        // Prevent scroll of the page
        event.preventDefault();
        moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
      } else if (key === 'ArrowUp') {
        event.preventDefault();
        moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
      } else if (key === 'Home') {
        event.preventDefault();
        moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
      } else if (key === 'End') {
        event.preventDefault();
        moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
      } else if (key.length === 1) {
        const criteria = textCriteriaRef.current;
        const lowerKey = key.toLowerCase();
        const currTime = performance.now();

        if (criteria.keys.length > 0) {
          // Reset
          if (currTime - criteria.lastTime > 500) {
            criteria.keys = [];
            criteria.repeating = true;
            criteria.previousKeyMatched = true;
          } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
            criteria.repeating = false;
          }
        }

        criteria.lastTime = currTime;
        criteria.keys.push(lowerKey);
        const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);

        if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
          event.preventDefault();
        } else {
          criteria.previousKeyMatched = false;
        }
      }

      if (onKeyDown) {
        onKeyDown(event);
      }
    };

    const handleRef = useForkRef(listRef, ref);
    /**
     * the index of the item should receive focus
     * in a `variant="selectedMenu"` it's the first `selected` item
     * otherwise it's the very first item.
     */

    let activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
    // to check if there is a `selected` item. We're looking for the last `selected`
    // item and use the first valid item as a fallback

    react.exports.Children.forEach(children, (child, index) => {
      if (! /*#__PURE__*/react.exports.isValidElement(child)) {
        return;
      }

      if (!child.props.disabled) {
        if (variant === 'selectedMenu' && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
    });
    const items = react.exports.Children.map(children, (child, index) => {
      if (index === activeItemIndex) {
        const newChildProps = {};

        if (autoFocusItem) {
          newChildProps.autoFocus = true;
        }

        if (child.props.tabIndex === undefined && variant === 'selectedMenu') {
          newChildProps.tabIndex = 0;
        }

        return /*#__PURE__*/react.exports.cloneElement(child, newChildProps);
      }

      return child;
    });
    return /*#__PURE__*/jsxRuntime.exports.jsx(List$1, _extends$4({
      role: "menu",
      ref: handleRef,
      className: className,
      onKeyDown: handleKeyDown,
      tabIndex: autoFocus ? 0 : -1
    }, other, {
      children: items
    }));
  });
  var MenuList$1 = MenuList;

  function getPopoverUtilityClass(slot) {
    return generateUtilityClass('MuiPopover', slot);
  }
  generateUtilityClasses('MuiPopover', ['root', 'paper']);

  const _excluded$3 = ["onEntering"],
        _excluded2$1 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps"];
  function getOffsetTop(rect, vertical) {
    let offset = 0;

    if (typeof vertical === 'number') {
      offset = vertical;
    } else if (vertical === 'center') {
      offset = rect.height / 2;
    } else if (vertical === 'bottom') {
      offset = rect.height;
    }

    return offset;
  }
  function getOffsetLeft(rect, horizontal) {
    let offset = 0;

    if (typeof horizontal === 'number') {
      offset = horizontal;
    } else if (horizontal === 'center') {
      offset = rect.width / 2;
    } else if (horizontal === 'right') {
      offset = rect.width;
    }

    return offset;
  }

  function getTransformOriginValue(transformOrigin) {
    return [transformOrigin.horizontal, transformOrigin.vertical].map(n => typeof n === 'number' ? `${n}px` : n).join(' ');
  }

  function resolveAnchorEl(anchorEl) {
    return typeof anchorEl === 'function' ? anchorEl() : anchorEl;
  }

  const useUtilityClasses$3 = ownerState => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ['root'],
      paper: ['paper']
    };
    return composeClasses(slots, getPopoverUtilityClass, classes);
  };

  const PopoverRoot = styled$1(Modal$1, {
    name: 'MuiPopover',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root
  })({});
  const PopoverPaper = styled$1(Paper$1, {
    name: 'MuiPopover',
    slot: 'Paper',
    overridesResolver: (props, styles) => styles.paper
  })({
    position: 'absolute',
    overflowY: 'auto',
    overflowX: 'hidden',
    // So we see the popover when it's empty.
    // It's most likely on issue on userland.
    minWidth: 16,
    minHeight: 16,
    maxWidth: 'calc(100% - 32px)',
    maxHeight: 'calc(100% - 32px)',
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  });
  const Popover = /*#__PURE__*/react.exports.forwardRef(function Popover(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiPopover'
    });

    const {
      action,
      anchorEl,
      anchorOrigin = {
        vertical: 'top',
        horizontal: 'left'
      },
      anchorPosition,
      anchorReference = 'anchorEl',
      children,
      className,
      container: containerProp,
      elevation = 8,
      marginThreshold = 16,
      open,
      PaperProps = {},
      transformOrigin = {
        vertical: 'top',
        horizontal: 'left'
      },
      TransitionComponent = Grow$1,
      transitionDuration: transitionDurationProp = 'auto',
      TransitionProps: {
        onEntering
      } = {}
    } = props,
          TransitionProps = _objectWithoutPropertiesLoose$2(props.TransitionProps, _excluded$3),
          other = _objectWithoutPropertiesLoose$2(props, _excluded2$1);

    const paperRef = react.exports.useRef();
    const handlePaperRef = useForkRef(paperRef, PaperProps.ref);

    const ownerState = _extends$4({}, props, {
      anchorOrigin,
      anchorReference,
      elevation,
      marginThreshold,
      PaperProps,
      transformOrigin,
      TransitionComponent,
      transitionDuration: transitionDurationProp,
      TransitionProps
    });

    const classes = useUtilityClasses$3(ownerState); // Returns the top/left offset of the position
    // to attach to on the anchor element (or body if none is provided)

    const getAnchorOffset = react.exports.useCallback(() => {
      if (anchorReference === 'anchorPosition') {

        return anchorPosition;
      }

      const resolvedAnchorEl = resolveAnchorEl(anchorEl); // If an anchor element wasn't provided, just use the parent body element of this Popover

      const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
      const anchorRect = anchorElement.getBoundingClientRect();

      return {
        top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
        left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
      };
    }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]); // Returns the base transform origin using the element

    const getTransformOrigin = react.exports.useCallback(elemRect => {
      return {
        vertical: getOffsetTop(elemRect, transformOrigin.vertical),
        horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
      };
    }, [transformOrigin.horizontal, transformOrigin.vertical]);
    const getPositioningStyle = react.exports.useCallback(element => {
      const elemRect = {
        width: element.offsetWidth,
        height: element.offsetHeight
      }; // Get the transform origin point on the element itself

      const elemTransformOrigin = getTransformOrigin(elemRect);

      if (anchorReference === 'none') {
        return {
          top: null,
          left: null,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      } // Get the offset of the anchoring element


      const anchorOffset = getAnchorOffset(); // Calculate element positioning

      let top = anchorOffset.top - elemTransformOrigin.vertical;
      let left = anchorOffset.left - elemTransformOrigin.horizontal;
      const bottom = top + elemRect.height;
      const right = left + elemRect.width; // Use the parent window of the anchorEl if provided

      const containerWindow = ownerWindow(resolveAnchorEl(anchorEl)); // Window thresholds taking required margin into account

      const heightThreshold = containerWindow.innerHeight - marginThreshold;
      const widthThreshold = containerWindow.innerWidth - marginThreshold; // Check if the vertical axis needs shifting

      if (top < marginThreshold) {
        const diff = top - marginThreshold;
        top -= diff;
        elemTransformOrigin.vertical += diff;
      } else if (bottom > heightThreshold) {
        const diff = bottom - heightThreshold;
        top -= diff;
        elemTransformOrigin.vertical += diff;
      }


      if (left < marginThreshold) {
        const diff = left - marginThreshold;
        left -= diff;
        elemTransformOrigin.horizontal += diff;
      } else if (right > widthThreshold) {
        const diff = right - widthThreshold;
        left -= diff;
        elemTransformOrigin.horizontal += diff;
      }

      return {
        top: `${Math.round(top)}px`,
        left: `${Math.round(left)}px`,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
    const setPositioningStyles = react.exports.useCallback(() => {
      const element = paperRef.current;

      if (!element) {
        return;
      }

      const positioning = getPositioningStyle(element);

      if (positioning.top !== null) {
        element.style.top = positioning.top;
      }

      if (positioning.left !== null) {
        element.style.left = positioning.left;
      }

      element.style.transformOrigin = positioning.transformOrigin;
    }, [getPositioningStyle]);

    const handleEntering = (element, isAppearing) => {
      if (onEntering) {
        onEntering(element, isAppearing);
      }

      setPositioningStyles();
    };

    react.exports.useEffect(() => {
      if (open) {
        setPositioningStyles();
      }
    });
    react.exports.useImperativeHandle(action, () => open ? {
      updatePosition: () => {
        setPositioningStyles();
      }
    } : null, [open, setPositioningStyles]);
    react.exports.useEffect(() => {
      if (!open) {
        return undefined;
      }

      const handleResize = debounce$1(() => {
        setPositioningStyles();
      });
      const containerWindow = ownerWindow(anchorEl);
      containerWindow.addEventListener('resize', handleResize);
      return () => {
        handleResize.clear();
        containerWindow.removeEventListener('resize', handleResize);
      };
    }, [anchorEl, open, setPositioningStyles]);
    let transitionDuration = transitionDurationProp;

    if (transitionDurationProp === 'auto' && !TransitionComponent.muiSupportAuto) {
      transitionDuration = undefined;
    } // If the container prop is provided, use that
    // If the anchorEl prop is provided, use its parent body element as the container
    // If neither are provided let the Modal take care of choosing the container


    const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : undefined);
    return /*#__PURE__*/jsxRuntime.exports.jsx(PopoverRoot, _extends$4({
      BackdropProps: {
        invisible: true
      },
      className: clsx(classes.root, className),
      container: container,
      open: open,
      ref: ref,
      ownerState: ownerState
    }, other, {
      children: /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends$4({
        appear: true,
        in: open,
        onEntering: handleEntering,
        timeout: transitionDuration
      }, TransitionProps, {
        children: /*#__PURE__*/jsxRuntime.exports.jsx(PopoverPaper, _extends$4({
          elevation: elevation
        }, PaperProps, {
          ref: handlePaperRef,
          className: clsx(classes.paper, PaperProps.className),
          children: children
        }))
      }))
    }));
  });
  var Popover$1 = Popover;

  function getMenuUtilityClass(slot) {
    return generateUtilityClass('MuiMenu', slot);
  }
  generateUtilityClasses('MuiMenu', ['root', 'paper', 'list']);

  const _excluded$2 = ["onEntering"],
        _excluded2 = ["autoFocus", "children", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant"];
  const RTL_ORIGIN = {
    vertical: 'top',
    horizontal: 'right'
  };
  const LTR_ORIGIN = {
    vertical: 'top',
    horizontal: 'left'
  };

  const useUtilityClasses$2 = ownerState => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ['root'],
      paper: ['paper'],
      list: ['list']
    };
    return composeClasses(slots, getMenuUtilityClass, classes);
  };

  const MenuRoot = styled$1(Popover$1, {
    shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
    name: 'MuiMenu',
    slot: 'Root',
    overridesResolver: (props, styles) => styles.root
  })({});
  const MenuPaper = styled$1(Paper$1, {
    name: 'MuiMenu',
    slot: 'Paper',
    overridesResolver: (props, styles) => styles.paper
  })({
    // specZ: The maximum height of a simple menu should be one or more rows less than the view
    // height. This ensures a tapable area outside of the simple menu with which to dismiss
    // the menu.
    maxHeight: 'calc(100% - 96px)',
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: 'touch'
  });
  const MenuMenuList = styled$1(MenuList$1, {
    name: 'MuiMenu',
    slot: 'List',
    overridesResolver: (props, styles) => styles.list
  })({
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0
  });
  const Menu = /*#__PURE__*/react.exports.forwardRef(function Menu(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiMenu'
    });

    const {
      autoFocus = true,
      children,
      disableAutoFocusItem = false,
      MenuListProps = {},
      onClose,
      open,
      PaperProps = {},
      PopoverClasses,
      transitionDuration = 'auto',
      TransitionProps: {
        onEntering
      } = {},
      variant = 'selectedMenu'
    } = props,
          TransitionProps = _objectWithoutPropertiesLoose$2(props.TransitionProps, _excluded$2),
          other = _objectWithoutPropertiesLoose$2(props, _excluded2);

    const theme = useTheme();
    const isRtl = theme.direction === 'rtl';

    const ownerState = _extends$4({}, props, {
      autoFocus,
      disableAutoFocusItem,
      MenuListProps,
      onEntering,
      PaperProps,
      transitionDuration,
      TransitionProps,
      variant
    });

    const classes = useUtilityClasses$2(ownerState);
    const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
    const menuListActionsRef = react.exports.useRef(null);

    const handleEntering = (element, isAppearing) => {
      if (menuListActionsRef.current) {
        menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
      }

      if (onEntering) {
        onEntering(element, isAppearing);
      }
    };

    const handleListKeyDown = event => {
      if (event.key === 'Tab') {
        event.preventDefault();

        if (onClose) {
          onClose(event, 'tabKeyDown');
        }
      }
    };
    /**
     * the index of the item should receive focus
     * in a `variant="selectedMenu"` it's the first `selected` item
     * otherwise it's the very first item.
     */


    let activeItemIndex = -1; // since we inject focus related props into children we have to do a lookahead
    // to check if there is a `selected` item. We're looking for the last `selected`
    // item and use the first valid item as a fallback

    react.exports.Children.map(children, (child, index) => {
      if (! /*#__PURE__*/react.exports.isValidElement(child)) {
        return;
      }

      if (!child.props.disabled) {
        if (variant === 'selectedMenu' && child.props.selected) {
          activeItemIndex = index;
        } else if (activeItemIndex === -1) {
          activeItemIndex = index;
        }
      }
    });
    return /*#__PURE__*/jsxRuntime.exports.jsx(MenuRoot, _extends$4({
      classes: PopoverClasses,
      onClose: onClose,
      anchorOrigin: {
        vertical: 'bottom',
        horizontal: isRtl ? 'right' : 'left'
      },
      transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
      PaperProps: _extends$4({
        component: MenuPaper
      }, PaperProps, {
        classes: _extends$4({}, PaperProps.classes, {
          root: classes.paper
        })
      }),
      className: classes.root,
      open: open,
      ref: ref,
      transitionDuration: transitionDuration,
      TransitionProps: _extends$4({
        onEntering: handleEntering
      }, TransitionProps),
      ownerState: ownerState
    }, other, {
      children: /*#__PURE__*/jsxRuntime.exports.jsx(MenuMenuList, _extends$4({
        onKeyDown: handleListKeyDown,
        actions: menuListActionsRef,
        autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
        autoFocusItem: autoFocusItem,
        variant: variant
      }, MenuListProps, {
        className: clsx(classes.list, MenuListProps.className),
        children: children
      }))
    }));
  });
  var Menu$1 = Menu;

  function getMenuItemUtilityClass(slot) {
    return generateUtilityClass('MuiMenuItem', slot);
  }
  const menuItemClasses = generateUtilityClasses('MuiMenuItem', ['root', 'focusVisible', 'dense', 'disabled', 'divider', 'gutters', 'selected']);
  var menuItemClasses$1 = menuItemClasses;

  const _excluded$1 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex"];
  const overridesResolver = (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.dense && styles.dense, ownerState.divider && styles.divider, !ownerState.disableGutters && styles.gutters];
  };

  const useUtilityClasses$1 = ownerState => {
    const {
      disabled,
      dense,
      divider,
      disableGutters,
      selected,
      classes
    } = ownerState;
    const slots = {
      root: ['root', dense && 'dense', disabled && 'disabled', !disableGutters && 'gutters', divider && 'divider', selected && 'selected']
    };
    const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes);
    return _extends$4({}, classes, composedClasses);
  };

  const MenuItemRoot = styled$1(ButtonBase$1, {
    shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',
    name: 'MuiMenuItem',
    slot: 'Root',
    overridesResolver
  })(({
    theme,
    ownerState
  }) => _extends$4({}, theme.typography.body1, {
    display: 'flex',
    justifyContent: 'flex-start',
    alignItems: 'center',
    position: 'relative',
    textDecoration: 'none',
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: 'border-box',
    whiteSpace: 'nowrap'
  }, !ownerState.disableGutters && {
    paddingLeft: 16,
    paddingRight: 16
  }, ownerState.divider && {
    borderBottom: `1px solid ${theme.palette.divider}`,
    backgroundClip: 'padding-box'
  }, {
    '&:hover': {
      textDecoration: 'none',
      backgroundColor: theme.palette.action.hover,
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: 'transparent'
      }
    },
    [`&.${menuItemClasses$1.selected}`]: {
      backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      [`&.${menuItemClasses$1.focusVisible}`]: {
        backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
      }
    },
    [`&.${menuItemClasses$1.selected}:hover`]: {
      backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      '@media (hover: none)': {
        backgroundColor: alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
      }
    },
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: theme.palette.action.focus
    },
    [`&.${menuItemClasses$1.disabled}`]: {
      opacity: theme.palette.action.disabledOpacity
    },
    [`& + .${dividerClasses$1.root}`]: {
      marginTop: theme.spacing(1),
      marginBottom: theme.spacing(1)
    },
    [`& + .${dividerClasses$1.inset}`]: {
      marginLeft: 52
    },
    [`& .${listItemTextClasses$1.root}`]: {
      marginTop: 0,
      marginBottom: 0
    },
    [`& .${listItemTextClasses$1.inset}`]: {
      paddingLeft: 36
    },
    [`& .${listItemIconClasses$1.root}`]: {
      minWidth: 36
    }
  }, !ownerState.dense && {
    [theme.breakpoints.up('sm')]: {
      minHeight: 'auto'
    }
  }, ownerState.dense && _extends$4({
    minHeight: 32,
    // https://material.io/components/menus#specs > Dense
    paddingTop: 4,
    paddingBottom: 4
  }, theme.typography.body2, {
    [`& .${listItemIconClasses$1.root} svg`]: {
      fontSize: '1.25rem'
    }
  })));
  const MenuItem = /*#__PURE__*/react.exports.forwardRef(function MenuItem(inProps, ref) {
    const props = useThemeProps({
      props: inProps,
      name: 'MuiMenuItem'
    });

    const {
      autoFocus = false,
      component = 'li',
      dense = false,
      divider = false,
      disableGutters = false,
      focusVisibleClassName,
      role = 'menuitem',
      tabIndex: tabIndexProp
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded$1);

    const context = react.exports.useContext(ListContext$1);
    const childContext = {
      dense: dense || context.dense || false,
      disableGutters
    };
    const menuItemRef = react.exports.useRef(null);
    useEnhancedEffect$1(() => {
      if (autoFocus) {
        if (menuItemRef.current) {
          menuItemRef.current.focus();
        }
      }
    }, [autoFocus]);

    const ownerState = _extends$4({}, props, {
      dense: childContext.dense,
      divider,
      disableGutters
    });

    const classes = useUtilityClasses$1(props);
    const handleRef = useForkRef(menuItemRef, ref);
    let tabIndex;

    if (!props.disabled) {
      tabIndex = tabIndexProp !== undefined ? tabIndexProp : -1;
    }

    return /*#__PURE__*/jsxRuntime.exports.jsx(ListContext$1.Provider, {
      value: childContext,
      children: /*#__PURE__*/jsxRuntime.exports.jsx(MenuItemRoot, _extends$4({
        ref: handleRef,
        role: role,
        tabIndex: tabIndex,
        component: component,
        focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName)
      }, other, {
        ownerState: ownerState,
        classes: classes
      }))
    });
  });
  var MenuItem$1 = MenuItem;

  function getTooltipUtilityClass(slot) {
    return generateUtilityClass('MuiTooltip', slot);
  }
  const tooltipClasses = generateUtilityClasses('MuiTooltip', ['popper', 'popperInteractive', 'popperArrow', 'popperClose', 'tooltip', 'tooltipArrow', 'touch', 'tooltipPlacementLeft', 'tooltipPlacementRight', 'tooltipPlacementTop', 'tooltipPlacementBottom', 'arrow']);
  var tooltipClasses$1 = tooltipClasses;

  const _excluded = ["arrow", "children", "classes", "components", "componentsProps", "describeChild", "disableFocusListener", "disableHoverListener", "disableInteractive", "disableTouchListener", "enterDelay", "enterNextDelay", "enterTouchDelay", "followCursor", "id", "leaveDelay", "leaveTouchDelay", "onClose", "onOpen", "open", "placement", "PopperComponent", "PopperProps", "title", "TransitionComponent", "TransitionProps"];

  function round(value) {
    return Math.round(value * 1e5) / 1e5;
  }

  const useUtilityClasses = ownerState => {
    const {
      classes,
      disableInteractive,
      arrow,
      touch,
      placement
    } = ownerState;
    const slots = {
      popper: ['popper', !disableInteractive && 'popperInteractive', arrow && 'popperArrow'],
      tooltip: ['tooltip', arrow && 'tooltipArrow', touch && 'touch', `tooltipPlacement${capitalize(placement.split('-')[0])}`],
      arrow: ['arrow']
    };
    return composeClasses(slots, getTooltipUtilityClass, classes);
  };

  const TooltipPopper = styled$1(Popper$1, {
    name: 'MuiTooltip',
    slot: 'Popper',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.popper, !ownerState.disableInteractive && styles.popperInteractive, ownerState.arrow && styles.popperArrow, !ownerState.open && styles.popperClose];
    }
  })(({
    theme,
    ownerState,
    open
  }) => _extends$4({
    zIndex: theme.zIndex.tooltip,
    pointerEvents: 'none'
  }, !ownerState.disableInteractive && {
    pointerEvents: 'auto'
  }, !open && {
    pointerEvents: 'none'
  }, ownerState.arrow && {
    [`&[data-popper-placement*="bottom"] .${tooltipClasses$1.arrow}`]: {
      top: 0,
      marginTop: '-0.71em',
      '&::before': {
        transformOrigin: '0 100%'
      }
    },
    [`&[data-popper-placement*="top"] .${tooltipClasses$1.arrow}`]: {
      bottom: 0,
      marginBottom: '-0.71em',
      '&::before': {
        transformOrigin: '100% 0'
      }
    },
    [`&[data-popper-placement*="right"] .${tooltipClasses$1.arrow}`]: _extends$4({}, !ownerState.isRtl ? {
      left: 0,
      marginLeft: '-0.71em'
    } : {
      right: 0,
      marginRight: '-0.71em'
    }, {
      height: '1em',
      width: '0.71em',
      '&::before': {
        transformOrigin: '100% 100%'
      }
    }),
    [`&[data-popper-placement*="left"] .${tooltipClasses$1.arrow}`]: _extends$4({}, !ownerState.isRtl ? {
      right: 0,
      marginRight: '-0.71em'
    } : {
      left: 0,
      marginLeft: '-0.71em'
    }, {
      height: '1em',
      width: '0.71em',
      '&::before': {
        transformOrigin: '0 0'
      }
    })
  }));
  const TooltipTooltip = styled$1('div', {
    name: 'MuiTooltip',
    slot: 'Tooltip',
    overridesResolver: (props, styles) => {
      const {
        ownerState
      } = props;
      return [styles.tooltip, ownerState.touch && styles.touch, ownerState.arrow && styles.tooltipArrow, styles[`tooltipPlacement${capitalize(ownerState.placement.split('-')[0])}`]];
    }
  })(({
    theme,
    ownerState
  }) => _extends$4({
    backgroundColor: alpha(theme.palette.grey[700], 0.92),
    borderRadius: theme.shape.borderRadius,
    color: theme.palette.common.white,
    fontFamily: theme.typography.fontFamily,
    padding: '4px 8px',
    fontSize: theme.typography.pxToRem(11),
    maxWidth: 300,
    margin: 2,
    wordWrap: 'break-word',
    fontWeight: theme.typography.fontWeightMedium
  }, ownerState.arrow && {
    position: 'relative',
    margin: 0
  }, ownerState.touch && {
    padding: '8px 16px',
    fontSize: theme.typography.pxToRem(14),
    lineHeight: `${round(16 / 14)}em`,
    fontWeight: theme.typography.fontWeightRegular
  }, {
    [`.${tooltipClasses$1.popper}[data-popper-placement*="left"] &`]: _extends$4({
      transformOrigin: 'right center'
    }, !ownerState.isRtl ? _extends$4({
      marginRight: '14px'
    }, ownerState.touch && {
      marginRight: '24px'
    }) : _extends$4({
      marginLeft: '14px'
    }, ownerState.touch && {
      marginLeft: '24px'
    })),
    [`.${tooltipClasses$1.popper}[data-popper-placement*="right"] &`]: _extends$4({
      transformOrigin: 'left center'
    }, !ownerState.isRtl ? _extends$4({
      marginLeft: '14px'
    }, ownerState.touch && {
      marginLeft: '24px'
    }) : _extends$4({
      marginRight: '14px'
    }, ownerState.touch && {
      marginRight: '24px'
    })),
    [`.${tooltipClasses$1.popper}[data-popper-placement*="top"] &`]: _extends$4({
      transformOrigin: 'center bottom',
      marginBottom: '14px'
    }, ownerState.touch && {
      marginBottom: '24px'
    }),
    [`.${tooltipClasses$1.popper}[data-popper-placement*="bottom"] &`]: _extends$4({
      transformOrigin: 'center top',
      marginTop: '14px'
    }, ownerState.touch && {
      marginTop: '24px'
    })
  }));
  const TooltipArrow = styled$1('span', {
    name: 'MuiTooltip',
    slot: 'Arrow',
    overridesResolver: (props, styles) => styles.arrow
  })(({
    theme
  }) => ({
    overflow: 'hidden',
    position: 'absolute',
    width: '1em',
    height: '0.71em'
    /* = width / sqrt(2) = (length of the hypotenuse) */
    ,
    boxSizing: 'border-box',
    color: alpha(theme.palette.grey[700], 0.9),
    '&::before': {
      content: '""',
      margin: 'auto',
      display: 'block',
      width: '100%',
      height: '100%',
      backgroundColor: 'currentColor',
      transform: 'rotate(45deg)'
    }
  }));
  let hystersisOpen = false;
  let hystersisTimer = null;

  function composeEventHandler(handler, eventHandler) {
    return event => {
      if (eventHandler) {
        eventHandler(event);
      }

      handler(event);
    };
  } // TODO v6: Remove PopperComponent, PopperProps, TransitionComponent and TransitionProps.


  const Tooltip = /*#__PURE__*/react.exports.forwardRef(function Tooltip(inProps, ref) {
    var _components$Popper, _ref, _components$Transitio, _components$Tooltip, _components$Arrow, _componentsProps$popp;

    const props = useThemeProps({
      props: inProps,
      name: 'MuiTooltip'
    });

    const {
      arrow = false,
      children,
      components = {},
      componentsProps = {},
      describeChild = false,
      disableFocusListener = false,
      disableHoverListener = false,
      disableInteractive: disableInteractiveProp = false,
      disableTouchListener = false,
      enterDelay = 100,
      enterNextDelay = 0,
      enterTouchDelay = 700,
      followCursor = false,
      id: idProp,
      leaveDelay = 0,
      leaveTouchDelay = 1500,
      onClose,
      onOpen,
      open: openProp,
      placement = 'bottom',
      PopperComponent: PopperComponentProp,
      PopperProps = {},
      title,
      TransitionComponent: TransitionComponentProp = Grow$1,
      TransitionProps
    } = props,
          other = _objectWithoutPropertiesLoose$2(props, _excluded);

    const theme = useTheme();
    const isRtl = theme.direction === 'rtl';
    const [childNode, setChildNode] = react.exports.useState();
    const [arrowRef, setArrowRef] = react.exports.useState(null);
    const ignoreNonTouchEvents = react.exports.useRef(false);
    const disableInteractive = disableInteractiveProp || followCursor;
    const closeTimer = react.exports.useRef();
    const enterTimer = react.exports.useRef();
    const leaveTimer = react.exports.useRef();
    const touchTimer = react.exports.useRef();
    const [openState, setOpenState] = useControlled({
      controlled: openProp,
      default: false,
      name: 'Tooltip',
      state: 'open'
    });
    let open = openState;

    const id = useId(idProp);
    const prevUserSelect = react.exports.useRef();
    const stopTouchInteraction = react.exports.useCallback(() => {
      if (prevUserSelect.current !== undefined) {
        document.body.style.WebkitUserSelect = prevUserSelect.current;
        prevUserSelect.current = undefined;
      }

      clearTimeout(touchTimer.current);
    }, []);
    react.exports.useEffect(() => {
      return () => {
        clearTimeout(closeTimer.current);
        clearTimeout(enterTimer.current);
        clearTimeout(leaveTimer.current);
        stopTouchInteraction();
      };
    }, [stopTouchInteraction]);

    const handleOpen = event => {
      clearTimeout(hystersisTimer);
      hystersisOpen = true; // The mouseover event will trigger for every nested element in the tooltip.
      // We can skip rerendering when the tooltip is already open.
      // We are using the mouseover event instead of the mouseenter event to fix a hide/show issue.

      setOpenState(true);

      if (onOpen && !open) {
        onOpen(event);
      }
    };

    const handleClose = useEventCallback(
    /**
     * @param {React.SyntheticEvent | Event} event
     */
    event => {
      clearTimeout(hystersisTimer);
      hystersisTimer = setTimeout(() => {
        hystersisOpen = false;
      }, 800 + leaveDelay);
      setOpenState(false);

      if (onClose && open) {
        onClose(event);
      }

      clearTimeout(closeTimer.current);
      closeTimer.current = setTimeout(() => {
        ignoreNonTouchEvents.current = false;
      }, theme.transitions.duration.shortest);
    });

    const handleEnter = event => {
      if (ignoreNonTouchEvents.current && event.type !== 'touchstart') {
        return;
      } // Remove the title ahead of time.
      // We don't want to wait for the next render commit.
      // We would risk displaying two tooltips at the same time (native + this one).


      if (childNode) {
        childNode.removeAttribute('title');
      }

      clearTimeout(enterTimer.current);
      clearTimeout(leaveTimer.current);

      if (enterDelay || hystersisOpen && enterNextDelay) {
        enterTimer.current = setTimeout(() => {
          handleOpen(event);
        }, hystersisOpen ? enterNextDelay : enterDelay);
      } else {
        handleOpen(event);
      }
    };

    const handleLeave = event => {
      clearTimeout(enterTimer.current);
      clearTimeout(leaveTimer.current);
      leaveTimer.current = setTimeout(() => {
        handleClose(event);
      }, leaveDelay);
    };

    const {
      isFocusVisibleRef,
      onBlur: handleBlurVisible,
      onFocus: handleFocusVisible,
      ref: focusVisibleRef
    } = useIsFocusVisible(); // We don't necessarily care about the focusVisible state (which is safe to access via ref anyway).
    // We just need to re-render the Tooltip if the focus-visible state changes.

    const [, setChildIsFocusVisible] = react.exports.useState(false);

    const handleBlur = event => {
      handleBlurVisible(event);

      if (isFocusVisibleRef.current === false) {
        setChildIsFocusVisible(false);
        handleLeave(event);
      }
    };

    const handleFocus = event => {
      // Workaround for https://github.com/facebook/react/issues/7769
      // The autoFocus of React might trigger the event before the componentDidMount.
      // We need to account for this eventuality.
      if (!childNode) {
        setChildNode(event.currentTarget);
      }

      handleFocusVisible(event);

      if (isFocusVisibleRef.current === true) {
        setChildIsFocusVisible(true);
        handleEnter(event);
      }
    };

    const detectTouchStart = event => {
      ignoreNonTouchEvents.current = true;
      const childrenProps = children.props;

      if (childrenProps.onTouchStart) {
        childrenProps.onTouchStart(event);
      }
    };

    const handleMouseOver = handleEnter;
    const handleMouseLeave = handleLeave;

    const handleTouchStart = event => {
      detectTouchStart(event);
      clearTimeout(leaveTimer.current);
      clearTimeout(closeTimer.current);
      stopTouchInteraction();
      prevUserSelect.current = document.body.style.WebkitUserSelect; // Prevent iOS text selection on long-tap.

      document.body.style.WebkitUserSelect = 'none';
      touchTimer.current = setTimeout(() => {
        document.body.style.WebkitUserSelect = prevUserSelect.current;
        handleEnter(event);
      }, enterTouchDelay);
    };

    const handleTouchEnd = event => {
      if (children.props.onTouchEnd) {
        children.props.onTouchEnd(event);
      }

      stopTouchInteraction();
      clearTimeout(leaveTimer.current);
      leaveTimer.current = setTimeout(() => {
        handleClose(event);
      }, leaveTouchDelay);
    };

    react.exports.useEffect(() => {
      if (!open) {
        return undefined;
      }
      /**
       * @param {KeyboardEvent} nativeEvent
       */


      function handleKeyDown(nativeEvent) {
        // IE11, Edge (prior to using Bink?) use 'Esc'
        if (nativeEvent.key === 'Escape' || nativeEvent.key === 'Esc') {
          handleClose(nativeEvent);
        }
      }

      document.addEventListener('keydown', handleKeyDown);
      return () => {
        document.removeEventListener('keydown', handleKeyDown);
      };
    }, [handleClose, open]);
    const handleUseRef = useForkRef(setChildNode, ref);
    const handleFocusRef = useForkRef(focusVisibleRef, handleUseRef);
    const handleRef = useForkRef(children.ref, handleFocusRef); // There is no point in displaying an empty tooltip.

    if (title === '') {
      open = false;
    }

    const positionRef = react.exports.useRef({
      x: 0,
      y: 0
    });
    const popperRef = react.exports.useRef();

    const handleMouseMove = event => {
      const childrenProps = children.props;

      if (childrenProps.onMouseMove) {
        childrenProps.onMouseMove(event);
      }

      positionRef.current = {
        x: event.clientX,
        y: event.clientY
      };

      if (popperRef.current) {
        popperRef.current.update();
      }
    };

    const nameOrDescProps = {};
    const titleIsString = typeof title === 'string';

    if (describeChild) {
      nameOrDescProps.title = !open && titleIsString && !disableHoverListener ? title : null;
      nameOrDescProps['aria-describedby'] = open ? id : null;
    } else {
      nameOrDescProps['aria-label'] = titleIsString ? title : null;
      nameOrDescProps['aria-labelledby'] = open && !titleIsString ? id : null;
    }

    const childrenProps = _extends$4({}, nameOrDescProps, other, children.props, {
      className: clsx(other.className, children.props.className),
      onTouchStart: detectTouchStart,
      ref: handleRef
    }, followCursor ? {
      onMouseMove: handleMouseMove
    } : {});

    const interactiveWrapperListeners = {};

    if (!disableTouchListener) {
      childrenProps.onTouchStart = handleTouchStart;
      childrenProps.onTouchEnd = handleTouchEnd;
    }

    if (!disableHoverListener) {
      childrenProps.onMouseOver = composeEventHandler(handleMouseOver, childrenProps.onMouseOver);
      childrenProps.onMouseLeave = composeEventHandler(handleMouseLeave, childrenProps.onMouseLeave);

      if (!disableInteractive) {
        interactiveWrapperListeners.onMouseOver = handleMouseOver;
        interactiveWrapperListeners.onMouseLeave = handleMouseLeave;
      }
    }

    if (!disableFocusListener) {
      childrenProps.onFocus = composeEventHandler(handleFocus, childrenProps.onFocus);
      childrenProps.onBlur = composeEventHandler(handleBlur, childrenProps.onBlur);

      if (!disableInteractive) {
        interactiveWrapperListeners.onFocus = handleFocus;
        interactiveWrapperListeners.onBlur = handleBlur;
      }
    }

    const popperOptions = react.exports.useMemo(() => {
      var _PopperProps$popperOp;

      let tooltipModifiers = [{
        name: 'arrow',
        enabled: Boolean(arrowRef),
        options: {
          element: arrowRef,
          padding: 4
        }
      }];

      if ((_PopperProps$popperOp = PopperProps.popperOptions) != null && _PopperProps$popperOp.modifiers) {
        tooltipModifiers = tooltipModifiers.concat(PopperProps.popperOptions.modifiers);
      }

      return _extends$4({}, PopperProps.popperOptions, {
        modifiers: tooltipModifiers
      });
    }, [arrowRef, PopperProps]);

    const ownerState = _extends$4({}, props, {
      isRtl,
      arrow,
      disableInteractive,
      placement,
      PopperComponentProp,
      touch: ignoreNonTouchEvents.current
    });

    const classes = useUtilityClasses(ownerState);
    const PopperComponent = (_components$Popper = components.Popper) != null ? _components$Popper : TooltipPopper;
    const TransitionComponent = (_ref = (_components$Transitio = components.Transition) != null ? _components$Transitio : TransitionComponentProp) != null ? _ref : Grow$1;
    const TooltipComponent = (_components$Tooltip = components.Tooltip) != null ? _components$Tooltip : TooltipTooltip;
    const ArrowComponent = (_components$Arrow = components.Arrow) != null ? _components$Arrow : TooltipArrow;
    const popperProps = appendOwnerState(PopperComponent, _extends$4({}, PopperProps, componentsProps.popper), ownerState);
    const transitionProps = appendOwnerState(TransitionComponent, _extends$4({}, TransitionProps, componentsProps.transition), ownerState);
    const tooltipProps = appendOwnerState(TooltipComponent, _extends$4({}, componentsProps.tooltip), ownerState);
    const tooltipArrowProps = appendOwnerState(ArrowComponent, _extends$4({}, componentsProps.arrow), ownerState);
    return /*#__PURE__*/jsxRuntime.exports.jsxs(react.exports.Fragment, {
      children: [/*#__PURE__*/react.exports.cloneElement(children, childrenProps), /*#__PURE__*/jsxRuntime.exports.jsx(PopperComponent, _extends$4({
        as: PopperComponentProp != null ? PopperComponentProp : Popper$1,
        placement: placement,
        anchorEl: followCursor ? {
          getBoundingClientRect: () => ({
            top: positionRef.current.y,
            left: positionRef.current.x,
            right: positionRef.current.x,
            bottom: positionRef.current.y,
            width: 0,
            height: 0
          })
        } : childNode,
        popperRef: popperRef,
        open: childNode ? open : false,
        id: id,
        transition: true
      }, interactiveWrapperListeners, popperProps, {
        className: clsx(classes.popper, PopperProps == null ? void 0 : PopperProps.className, (_componentsProps$popp = componentsProps.popper) == null ? void 0 : _componentsProps$popp.className),
        popperOptions: popperOptions,
        children: ({
          TransitionProps: TransitionPropsInner
        }) => {
          var _componentsProps$tool, _componentsProps$arro;

          return /*#__PURE__*/jsxRuntime.exports.jsx(TransitionComponent, _extends$4({
            timeout: theme.transitions.duration.shorter
          }, TransitionPropsInner, transitionProps, {
            children: /*#__PURE__*/jsxRuntime.exports.jsxs(TooltipComponent, _extends$4({}, tooltipProps, {
              className: clsx(classes.tooltip, (_componentsProps$tool = componentsProps.tooltip) == null ? void 0 : _componentsProps$tool.className),
              children: [title, arrow ? /*#__PURE__*/jsxRuntime.exports.jsx(ArrowComponent, _extends$4({}, tooltipArrowProps, {
                className: clsx(classes.arrow, (_componentsProps$arro = componentsProps.arrow) == null ? void 0 : _componentsProps$arro.className),
                ref: setArrowRef
              })) : null]
            }))
          }));
        }
      }))]
    });
  });
  var Tooltip$1 = Tooltip;

  var LevelDescriptorIcon = createSvgIcon$1( /*#__PURE__*/React.createElement("path", {
    d: "M17.4175 7.55977C17.4175 6.61977 18.5575 6.13977 19.2275 6.80977L23.7075 11.2898C24.0975 11.6798 24.0975 12.3098 23.7075 12.6998L19.2275 17.1798C18.5575 17.8598 17.4175 17.3798 17.4175 16.4398C17.4175 16.1598 17.5275 15.8898 17.7275 15.6898L21.4175 11.9998L17.7275 8.30977C17.5275 8.10977 17.4175 7.83977 17.4175 7.55977ZM11.4175 8.99977V7.40977C11.4175 6.51977 12.4975 6.06977 13.1275 6.69977L17.7175 11.2898C18.1075 11.6798 18.1075 12.3098 17.7175 12.6998L13.1275 17.2898C12.4975 17.9198 11.4175 17.4698 11.4175 16.5798V14.8998C6.4175 14.8998 2.9175 16.4998 0.4175 19.9998C1.4175 14.9998 4.4175 9.99977 11.4175 8.99977Z"
  }), 'LevelDescriptor');

  var FieldIcon = createSvgIcon$1( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M22.2792 9.85407H19.8193V5.37854C19.8193 5.25794 19.7216 5.16016 19.6009 5.16016H13.5294C13.4087 5.16016 13.311 5.25794 13.311 5.37854V9.85407H10.6661V5.37854C10.6661 5.25794 10.5684 5.16016 10.4477 5.16016H4.36862C4.24792 5.16016 4.15024 5.25794 4.15024 5.37854V9.85407H1.72057C1.35866 9.85407 1.06543 10.1474 1.06543 10.5092V18.6809C1.06543 19.0427 1.35866 19.336 1.72057 19.336H22.2792C22.6411 19.336 22.9343 19.0427 22.9343 18.6809V10.5092C22.9343 10.1474 22.6411 9.85407 22.2792 9.85407ZM9.29868 11.2215H14.6784V6.52755H18.4519V11.2215H21.567V17.9687H2.43282V11.2215H5.51763V6.52755H9.29868V11.2215Z"
  })), 'ContentTypeField');

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

  function getStyles(sx) {
    return {
      box: {
        boxSizing: 'border-box',
        outline: theme => `2px solid ${theme.palette.success.main}`,
        outlineOffset: '-2px',
        textAlign: 'center',
        position: 'absolute',
        zIndex: 'tooltip',
        pointerEvents: 'none',
        ...(sx === null || sx === void 0 ? void 0 : sx.box)
      },
      paper: {
        padding: [0.5, 1],
        fontSize: '14px',
        overflow: 'hidden',
        fontWeight: 700,
        pointerEvents: 'none',
        zIndex: 'tooltip',
        display: 'flex',
        alignItems: 'center',
        flexDirection: 'column',
        ...(sx === null || sx === void 0 ? void 0 : sx.paper)
      },
      icon: {
        marginRight: 1,
        ...(sx === null || sx === void 0 ? void 0 : sx.icon)
      },
      tooltip: {
        transition: 'none',
        zIndex: 'tooltip',
        ...(sx === null || sx === void 0 ? void 0 : sx.tooltip)
      },
      menuItemsContainer: {
        pointerEvents: 'all',
        alignItems: 'center',
        display: 'flex'
      }
    };
  }

  function ZoneMarker(props) {
    const {
      rect,
      label,
      classes,
      inherited,
      menuItems,
      showZoneTooltip = true,
      onPopperClick
    } = props;
    const [zoneStyle, setZoneStyle] = react.exports.useState();
    const sx = getStyles(props.sx);
    const elRef = react.exports.useRef();
    react.exports.useEffect(() => {
      setZoneStyle(getZoneMarkerStyle(rect));
    }, [rect]);
    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Box$1, {
      ref: elRef,
      style: zoneStyle,
      sx: sx.box,
      className: classes === null || classes === void 0 ? void 0 : classes.box
    }), showZoneTooltip && elRef.current && /*#__PURE__*/React.createElement(Box$1, {
      open: true,
      component: Popper$1,
      anchorEl: elRef.current,
      placement: "top-start",
      onClick: onPopperClick,
      sx: sx.tooltip,
      modifiers: [{
        name: 'offset',
        options: {
          offset: [0, 5]
        }
      }]
    }, /*#__PURE__*/React.createElement(Paper$1, {
      className: classes === null || classes === void 0 ? void 0 : classes.paper,
      sx: sx.paper
    }, /*#__PURE__*/React.createElement("div", {
      style: {
        display: 'flex'
      }
    }, inherited ? /*#__PURE__*/React.createElement(LevelDescriptorIcon, {
      sx: sx.icon
    }) : /*#__PURE__*/React.createElement(FieldIcon, {
      sx: sx.icon
    }), /*#__PURE__*/React.createElement(Typography$1, {
      title: label,
      noWrap: true,
      sx: {
        pointerEvents: 'all'
      }
    }, label)), /*#__PURE__*/React.createElement("div", null, menuItems && /*#__PURE__*/React.createElement(Box$1, {
      sx: sx.menuItemsContainer
    }, menuItems)))));
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

  function getSx(sx) {
    return {
      root: {
        zIndex: 'tooltip',
        position: 'fixed',
        pointerEvents: 'none',
        ...(sx === null || sx === void 0 ? void 0 : sx.root)
      },
      tips: {
        content: '""',
        width: '8px',
        height: '8px',
        backgroundColor: 'error.main',
        borderRadius: 1,
        marginTop: '-3px',
        marginLeft: '-4.5px',
        position: 'absolute',
        ...(sx === null || sx === void 0 ? void 0 : sx.tips)
      },
      vertical: {
        height: 2,
        visibility: 'visible',
        backgroundColor: 'error.main',
        boxShadow: 1,
        '&::before': {
          left: 0
        },
        '&::after': {
          right: 0
        },
        ...(sx === null || sx === void 0 ? void 0 : sx.horizontal)
      },
      horizontal: {
        width: 2,
        minHeight: '5px',
        marginLeft: '3px',
        border: 1,
        borderColor: 'error.main',
        boxShadow: 1,
        '&::before': {
          top: 0
        },
        '&::after': {
          bottom: -4
        },
        ...(sx === null || sx === void 0 ? void 0 : sx.vertical)
      }
    };
  }

  function DropMarker(props) {
    const {
      over: {
        element
      },
      prev,
      next,
      dropZone,
      coordinates,
      onDropPosition
    } = props;
    const refs = react.exports.useRef({
      targetIndex: null
    });
    const [style, setStyle] = react.exports.useState({});
    const sx = getSx(props.sx);
    const arrangement = dropZone.arrangement;
    react.exports.useEffect(() => {
      let nextStyle = null;
      let targetIndex;

      if (element === dropZone.element) {
        if (element.children.length > 0) {
          const closestChildIndex = findClosestRect(dropZone.rect, dropZone.childrenRects, coordinates),
                closestRect = dropZone.childrenRects[closestChildIndex],
                closestChild = dropZone.children[closestChildIndex],
                before = dropZone.arrangement === HORIZONTAL ? // Is it to the left of the center of the rect?
          coordinates.x <= closestRect.left + closestRect.width / 2 : // Is it to the north of the center of the rect?
          coordinates.y <= closestRect.top + closestRect.height / 2;
          nextStyle = getDropMarkerPosition({
            arrangement: dropZone.arrangement,
            insertPosition: before ? 'before' : 'after',
            refElement: closestChild,
            refElementRect: closestRect,
            nextOrPrevRect: before ? dropZone.childrenRects[closestChildIndex - 1] : dropZone.childrenRects[closestChildIndex + 1]
          });
          targetIndex = before ? closestChildIndex : closestChildIndex + 1;
        } else {
          // Drop zone is empty
          // onDropPosition({ targetIndex: 0 });
          const virtualRects = splitRect(dropZone.rect, // Using the larger space to display the drop marker makes it more visible
          dropZone.rect.width > dropZone.rect.height ? X_AXIS : Y_AXIS);
          nextStyle = getDropMarkerPosition({
            arrangement: dropZone.arrangement,
            insertPosition: 'after',
            refElement: dropZone.element,
            refElementRect: virtualRects[0],
            nextOrPrevRect: virtualRects[1]
          });
          targetIndex = 0;
        }
      } else {
        let prevRect = prev;
        let nextRect = next;
        let rect = element.getBoundingClientRect();
        let rectStats = getInRectStats(rect, coordinates);

        if (rectStats.inRect) {
          const insertPosition = dropZone.arrangement === HORIZONTAL && rectStats.percents.x >= 50 || dropZone.arrangement === VERTICAL && rectStats.percents.y >= 50 ? 'after' : 'before';
          let before = insertPosition === 'before';
          nextStyle = getDropMarkerPosition({
            insertPosition,
            arrangement: dropZone.arrangement,
            refElement: element,
            refElementRect: rect,
            nextOrPrevRect: before ? prevRect : nextRect
          });
          targetIndex = dropZone.children.findIndex(e => e === element);

          if (!before) {
            ++targetIndex;
          }
        } else {
          console.log('DropMarker:dragOver unhandled path');
        }
      }

      if (notNullOrUndefined(nextStyle)) {
        forEach(Object.keys(nextStyle), key => {
          if (style[key] !== nextStyle[key]) {
            setStyle(nextStyle);
            return 'break';
          }
        });
      }

      if (refs.current.targetIndex !== targetIndex) {
        refs.current.targetIndex = targetIndex;
        onDropPosition({
          targetIndex
        });
      }
    }, [prev, next, coordinates.x, coordinates.y, element, dropZone.element, dropZone.rect, dropZone.childrenRects, dropZone.children, dropZone.arrangement, coordinates, style, onDropPosition]);
    return /*#__PURE__*/React.createElement(Box$1, {
      sx: { ...sx.root,
        ...style,
        // @ts-ignore
        '&::before, &::after': sx.tips,
        ...(arrangement === HORIZONTAL ? sx.horizontal : sx.vertical)
      }
    });
  }
  DropMarker.defaultProps = {
    onDropPosition: foo
  };

  const palette = {
    white: '#fff',
    black: '#000',
    blue: {
      tint: '#409CFF',
      main: '#007AFF',
      shade: '#0040DD',
      highlight: 'rgba(0, 122, 255, .1)',
      highlightHex: '#E6F2FF'
    },
    green: {
      tint: '#30DB5B',
      main: '#34C759',
      shade: '#248A3D',
      highlight: '#EBFAEF'
    },
    indigo: {
      tint: '#7D7AFF',
      main: '#5856D6',
      shade: '#3634A3'
    },
    orange: {
      tint: '#FFB340',
      main: '#FF9500',
      shade: '#C93400'
    },
    pink: {
      tint: '#FF6482',
      main: '#FF2D55',
      shade: '#D30F45'
    },
    purple: {
      tint: '#DA8FFF',
      main: '#AF52DE',
      shade: '#8944AB'
    },
    red: {
      tint: '#FF6961',
      main: '#FF3B30',
      shade: '#D70015',
      highlight: '#FFEBEA'
    },
    teal: {
      tint: '#70D7FF',
      main: '#5AC8FA',
      shade: '#0071A4'
    },
    yellow: {
      tint: '#FFD426',
      main: '#FFCC00',
      shade: '#A05A00',
      highlight: '#FFFAE6'
    },
    gray: {
      light0: '#FAFAFA',
      light1: '#F3F3F3',
      light2: '#F2F2F7',
      light3: '#EBEBF0',
      light4: '#E5E5EA',
      light5: '#D8D8DC',
      light6: '#D1D1D6',
      light7: '#C7C7CC',
      medium1: '#BCBCC0',
      medium2: '#AEAEB2',
      medium3: '#8E8E93',
      medium4: '#7C7C80',
      medium5: '#6C6C70',
      medium6: '#636366',
      medium7: '#545456',
      dark1: '#48484A',
      dark2: '#444446',
      dark3: '#3A3A3C',
      dark4: '#363638',
      dark5: '#2C2C2E',
      dark6: '#242426',
      dark7: '#1C1C1E'
    }
  };

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function useGuestTheme(styleConfig) {
    const prefersDarkMode = useMediaQuery('(prefers-color-scheme: dark)');
    return react.exports.useMemo(() => {
      const mode = prefersDarkMode ? 'dark' : 'light';
      return createTheme({
        palette: {
          mode,
          primary: {
            main: prefersDarkMode ? palette.blue.tint : palette.blue.main
          },
          warning: {
            main: prefersDarkMode ? palette.orange.tint : palette.orange.main
          },
          error: {
            main: prefersDarkMode ? palette.red.tint : palette.red.main
          },
          success: {
            main: prefersDarkMode ? palette.green.tint : palette.green.main
          },
          info: {
            main: prefersDarkMode ? palette.teal.tint : palette.teal.main
          },
          secondary: {
            main: prefersDarkMode ? palette.indigo.tint : palette.purple.tint
          }
        }
      }, styleConfig);
    }, [prefersDarkMode, styleConfig]);
  }
  const styleSxDefaults = {
    zoneMarker: {
      base: {},
      selectModeHighlight: {
        paper: {
          bgcolor: 'success.light',
          color: 'success.contrastText'
        },
        box: {
          outlineColor: theme => theme.palette.success.light
        },
        icon: {
          color: 'success.contrastText'
        }
      },
      moveModeHighlight: {
        paper: {
          bgcolor: 'primary.light',
          color: 'primary.contrastText'
        },
        box: {
          outlineColor: theme => theme.palette.primary.light
        },
        icon: {}
      },
      errorHighlight: {
        paper: {
          bgcolor: 'error.light',
          color: 'error.contrastText'
        },
        box: {
          bgcolor: 'error.light'
        }
      },
      warnHighlight: {
        paper: {
          bgcolor: 'warning.light',
          color: 'warning.contrastText'
        },
        box: {
          outlineColor: theme => theme.palette.warning.light
        }
      }
    }
  };

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function AssetUploaderMask(props) {
    const {
      rect,
      progress
    } = props,
          [zoneStyle, setZoneStyle] = react.exports.useState();
    react.exports.useEffect(() => {
      setZoneStyle(getZoneMarkerStyle(rect));
    }, [rect]);
    return /*#__PURE__*/React.createElement("craftercms-asset-uploader-mask-container", {
      style: zoneStyle
    }, /*#__PURE__*/React.createElement("craftercms-asset-uploader-mask", {
      style: {
        height: `${100 - progress}%`
      }
    }));
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  let EditingStatus;

  (function (EditingStatus) {
    EditingStatus["LISTENING"] = "LISTENING";
    EditingStatus["SORTING_COMPONENT"] = "SORTING_COMPONENT";
    EditingStatus["PLACING_NEW_COMPONENT"] = "PLACING_NEW_COMPONENT";
    EditingStatus["PLACING_DETACHED_COMPONENT"] = "PLACING_DETACHED_COMPONENT";
    EditingStatus["PLACING_DETACHED_ASSET"] = "PLACING_DETACHED_ASSET";
    EditingStatus["EDITING_COMPONENT"] = "EDITING_COMPONENT";
    EditingStatus["EDITING_COMPONENT_INLINE"] = "EDITING_COMPONENT_INLINE";
    EditingStatus["UPLOAD_ASSET_FROM_DESKTOP"] = "UPLOAD_ASSET_FROM_DESKTOP";
    EditingStatus["SHOW_DROP_TARGETS"] = "SHOW_DROP_TARGETS";
    EditingStatus["FIELD_SELECTED"] = "FIELD_SELECTED";
    EditingStatus["HIGHLIGHT_MOVE_TARGETS"] = "HIGHLIGHT_MOVE_TARGETS";
  })(EditingStatus || (EditingStatus = {}));

  let HighlightMode;

  (function (HighlightMode) {
    HighlightMode["ALL"] = "all";
    HighlightMode["MOVE_TARGETS"] = "move";
  })(HighlightMode || (HighlightMode = {}));

  const editOnClass = 'craftercms-ice-on';
  const iceBypassKeyClass = 'craftercms-ice-bypass';
  const eventCaptureOverlayAttribute = 'data-craftercms-event-capture-overlay';
  const moveModeClass = `craftercms-highlight-${HighlightMode.MOVE_TARGETS}`;
  const editModeClass = `craftercms-highlight-${HighlightMode.ALL}`;
  const emptyCollectionClass = 'craftercms-empty-collection';
  const emptyFieldClass = 'craftercms-empty-field';
  const dragAndDropActiveClass = 'craftercms-drag-n-drop-active';
  const editModePaddingClass = 'craftercms-edit-mode-padding';
  const editModeIceBypassEvent = 'craftercms.iceBypass';
  const editModeEvent = 'craftercms.editMode';

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
    };

    return extendStatics(d, b);
  };

  function __extends(d, b) {
    if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var StateObservable =
  /** @class */
  function (_super) {
    __extends(StateObservable, _super);

    function StateObservable(input$, initialState) {
      var _this = _super.call(this, function (subscriber) {
        var subscription = _this.__notifier.subscribe(subscriber);

        if (subscription && !subscription.closed) {
          subscriber.next(_this.value);
        }

        return subscription;
      }) || this;

      _this.__notifier = new Subject();
      _this.value = initialState;
      input$.subscribe(function (value) {
        // We only want to update state$ if it has actually changed since
        // redux requires reducers use immutability patterns.
        // This is basically what distinctUntilChanged() does but it's so simple
        // we don't need to pull that code in
        if (value !== _this.value) {
          _this.value = value;

          _this.__notifier.next(value);
        }
      });
      return _this;
    }

    return StateObservable;
  }(Observable);

  function createEpicMiddleware(options) {
    if (options === void 0) {
      options = {};
    } // This isn't great. RxJS doesn't publicly export the constructor for
    // QueueScheduler nor QueueAction, so we reach in. We need to do this because
    // we don't want our internal queuing mechanism to be on the same queue as any
    // other RxJS code outside of redux-observable internals.


    var QueueScheduler = queueScheduler.constructor;
    var uniqueQueueScheduler = new QueueScheduler(queueScheduler.schedulerActionCtor);

    var epic$ = new Subject();
    var store;

    var epicMiddleware = function (_store) {

      store = _store;
      var actionSubject$ = new Subject();
      var stateSubject$ = new Subject();
      var action$ = actionSubject$.asObservable().pipe(observeOn(uniqueQueueScheduler));
      var state$ = new StateObservable(stateSubject$.pipe(observeOn(uniqueQueueScheduler)), store.getState());
      var result$ = epic$.pipe(map(function (epic) {
        var output$ = epic(action$, state$, options.dependencies);

        if (!output$) {
          throw new TypeError("Your root Epic \"" + (epic.name || '<anonymous>') + "\" does not return a stream. Double check you're not missing a return statement!");
        }

        return output$;
      }), mergeMap(function (output$) {
        return from$1(output$).pipe(subscribeOn(uniqueQueueScheduler), observeOn(uniqueQueueScheduler));
      }));
      result$.subscribe(store.dispatch);
      return function (next) {
        return function (action) {
          // Downstream middleware gets the action first,
          // which includes their reducers, so state is
          // updated before epics receive the action
          var result = next(action); // It's important to update the state$ before we emit
          // the action because otherwise it would be stale

          stateSubject$.next(store.getState());
          actionSubject$.next(action);
          return result;
        };
      };
    };

    epicMiddleware.run = function (rootEpic) {

      epic$.next(rootEpic);
    };

    return epicMiddleware;
  }

  /**
    Merges all epics into a single one.
   */

  function combineEpics() {
    var epics = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      epics[_i] = arguments[_i];
    }

    var merger = function () {
      var args = [];

      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }

      return merge$1.apply(void 0, epics.map(function (epic) {
        var output$ = epic.apply(void 0, args);

        if (!output$) {
          throw new TypeError("combineEpics: one of the provided Epics \"" + (epic.name || '<anonymous>') + "\" does not return a stream. Double check you're not missing a return statement!");
        }

        return output$;
      }));
    }; // Technically the `name` property on Function's are supposed to be read-only.
    // While some JS runtimes allow it anyway (so this is useful in debugging)
    // some actually throw an exception when you attempt to do so.


    try {
      Object.defineProperty(merger, 'name', {
        value: "combineEpics(" + epics.map(function (epic) {
          return epic.name || '<anonymous>';
        }).join(', ') + ")"
      });
    } catch (e) {}

    return merger;
  }

  var keyHasType = function (type, key) {
    return type === key || typeof key === 'function' && type === key.toString();
  };
  /**
   * Inferring the types of this is a bit challenging, and only works in newer
   * versions of TypeScript.
   *
   * @param ...types One or more Redux action types you want to filter for, variadic.
   */


  function ofType() {
    var types = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      types[_i] = arguments[_i];
    }

    var len = types.length;

    return filter$1(len === 1 ? function (action) {
      return keyHasType(action.type, types[0]);
    } : function (action) {
      for (var i = 0; i < len; i++) {
        if (keyHasType(action.type, types[i])) {
          return true;
        }
      }

      return false;
    });
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function dragOk(status) {
    return [EditingStatus.SORTING_COMPONENT, EditingStatus.PLACING_NEW_COMPONENT, EditingStatus.PLACING_DETACHED_ASSET, EditingStatus.PLACING_DETACHED_COMPONENT, EditingStatus.UPLOAD_ASSET_FROM_DESKTOP].includes(status);
  }
  function unwrapEvent(event) {
    var _ref, _event$originalEvent;

    // @ts-ignore
    return (_ref = (_event$originalEvent = event === null || event === void 0 ? void 0 : event.originalEvent) !== null && _event$originalEvent !== void 0 ? _event$originalEvent : event === null || event === void 0 ? void 0 : event.nativeEvent) !== null && _ref !== void 0 ? _ref : event;
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const contentReady = /*#__PURE__*/createAction('content_ready');
  const setDropPosition = /*#__PURE__*/createAction('set_drop_position');
  const computedDragEnd = /*#__PURE__*/createAction('computed_dragend');
  const computedDragOver = /*#__PURE__*/createAction('computed_dragover');
  const iceZoneSelected = /*#__PURE__*/createAction('ice_zone_selected');
  const editComponentInline = /*#__PURE__*/createAction('edit_component_inline');
  const exitComponentInlineEdit = /*#__PURE__*/createAction('exit_component_inline_edit');
  const setEditMode = /*#__PURE__*/createAction('set_edit_mode');
  const startListening = /*#__PURE__*/createAction('start_listening');
  const scrolling = /*#__PURE__*/createAction('scrolling');
  const scrollingStopped = /*#__PURE__*/createAction('scrolling_stopped');
  const dropzoneEnter = /*#__PURE__*/createAction('drop_zone_enter');
  const dropzoneLeave = /*#__PURE__*/createAction('drop_zone_leave');
  const documentDragOver = /*#__PURE__*/createAction('document:dragover');
  const documentDragLeave = /*#__PURE__*/createAction('document:dragleave');
  const documentDrop = /*#__PURE__*/createAction('document:drop');
  const documentDragEnd = /*#__PURE__*/createAction('document:dragend');
  const desktopAssetDragStarted = /*#__PURE__*/createAction('desktop_asset_drag_started');
  const desktopAssetDragEnded = /*#__PURE__*/createAction('desktop_asset_drag_ended');
  const setEditingStatus = /*#__PURE__*/createAction('set_editing_status');

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const clearAndListen$ = new Subject();
  const escape$ = typeof document === 'undefined' ? new Subject() : fromEvent(document, 'keydown').pipe(filter$1(e => e.key === 'Escape'));
  let active = false;
  let dragover$;

  const getDragOver = () => dragover$;

  let killSignal$;
  let scrolling$;
  function initializeDragSubjects(state$) {
    if (!active) {
      active = true;
      killSignal$ = new Subject();
      dragover$ = new Subject();
      scrolling$ = fromEvent(document, 'scroll').pipe(takeUntil(killSignal$), share());
    }

    return merge$1(dragover$.pipe(throttleTime(100), map(computedDragOver)), scrolling$.pipe(throttleTime(200), withLatestFrom(state$), filter$1(([, state]) => {
      var _state$dragContext;

      return !((_state$dragContext = state.dragContext) !== null && _state$dragContext !== void 0 && _state$dragContext.scrolling);
    }), map(() => scrolling())), // Scrolling ended
    scrolling$.pipe( // Emit values from scroll$ only after 200ms have
    // passed without another source emission should give
    // us the end of scrolling.
    debounceTime(200), map(() => scrollingStopped())));
  }
  function destroyDragSubjects() {
    if (active) {
      active = false; // scrolling$ is terminated by killSignal$

      killSignal$.next();
      killSignal$.complete();
      killSignal$.unsubscribe();
      killSignal$ = null;
      dragover$.complete();
      dragover$.unsubscribe();
      dragover$ = null;
    }
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function initTinyMCE(record, validations, rteSetup) {
    var _rteSetup$tinymceOpti, _rteSetup$tinymceOpti2;

    const dispatch$ = new Subject();
    const {
      field
    } = getReferentialEntries(record.iceIds[0]);
    const type = field === null || field === void 0 ? void 0 : field.type;
    const elementDisplay = $(record.element).css('display');

    if (elementDisplay === 'inline') {
      $(record.element).css('display', 'inline-block');
    }

    const openEditForm = () => {
      post({
        type: showEditDialog.type,
        payload: {
          selectedFields: [field.id]
        }
      });
    };

    const controlPropsMap = {
      enableSpellCheck: 'browser_spellcheck',
      forceRootBlockPTag: 'forced_root_block'
    };
    const controlProps = {};
    Object.keys(controlPropsMap).forEach(key => {
      var _field$properties;

      if ((_field$properties = field.properties) !== null && _field$properties !== void 0 && _field$properties[key]) {
        const propKey = controlPropsMap[key];
        controlProps[propKey] = field.properties[key].value;
      }
    });
    const external = { ...(rteSetup === null || rteSetup === void 0 ? void 0 : (_rteSetup$tinymceOpti = rteSetup.tinymceOptions) === null || _rteSetup$tinymceOpti === void 0 ? void 0 : _rteSetup$tinymceOpti.external_plugins),
      acecode: '/studio/static-assets/js/tinymce-plugins/ace/plugin.min.js',
      editform: '/studio/static-assets/js/tinymce-plugins/editform/plugin.js',
      craftercms_paste_extension: '/studio/static-assets/js/tinymce-plugins/craftercms_paste_extension/plugin.js'
    };
    const $element = $(record.element);
    $element.removeClass(emptyFieldClass);
    window.tinymce.init({
      mode: 'none',
      target: record.element,
      // For some reason this is not working.
      // body_class: 'craftercms-rich-text-editor',
      plugins: ['paste editform', rteSetup === null || rteSetup === void 0 ? void 0 : (_rteSetup$tinymceOpti2 = rteSetup.tinymceOptions) === null || _rteSetup$tinymceOpti2 === void 0 ? void 0 : _rteSetup$tinymceOpti2.plugins].filter(Boolean).join(' '),
      // 'editform' & 'paste' plugins will always be loaded
      paste_as_text: type !== 'html',
      paste_data_images: type === 'html',

      paste_preprocess(plugin, args) {
        var _window$tinymce$activ;

        (_window$tinymce$activ = window.tinymce.activeEditor.plugins.craftercms_paste_extension) === null || _window$tinymce$activ === void 0 ? void 0 : _window$tinymce$activ.paste_preprocess(plugin, args);
      },

      paste_postprocess(plugin, args) {
        var _window$tinymce$activ2;

        (_window$tinymce$activ2 = window.tinymce.activeEditor.plugins.craftercms_paste_extension) === null || _window$tinymce$activ2 === void 0 ? void 0 : _window$tinymce$activ2.paste_postprocess(plugin, args);
      },

      toolbar: type === 'html',
      menubar: false,
      inline: true,
      base_url: '/studio/static-assets/modules/editors/tinymce/v5/tinymce',
      suffix: '.min',
      external_plugins: external,
      code_editor_inline: false,
      skin: window.matchMedia('(prefers-color-scheme: dark)').matches ? 'oxide-dark' : 'oxide',

      setup(editor) {
        const pluginManager = window.tinymce.util.Tools.resolve('tinymce.PluginManager');
        editor.on('init', function () {
          let changed = false;
          let originalContent = getContent();
          editor.focus(false);
          editor.selection.select(editor.getBody(), true);
          editor.selection.collapse(false); // In some cases the 'blur' event is getting caught somewhere along
          // the way. Focusout seems to be more reliable.

          editor.on('focusout', e => {
            var _e$relatedTarget;

            if (!((_e$relatedTarget = e.relatedTarget) !== null && _e$relatedTarget !== void 0 && _e$relatedTarget.closest('.tox-tinymce'))) {
              if (validations !== null && validations !== void 0 && validations.required && !getContent().trim()) {
                post(validationMessage({
                  id: 'required',
                  level: 'required',
                  values: {
                    field: record.label
                  }
                }));
                editor.setContent(originalContent);
              } else {
                save();
              }

              e.stopImmediatePropagation();
              cancel();
            }
          });
          editor.once('change', () => {
            changed = true;
          });
          editor.once('external_change', () => {
            changed = true;
          });
          editor.on('keydown', e => {
            if (e.key === 'Escape') {
              e.stopImmediatePropagation();
              editor.setContent(originalContent);
              cancel();
            } else if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
              editor.fire('focusout');
            } else if (validations !== null && validations !== void 0 && validations.maxLength && // TODO: Check/improve regex
            /[a-zA-Z0-9-_ ]/.test(String.fromCharCode(e.keyCode)) && getContent().length + 1 > parseInt(validations.maxLength.value)) {
              post(validationMessage({
                id: 'maxLength',
                level: 'required',
                values: {
                  maxLength: validations.maxLength.value
                }
              }));
              e.stopPropagation();
              return false;
            }
          });

          function save() {
            const content = getContent();

            if (changed) {
              updateField(record.modelId, record.fieldId[0], record.index, content);
            }
          }

          function getContent() {
            return type === 'html' ? editor.getContent() : editor.getContent({
              format: 'text'
            });
          }

          function destroyEditor() {
            editor.destroy(false);
          }

          function cancel() {
            const content = getContent();
            destroyEditor(); // In case the user did some text bolding or other formatting which won't
            // be honoured on plain text, revert the content to the edited plain text
            // version of the input.

            changed && type === 'text' && $element.html(content);

            if (elementDisplay === 'inline') {
              $element.css('display', '');
            }

            if ($element.html().trim() === '') {
              $element.addClass(emptyFieldClass);
            } // The timeout prevents clicking the edit menu to be shown when clicking out of an RTE
            // with the intention to exit editing.


            setTimeout(() => {
              dispatch$.next({
                type: exitComponentInlineEdit.type
              });
              dispatch$.complete();
              dispatch$.unsubscribe();
            }, 150);
          }

          if (type !== 'html') {
            // For plain text fields, remove keyboard shortcuts for formatting text
            // meta is used in tinymce for Ctrl (PC) and Command (macOS)
            // https://www.tiny.cloud/docs/advanced/keyboard-shortcuts/#editorkeyboardshortcuts
            editor.addShortcut('meta+b', '', '');
            editor.addShortcut('meta+i', '', '');
            editor.addShortcut('meta+u', '', '');
          }
        });
        editor.on('keydown', e => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
            e.preventDefault();
          }
        });
        editor.on('DblClick', e => {
          e.stopPropagation();

          if (e.target.nodeName === 'IMG') {
            window.tinymce.activeEditor.execCommand('mceImage');
          }
        });
        editor.on('click', e => {
          e.stopPropagation();
        }); // No point in waiting for `craftercms_tinymce_hooks` if the hook won't be loaded at all.

        external.craftercms_tinymce_hooks && pluginManager.waitFor('craftercms_tinymce_hooks', () => {
          const hooks = pluginManager.get('craftercms_tinymce_hooks');

          if (hooks) {
            var _pluginManager$get$se, _pluginManager$get;

            (_pluginManager$get$se = (_pluginManager$get = pluginManager.get('craftercms_tinymce_hooks')).setup) === null || _pluginManager$get$se === void 0 ? void 0 : _pluginManager$get$se.call(_pluginManager$get, editor);
          } else {
            console.error("The `craftercms_tinymce_hooks` was configured to be loaded but didn't load. Check the path is correct in the rte configuration file.");
          }
        }, 'loaded');
      },

      ...(rteSetup !== null && rteSetup !== void 0 && rteSetup.tinymceOptions ? { ...reversePluckProps(rteSetup.tinymceOptions, 'target', // Target can't be changed
        'inline', // Not using inline view doesn't behave well on pageBuilder, this setting shouldn't be changed.
        'setup', 'base_url', 'encoding', 'autosave_ask_before_unload', // Autosave options are removed since it is not supported in control.
        'autosave_interval', 'autosave_prefix', 'autosave_restore_when_empty', 'autosave_retention', 'file_picker_callback', // No file picker is set by default, and functions are not supported in config file.
        'height', // Height is set to the size of content
        'file_picker_callback', // Files/images handlers currently not supported
        'paste_postprocess', 'images_upload_handler', 'code_editor_inline', 'plugins' // Considered/used above, mixed with our options
        )
      } : {}),
      ...controlProps,
      openEditForm
    });
    return dispatch$.pipe(startWith({
      type: editComponentInline.type
    }));
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const epic = combineEpics( // region mouseover, mouseleave
  (action$, state$) => action$.pipe(ofType('mouseover', 'mouseleave'), withLatestFrom(state$), filter$1(args => args[1].status === EditingStatus.LISTENING), tap(([action]) => action.payload.event.stopPropagation()), ignoreElements()), // endregion
  // region dragstart
  (action$, state$) => action$.pipe(ofType('dragstart'), withLatestFrom(state$), switchMap(([action, state]) => {
    var _state$draggable;

    const {
      payload: {
        event,
        record
      }
    } = action;
    const iceId = (_state$draggable = state.draggable) === null || _state$draggable === void 0 ? void 0 : _state$draggable[record.id];

    if (nullOrUndefined(iceId)) {
      // When the drag starts on a child element of the item, it passes through here.
      console.error('No ice id found for this drag instance.', record, state.draggable);
    } else if (not(iceId)) {
      // Items that browser make draggable by default (images, etc).
      console.warn("Element is draggable but wasn't set draggable by craftercms");
    } else {
      post(instanceDragBegun(iceId));

      if (event) {
        event.stopPropagation();
        const e = unwrapEvent(event);
        e.dataTransfer.setData('text/plain', `${record.id}`);
        e.dataTransfer.setDragImage(document.querySelector('.craftercms-dragged-element'), 20, 20);
      }

      $('html').addClass(dragAndDropActiveClass);
      return initializeDragSubjects(state$);
    }

    return NEVER;
  })), // endregion
  // region dragover
  (action$, state$) => action$.pipe(ofType('dragover'), withLatestFrom(state$), tap(([action, state]) => {
    var _state$dragContext;

    const {
      payload: {
        event,
        record
      }
    } = action;
    let {
      element
    } = record;

    if (dragOk(state.status) && !((_state$dragContext = state.dragContext) !== null && _state$dragContext !== void 0 && _state$dragContext.scrolling) && state.dragContext.players.includes(element)) {
      event.preventDefault();
      event.stopPropagation();
      getDragOver().next({
        event,
        record
      });
    }
  }), ignoreElements()), action$ => action$.pipe(ofType(documentDragOver.type), tap(({
    payload: {
      event
    }
  }) => event.preventDefault()), ignoreElements()), // endregion
  // region dragleave
  (action$, state$) => action$.pipe(ofType('dragleave', documentDragLeave.type), withLatestFrom(state$), filter$1(([, state]) => state.status === EditingStatus.UPLOAD_ASSET_FROM_DESKTOP), switchMap(() => interval(100).pipe(mapTo(desktopAssetDragEnded()), takeUntil(action$.pipe(ofType(documentDragOver.type, 'dragover')))))), // endregion
  // region drop, documentDrop
  (action$, state$) => {
    return action$.pipe(ofType('drop'), withLatestFrom(state$), filter$1(([, state]) => dragOk(state.status) && !state.dragContext.invalidDrop), switchMap(([action, state]) => {
      const {
        payload: {
          event,
          record
        }
      } = action;
      event.preventDefault();
      event.stopPropagation();
      const status = state.status;
      const dragContext = state.dragContext;

      switch (status) {
        case EditingStatus.PLACING_DETACHED_ASSET:
          {
            const {
              dropZone
            } = dragContext;

            if (dropZone && dragContext.inZone) {
              const record = getById(dropZone.iceId);
              updateField(record.modelId, record.fieldId, record.index, dragContext.dragged.path);
            }

            break;
          }

        case EditingStatus.SORTING_COMPONENT:
          {
            if (notNullOrUndefined(dragContext.targetIndex)) {
              moveComponent(dragContext); // return of({ type: 'move_component' });
            }

            break;
          }

        case EditingStatus.PLACING_NEW_COMPONENT:
          {
            if (notNullOrUndefined(dragContext.targetIndex)) {
              const {
                targetIndex,
                contentType,
                dropZone
              } = dragContext;
              const record = getById(dropZone.iceId);
              setTimeout(() => {
                insertComponent(record.modelId, record.fieldId, record.fieldId.includes('.') ? `${record.index}.${targetIndex}` : targetIndex, contentType);
              }); // return of({ type: 'insert_component' });
            }

            break;
          }

        case EditingStatus.PLACING_DETACHED_COMPONENT:
          {
            if (notNullOrUndefined(dragContext.targetIndex)) {
              const {
                targetIndex,
                instance,
                dropZone
              } = dragContext;
              const record = getById(dropZone.iceId);
              setTimeout(() => {
                insertInstance(record.modelId, record.fieldId, record.fieldId.includes('.') ? `${record.index}.${targetIndex}` : targetIndex, instance);
              }); // return of({ type: 'insert_instance' });
            }

            break;
          }

        case EditingStatus.UPLOAD_ASSET_FROM_DESKTOP:
          {
            if (dragContext.inZone) {
              const file = unwrapEvent(event).dataTransfer.files[0];
              const stream$ = new Subject();
              const reader = new FileReader();

              reader.onload = (aImg => event => {
                post(desktopAssetDrop.type, {
                  dataUrl: event.target.result,
                  name: file.name,
                  type: file.type,
                  record: reversePluckProps(record, 'element')
                });
                aImg.src = event.target.result; // Timeout gives the browser a chance to render the image so later rect
                // calculations are working with the updated paint.

                setTimeout(() => {
                  stream$.next({
                    type: desktopAssetUploadStarted.type,
                    payload: {
                      record
                    }
                  });
                  stream$.next({
                    type: desktopAssetDragEnded.type
                  });
                  stream$.complete();
                  stream$.unsubscribe();
                });
              })(record.element);

              reader.readAsDataURL(file);
              return stream$;
            } else {
              return of(desktopAssetDragEnded());
            }
          }
      }

      return NEVER;
    }));
  }, (action$, state$) => action$.pipe(ofType(documentDrop.type), withLatestFrom(state$), switchMap(([action, state]) => {
    const {
      payload: {
        event
      }
    } = action;
    const status = state.status;
    event.preventDefault();
    event.stopPropagation();

    switch (status) {
      case EditingStatus.UPLOAD_ASSET_FROM_DESKTOP:
        return of(desktopAssetDragEnded());

      case EditingStatus.SORTING_COMPONENT:
      case EditingStatus.PLACING_NEW_COMPONENT:
        {
          if (status === EditingStatus.SORTING_COMPONENT) {
            post(instanceDragEnded());
          }

          return [computedDragEnd(), startListening()];
        }

      default:
        return NEVER;
    }
  })), // endregion
  // region dragend, documentDragEnd
  (action$, state$) => {
    return action$.pipe(ofType('dragend'), withLatestFrom(state$), filter$1(([, state]) => dragOk(state.status)), switchMap(([action]) => {
      const {
        event
      } = action.payload;
      event.preventDefault();
      event.stopPropagation();
      post(instanceDragEnded());
      return of(computedDragEnd());
    }));
  }, action$ => action$.pipe(ofType(documentDragEnd.type), tap(({
    payload
  }) => payload.event.preventDefault()), ignoreElements()), // endregion
  // region assetDragEnded, componentDragEnded, componentInstanceDragEnded, desktopAssetDragEnded
  action$ => action$.pipe(ofType(assetDragEnded.type, componentDragEnded.type, componentInstanceDragEnded.type, desktopAssetDragEnded.type), map(() => computedDragEnd())), // endregion
  // region click
  (action$, state$) => action$.pipe(ofType('click'), withLatestFrom(state$), filter$1(([, state]) => state.highlightMode === HighlightMode.ALL && state.status === EditingStatus.LISTENING || state.highlightMode === HighlightMode.MOVE_TARGETS && state.status === EditingStatus.LISTENING || state.highlightMode === HighlightMode.MOVE_TARGETS && state.status === EditingStatus.FIELD_SELECTED), switchMap(([action, state]) => {
    const {
      record,
      event
    } = action.payload;

    if (state.highlightMode === HighlightMode.ALL && state.status === EditingStatus.LISTENING) {
      ({
        modelId: null,
        fieldId: [],
        index: null,
        coordinates: {
          x: event.clientX,
          y: event.clientY
        }
      });

      if (getById(record.iceIds[0]).recordType === 'node-selector-item') {
        // When selecting the item on a node-selector the desired edit will be the item itself.
        // The following will send the component model id instead of the item model id
        extractCollectionItem(getCachedModel(record.modelId), record.fieldId[0], record.index);
      }

      const {
        field
      } = getReferentialEntries(record.iceIds[0]);
      const validations = field === null || field === void 0 ? void 0 : field.validations;
      const type = field === null || field === void 0 ? void 0 : field.type;

      switch (type) {
        case 'html':
        case 'text':
        case 'textarea':
          {
            var _validations$readOnly;

            if (!window.tinymce) {
              alert('Looks like tinymce is not added on the page. ' + 'Please add tinymce on to the page to enable editing.');
            } else if (not(validations === null || validations === void 0 ? void 0 : (_validations$readOnly = validations.readOnly) === null || _validations$readOnly === void 0 ? void 0 : _validations$readOnly.value)) {
              var _field$properties$rte, _field$properties, _field$properties$rte2, _ref, _state$rteConfig$setu;

              const setupId = (_field$properties$rte = (_field$properties = field.properties) === null || _field$properties === void 0 ? void 0 : (_field$properties$rte2 = _field$properties.rteConfiguration) === null || _field$properties$rte2 === void 0 ? void 0 : _field$properties$rte2.value) !== null && _field$properties$rte !== void 0 ? _field$properties$rte : 'generic';
              const setup = (_ref = (_state$rteConfig$setu = state.rteConfig[setupId]) !== null && _state$rteConfig$setu !== void 0 ? _state$rteConfig$setu : Object.values(state.rteConfig)[0]) !== null && _ref !== void 0 ? _ref : {}; // Only pass rte setup to html type, text/textarea (plaintext) controls won't show full rich-text-editing.

              return initTinyMCE(record, validations, type === 'html' ? setup : {});
            }

            break;
          }

        default:
          {
            return merge$1(escape$.pipe(takeUntil(clearAndListen$), tap(() => post(clearSelectedZones.type)), map(() => startListening()), take(1)), of(setEditingStatus({
              status: EditingStatus.FIELD_SELECTED
            })));
          }
      }
    } else if (state.highlightMode === HighlightMode.MOVE_TARGETS && state.status === EditingStatus.LISTENING) {
      const movableRecordId = getMovableParentRecord(record.iceIds[0]);

      if (notNullOrUndefined(movableRecordId)) {
        // Inform host of the field selection
        // post();
        // By this point element is already highlighted. We just need to freeze
        // and change mode to reveal the move/sort options.
        return merge$1(escape$.pipe(takeUntil(clearAndListen$), // TODO: stop & map to startListening when any pivoting action occurs
        // takeUntil(action$.pipe(ofType(componentInstanceDragStarted.type))),
        tap(() => post(clearSelectedZones.type)), map(() => startListening()), take(1)), of(setEditingStatus({
          status: EditingStatus.FIELD_SELECTED
        })));
      }
    } else if (state.status === EditingStatus.FIELD_SELECTED && state.highlightMode === HighlightMode.MOVE_TARGETS) {
      const movableRecordId = getMovableParentRecord(record.iceIds[0]);

      if (state.highlighted[movableRecordId] === void 0) {
        post(clearSelectedZones.type);
        return of(startListening());
      }
    } // Note: Returning NEVER will unsubscribe from any previous stream returned on a prior click.


    return NEVER;
  })), // endregion
  // region computedDragEnd
  action$ => action$.pipe(ofType(computedDragEnd.type), tap(() => {
    $('html').removeClass(dragAndDropActiveClass);
    destroyDragSubjects();
  }), ignoreElements()), // endregion
  // region desktopAssetUploadComplete
  action$ => {
    return action$.pipe(ofType(desktopAssetUploadComplete.type), tap(action => {
      const {
        record,
        path
      } = action.payload;
      updateField(record.modelId, record.fieldId[0], record.index, path);
    }), ignoreElements());
  }, // endregion
  // region contentTypeDropTargetsRequest
  action$ => {
    return action$.pipe(ofType(contentTypeDropTargetsRequest.type), tap(action => {
      const {
        contentTypeId
      } = action.payload;
      const dropTargets = getContentTypeDropTargets(contentTypeId).map(item => {
        let {
          elementRecordId
        } = compileDropZone(item.id);
        let highlight = getHoverData(elementRecordId);
        return {
          modelId: item.modelId,
          fieldId: item.fieldId,
          label: highlight.label,
          id: item.id,
          contentTypeId
        };
      });
      post(contentTypeDropTargetsResponse({
        contentTypeId,
        dropTargets
      }));
    }), ignoreElements());
  }, // endregion
  // region startListening
  action$ => {
    return action$.pipe(ofType(startListening.type), tap(() => post(clearSelectedZones.type)), ignoreElements());
  }, // endregion
  // region trashed
  action$ => {
    // onDrop doesn't execute when trashing on host side
    // Consider behaviour when running Host Guest-side
    return action$.pipe(ofType(trashed.type), tap(action => {
      const {
        iceId
      } = action.payload;
      let {
        modelId,
        fieldId,
        index
      } = getById(iceId);
      deleteItem(modelId, fieldId, index);
      post(instanceDragEnded());
    }), // There's a raise condition where sometimes the dragend is
    // fired and sometimes is not upon dropping on the rubbish bin.
    // Manually firing here may incur in double firing of computed_dragend
    // in those occasions.
    mapTo(computedDragEnd()));
  }, // endregion
  // region dropzoneEnter
  (action$, state$) => {
    // onDrop doesn't execute when trashing on host side
    // Consider behaviour when running Host Guest-side
    return action$.pipe(ofType(dropzoneEnter.type), withLatestFrom(state$), tap(([action, state]) => {
      const {
        elementRecordId
      } = action.payload;
      const {
        validations
      } = state.dragContext.dropZones.find(dropZone => dropZone.elementRecordId === elementRecordId);
      Object.values(validations).forEach(validation => {
        post(validationMessage(validation));
      });
    }), ignoreElements());
  }, // endregion
  // region dropzoneLeave
  (action$, state$) => {
    return action$.pipe(ofType(dropzoneLeave.type), withLatestFrom(state$), tap(([action, state]) => {
      if (!state.dragContext) {
        return;
      }

      const {
        elementRecordId
      } = action.payload;
      const {
        validations
      } = state.dragContext.dropZones.find(dropZone => dropZone.elementRecordId === elementRecordId);

      if (validations.minCount) {
        post({
          type: instanceDragEnded.type
        });
      }

      Object.values(validations).forEach(validation => {
        // We dont want to show a validation message for maxCount on Leaving Dropzone
        if (validations.maxCount) {
          return;
        }

        post(validationMessage(validation));
      });
    }), ignoreElements());
  }, // endregion
  // region componentDragStarted
  (action$, state$) => action$.pipe(ofType(componentDragStarted.type), withLatestFrom(state$), switchMap(([, state]) => {
    const contentType = state.dragContext.contentType;

    if (nullOrUndefined(contentType.id)) {
      console.error('No contentTypeId found for this drag instance.');
    } else {
      if (state.dragContext.dropZones.length === 0) {
        post(validationMessage({
          id: 'dropTargetsNotFound',
          level: 'info',
          values: {
            contentType: state.dragContext.contentType.name
          }
        }));
      } else {
        $('html').addClass(dragAndDropActiveClass);
        return initializeDragSubjects(state$);
      }
    }

    return NEVER;
  })), // endregion
  // region componentInstanceDragStarted
  (action$, state$) => {
    return action$.pipe(ofType(componentInstanceDragStarted.type), withLatestFrom(state$), switchMap(([, state]) => {
      if (nullOrUndefined(state.dragContext.instance.craftercms.contentTypeId)) {
        console.error('No contentTypeId found for this drag instance.');
      } else {
        if (state.dragContext.dropZones.length === 0) {
          post(validationMessage({
            id: 'dropTargetsNotFound',
            level: 'info',
            values: {
              contentType: state.dragContext.contentType.name
            }
          }));
        } else {
          $('html').addClass(dragAndDropActiveClass);
          return initializeDragSubjects(state$);
        }
      }

      return NEVER;
    }));
  }, // endregion
  // region assetDragStarted
  (action$, state$) => {
    return action$.pipe(ofType(assetDragStarted.type), withLatestFrom(state$), switchMap(([, state]) => {
      if (nullOrUndefined(state.dragContext.dragged.path)) {
        console.error('No path found for this drag asset.');
      } else {
        return initializeDragSubjects(state$);
      }

      return NEVER;
    }));
  }, // endregion
  // region desktopAssetDragStarted
  (action$, state$) => {
    return action$.pipe(ofType(desktopAssetDragStarted.type), withLatestFrom(state$), switchMap(([, state]) => {
      if (nullOrUndefined(state.dragContext.dragged)) {
        console.error('No file found for this drag asset.');
      } else {
        return initializeDragSubjects(state$);
      }

      return NEVER;
    }));
  }, // endregion
  // region contentTreeFieldSelected
  action$ => {
    return action$.pipe(ofType(contentTreeFieldSelected.type), switchMap(action => {
      const {
        iceProps,
        scrollElement,
        name
      } = action.payload;
      const element = getElementFromICEProps(iceProps.modelId, iceProps.fieldId, iceProps.index);

      if (scrollToElement(element, scrollElement)) {
        return escape$.pipe(takeUntil(clearAndListen$), map(() => clearContentTreeFieldSelected()), take(1));
      } else {
        post(validationMessage({
          id: 'registerNotFound',
          level: 'suggestion',
          values: {
            name
          }
        }));
        return NEVER;
      }
    }));
  }, // endregion
  // region contentTreeSwitchFieldInstance
  (action$, state$) => {
    return action$.pipe(ofType(contentTreeSwitchFieldInstance.type), withLatestFrom(state$), tap(([action, state]) => {
      const {
        scrollElement
      } = action.payload;
      let registryEntryId = state.fieldSwitcher.registryEntryIds[state.fieldSwitcher.currentElement];
      scrollToElement(get(registryEntryId).element, scrollElement);
    }), ignoreElements());
  } // endregion
  );

  const moveComponent = dragContext => {
    let {
      dragged,
      dropZone,
      dropZones,
      targetIndex
    } = dragContext,
        record = dragged,
        draggedElementIndex = record.index,
        originDropZone = dropZones.find(dropZone => dropZone.origin),
        currentDZ = dropZone.element;

    if (typeof draggedElementIndex === 'string') {
      // If the index is a string, it's a nested index with dot notation.
      // At this point, we only care for the last index piece, which is
      // the index of this item in the collection that's being manipulated.
      draggedElementIndex = parseInt(draggedElementIndex.substr(draggedElementIndex.lastIndexOf('.') + 1), 10);
    }

    const containerRecord = getById(originDropZone.iceId); // Determine whether the component is to be sorted or moved.

    if (currentDZ === originDropZone.element) {
      // Same drop zone: Sort identified
      // If moving the item down the array of items, need to account
      // for all the originally subsequent items shifting up.
      if (draggedElementIndex < targetIndex) {
        // Hence the final target index in reality is
        // the drop marker's index minus 1
        --targetIndex;
      }

      if (draggedElementIndex !== targetIndex) {
        setTimeout(() => {
          sortItem(containerRecord.modelId, containerRecord.fieldId, containerRecord.fieldId.includes('.') ? `${containerRecord.index}.${draggedElementIndex}` : draggedElementIndex, containerRecord.fieldId.includes('.') ? `${containerRecord.index}.${targetIndex}` : targetIndex);
        });
      }
    } else {
      // Different drop zone: Move identified
      const rec = getById(dropZone.iceId); // Chrome didn't trigger the dragend event
      // without the set timeout.

      setTimeout(() => {
        moveItem(containerRecord.modelId, containerRecord.fieldId, containerRecord.fieldId.includes('.') ? `${containerRecord.index}.${draggedElementIndex}` : draggedElementIndex, rec.modelId, rec.fieldId, rec.fieldId.includes('.') ? `${rec.index}.${targetIndex}` : targetIndex);
      }, 20);
    }
  };

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const initialState = {
    dragContext: null,
    draggable: {},
    editable: {},
    highlighted: {},
    status: EditingStatus.LISTENING,
    editMode: false,
    highlightMode: HighlightMode.ALL,
    uploading: {},
    models: {},
    contentTypes: {},
    hostCheckedIn: false,
    rteConfig: {},
    activeSite: '',
    editModePadding: false
  };

  function createReducer(initialState, actionsMap) {
    return (state = initialState, action) => {
      var _caseReducer;

      const caseReducer = actionsMap[action.type];
      return (_caseReducer = caseReducer === null || caseReducer === void 0 ? void 0 : caseReducer(state, action)) !== null && _caseReducer !== void 0 ? _caseReducer : state;
    };
  }

  const resetState = state => ({ ...state,
    status: EditingStatus.LISTENING,
    draggable: {},
    highlighted: {},
    dragContext: null
  });

  const reducer = createReducer(initialState, {
    // region dblclick
    dblclick: (state, {
      payload: {
        record
      }
    }) => state.status === EditingStatus.LISTENING ? { ...state,
      status: EditingStatus.EDITING_COMPONENT_INLINE,
      editable: {
        [record.id]: record
      }
    } : state,
    // endregion
    // region mouseover
    // TODO: Not pure.
    mouseover: (state, action) => {
      const {
        record
      } = action.payload;

      if (state.status === EditingStatus.LISTENING) {
        const {
          highlightMode
        } = state;

        if (highlightMode === HighlightMode.ALL) {
          const highlight = getHoverData(record.id);
          return { ...state,
            highlighted: {
              [record.id]: highlight
            }
          };
        } else if (highlightMode === HighlightMode.MOVE_TARGETS) {
          const iceId = record.iceIds[0];
          const movableRecordId = getMovableParentRecord(iceId);

          if (notNullOrUndefined(movableRecordId)) {
            const elementId = iceId === movableRecordId ? record.id : fromICEId(movableRecordId).id;
            const draggable = getDraggable(elementId);
            const highlight = getHoverData( // If (iceId == movableRecordId) the current record is already
            // the one to show the highlight on.
            elementId);
            return { ...state,
              highlighted: {
                [movableRecordId]: highlight
              },
              draggable: draggable ? {
                [elementId]: draggable
              } : state.draggable
            };
          }
        }
      }

      return state;
    },
    // endregion
    // region mouseleave
    mouseleave: state => state.status === EditingStatus.LISTENING ? { ...state,
      highlighted: {},
      draggable: {}
    } : state,
    // endregion
    // region dragstart
    // TODO: Not pure.
    dragstart: (state, action) => {
      var _state$draggable;

      const {
        record
      } = action.payload; // onMouseOver pre-populates the draggable record

      const iceId = (_state$draggable = state.draggable) === null || _state$draggable === void 0 ? void 0 : _state$draggable[record.id]; // Items that browser make draggable by default (images, etc) may not have an ice id

      if (notNullOrUndefined(iceId)) {
        const dropTargets = getRecordDropTargets(iceId);
        const validationsLookup = runDropTargetsValidations(dropTargets);
        const {
          players,
          siblings,
          containers,
          dropZones
        } = getDragContextFromDropTargets(dropTargets, validationsLookup, record);
        const highlighted = getHighlighted(dropZones);
        return { ...state,
          highlighted,
          status: EditingStatus.SORTING_COMPONENT,
          dragContext: { ...state.dragContext,
            players,
            siblings,
            dropZones,
            containers,
            inZone: false,
            targetIndex: null,
            dragged: getById(iceId)
          }
        };
      } else {
        return state;
      }
    },
    // endregion
    // region dragleave
    dragleave: (state, action) => {
      var _state$dragContext, _state$dragContext$dr;

      const leavingDropZone = !((_state$dragContext = state.dragContext) !== null && _state$dragContext !== void 0 && (_state$dragContext$dr = _state$dragContext.dropZone) !== null && _state$dragContext$dr !== void 0 && _state$dragContext$dr.element.contains(action.payload.event.relatedTarget));
      return dragOk(state.status) ? { ...state,
        dragContext: { ...state.dragContext,
          over: null,
          inZone: false,
          targetIndex: null,
          dropZone: leavingDropZone ? null : state.dragContext.dropZone
        }
      } : state;
    },
    // endregion
    // region computedDragOver
    // TODO: Not pure.
    [computedDragOver.type]: (state, action) => {
      if (state.dragContext.scrolling) {
        return state;
      } else {
        const dragContext = state.dragContext;
        const {
          record,
          event
        } = action.payload;
        const element = record.element;

        if (dragContext.players.includes(element)) {
          let {
            next,
            prev
          } = // No point finding siblings for the drop zone element
          dragContext.containers.includes(element) ? {
            next: null,
            prev: null
          } : getSiblingRects(record.id);
          return { ...state,
            dragContext: { ...dragContext,
              next,
              prev,
              inZone: true,
              over: record,
              coordinates: {
                x: event.clientX,
                y: event.clientY
              },
              dropZone: dragContext.dropZones.find(dz => dz.element === element || dz.children.includes(element))
            }
          };
        } else {
          return state;
        }
      }
    },
    // endregion
    // region computedDragEnd
    [computedDragEnd.type]: state => ({ ...state,
      status: EditingStatus.LISTENING,
      dragContext: null,
      highlighted: {}
    }),
    // endregion
    // region setDropPosition
    [setDropPosition.type]: (state, {
      payload: {
        targetIndex
      }
    }) => ({ ...state,
      dragContext: { ...state.dragContext,
        targetIndex
      }
    }),
    // endregion
    // region editComponentInline
    [editComponentInline.type]: state => ({ ...state,
      status: EditingStatus.EDITING_COMPONENT_INLINE,
      draggable: {},
      highlighted: {}
    }),
    // endregion
    // region exitComponentInlineEdit
    [exitComponentInlineEdit.type]: state => ({ ...state,
      status: EditingStatus.LISTENING,
      highlighted: {}
    }),
    // endregion
    // region iceZoneSelected
    // TODO: Not pure
    [iceZoneSelected.type]: (state, {
      payload: {
        record
      }
    }) => ({ ...state,
      status: EditingStatus.EDITING_COMPONENT,
      draggable: {},
      highlighted: {
        [record.id]: getHoverData(record.id)
      }
    }),
    // endregion
    // region startListening
    [startListening.type]: resetState,
    // endregion
    // region scrolling
    [scrolling.type]: state => ({ ...state,
      dragContext: { ...state.dragContext,
        scrolling: true
      }
    }),
    // endregion
    // region scrollingStopped
    // TODO: Not pure
    [scrollingStopped.type]: state => {
      var _state$dragContext2, _state$dragContext2$d;

      return { ...state,
        dragContext: { ...state.dragContext,
          scrolling: false,
          dropZones: (_state$dragContext2 = state.dragContext) === null || _state$dragContext2 === void 0 ? void 0 : (_state$dragContext2$d = _state$dragContext2.dropZones) === null || _state$dragContext2$d === void 0 ? void 0 : _state$dragContext2$d.map(dropZone => ({ ...dropZone,
            rect: dropZone.element.getBoundingClientRect(),
            childrenRects: dropZone.children.map(child => child.getBoundingClientRect())
          }))
        }
      };
    },
    // endregion
    // region dropzoneEnter
    // TODO: Not pure
    [dropzoneEnter.type]: (state, action) => {
      const {
        elementRecordId
      } = action.payload;
      const {
        dropZones: currentDropZones
      } = state.dragContext;
      const currentDropZone = currentDropZones.find(dropZone => dropZone.elementRecordId === elementRecordId);
      let length = currentDropZone.children.length;
      let invalidDrop = currentDropZone.origin ? false : state.dragContext.invalidDrop;
      let rest = reversePluckProps(currentDropZone.validations, 'maxCount', 'minCount');

      if (state.status === EditingStatus.SORTING_COMPONENT && currentDropZone.origin) {
        length = length - 1;
      }

      const maxCount = !currentDropZone.origin ? runValidation(currentDropZone.iceId, 'maxCount', [length]) : null;

      if (maxCount) {
        rest.maxCount = maxCount;
        invalidDrop = true;
      }

      const dropZones = updateDropZoneValidations(currentDropZone, currentDropZones, rest);
      const highlighted = getHighlighted(dropZones);
      return { ...state,
        dragContext: { ...state.dragContext,
          dropZones,
          invalidDrop
        },
        highlighted
      };
    },
    // endregion
    // region dropzoneLeave
    // TODO: Not pure
    [dropzoneLeave.type]: (state, action) => {
      const {
        elementRecordId
      } = action.payload;

      if (!state.dragContext) {
        return;
      }

      const {
        dropZones: currentDropZones
      } = state.dragContext;
      const currentDropZone = currentDropZones.find(dropZone => dropZone.elementRecordId === elementRecordId);
      let length = currentDropZone.children.length;
      let invalidDrop = state.status === EditingStatus.SORTING_COMPONENT ? state.dragContext.invalidDrop : false;
      let rest = reversePluckProps(currentDropZone.validations, 'minCount');

      if (state.status === EditingStatus.SORTING_COMPONENT && currentDropZone.origin) {
        length = length - 1;
      }

      const minCount = runValidation(currentDropZone.iceId, 'minCount', [length]);

      if (minCount) {
        rest.minCount = minCount;
        invalidDrop = !!currentDropZone.origin;
      }

      const dropZones = updateDropZoneValidations(currentDropZone, currentDropZones, rest);
      const highlighted = getHighlighted(dropZones);
      return { ...state,
        dragContext: { ...state.dragContext,
          dropZones,
          invalidDrop
        },
        highlighted
      };
    },
    // endregion
    // region setEditMode
    [setEditMode.type]: (state, {
      payload
    }) => ({ ...state,
      highlighted: {},
      highlightMode: payload.highlightMode
    }),
    // endregion
    // region setPreviewEditMode
    [setPreviewEditMode.type]: (state, action) => action.payload.editMode !== state.editMode ? { ...state,
      highlighted: {},
      editMode: action.payload.editMode
    } : state,
    // endregion
    // region highlightModeChanged
    [highlightModeChanged.type]: (state, {
      payload
    }) => state.highlightMode !== payload.highlightMode ? { ...resetState(state),
      highlightMode: payload.highlightMode
    } : state,
    // endregion
    // region contentTypeDropTargetsRequest
    // TODO: Not pure
    [contentTypeDropTargetsRequest.type]: (state, action) => {
      const {
        contentTypeId
      } = action.payload;
      const highlighted = {};
      getContentTypeDropTargets(contentTypeId).forEach(item => {
        let {
          elementRecordId
        } = compileDropZone(item.id);
        highlighted[elementRecordId] = getHoverData(elementRecordId);
      });
      return { ...state,
        dragContext: { ...state.dragContext,
          inZone: false
        },
        status: EditingStatus.SHOW_DROP_TARGETS,
        highlighted
      };
    },
    // endregion
    // region clearHighlightedDropTargets
    [clearHighlightedDropTargets.type]: state => ({ ...state,
      status: EditingStatus.LISTENING,
      highlighted: {}
    }),
    // endregion
    // region desktopAssetUploadStarted
    // TODO: Not pure
    [desktopAssetUploadStarted.type]: (state, {
      payload: {
        record
      }
    }) => ({ ...state,
      uploading: { ...state.uploading,
        [record.id]: getHoverData(record.id)
      }
    }),
    // endregion
    // region desktopAssetUploadComplete
    // TODO: Carry or retrieve record for these events
    [desktopAssetUploadComplete.type]: (state, {
      payload: {
        record
      }
    }) => ({ ...state,
      uploading: reversePluckProps(state.uploading, record.id)
    }),
    // endregion
    // region desktopAssetUploadProgress
    [desktopAssetUploadProgress.type]: (state, {
      payload: {
        percentage,
        record
      }
    }) => ({ ...state,
      uploading: { ...state.uploading,
        [record.id]: { ...state.uploading[record.id],
          progress: percentage
        }
      }
    }),
    // endregion
    // region componentDragStarted
    // TODO: Not pure.
    [componentDragStarted.type]: (state, action) => {
      const {
        contentType
      } = action.payload;

      if (notNullOrUndefined(contentType)) {
        const dropTargets = getContentTypeDropTargets(contentType);
        const validationsLookup = runDropTargetsValidations(dropTargets);
        const {
          players,
          siblings,
          containers,
          dropZones
        } = getDragContextFromDropTargets(dropTargets, validationsLookup);
        const highlighted = getHighlighted(dropZones);
        return { ...state,
          highlighted,
          status: EditingStatus.PLACING_NEW_COMPONENT,
          dragContext: { ...state.dragContext,
            players,
            siblings,
            dropZones,
            containers,
            contentType,
            inZone: false,
            targetIndex: null,
            dragged: null
          }
        };
      } else {
        return state;
      }
    },
    // endregion
    // region componentInstanceDragStarted
    // TODO: Not pure.
    [componentInstanceDragStarted.type]: (state, action) => {
      const {
        instance,
        contentType
      } = action.payload;

      if (notNullOrUndefined(instance)) {
        const dropTargets = getContentTypeDropTargets(instance.craftercms.contentTypeId);
        const validationsLookup = runDropTargetsValidations(dropTargets);
        const {
          players,
          siblings,
          containers,
          dropZones
        } = getDragContextFromDropTargets(dropTargets, validationsLookup);
        const highlighted = getHighlighted(dropZones);
        return { ...state,
          highlighted,
          status: EditingStatus.PLACING_DETACHED_COMPONENT,
          dragContext: { ...state.dragContext,
            players,
            siblings,
            dropZones,
            containers,
            instance,
            contentType,
            inZone: false,
            targetIndex: null,
            dragged: null
          }
        };
      } else {
        return state;
      }
    },
    // endregion
    // region desktopAssetDragStarted
    // TODO: Not pure
    [desktopAssetDragStarted.type]: (state, action) => {
      const {
        asset
      } = action.payload;

      if (notNullOrUndefined(asset)) {
        let type;

        if (asset.type.includes('image/')) {
          type = 'image';
        } else if (asset.type.includes('video/')) {
          type = 'video-picker';
        }

        const dropTargets = getMediaDropTargets(type);
        const {
          players,
          containers,
          dropZones
        } = getDragContextFromDropTargets(dropTargets);
        const highlighted = getHighlighted(dropZones);
        return { ...state,
          highlighted,
          status: EditingStatus.UPLOAD_ASSET_FROM_DESKTOP,
          dragContext: { ...state.dragContext,
            players,
            siblings: [],
            dropZones,
            containers,
            inZone: false,
            targetIndex: null,
            dragged: asset
          }
        };
      } else {
        return state;
      }
    },
    // endregion
    // region assetDragStarted
    // TODO: Not pure
    [assetDragStarted.type]: (state, action) => {
      const {
        asset
      } = action.payload;

      if (notNullOrUndefined(asset)) {
        let type;

        if (asset.mimeType.includes('image/')) {
          type = 'image';
        } else if (asset.mimeType.includes('video/')) {
          type = 'video-picker';
        }

        const dropTargets = getMediaDropTargets(type);
        const {
          players,
          containers,
          dropZones
        } = getDragContextFromDropTargets(dropTargets);
        const highlighted = getHighlighted(dropZones);
        return { ...state,
          highlighted,
          status: EditingStatus.PLACING_DETACHED_ASSET,
          dragContext: { ...state.dragContext,
            players,
            siblings: [],
            dropZones,
            containers,
            inZone: false,
            targetIndex: null,
            dragged: asset
          }
        };
      } else {
        return state;
      }
    },
    // endregion
    // region selectField
    [setEditingStatus.type]: (state, {
      payload
    }) => ({ ...state,
      status: payload.status
    }),
    // endregion
    // region contentTreeFieldSelected
    // TODO: Not pure
    [contentTreeFieldSelected.type]: (state, action) => {
      const {
        iceProps
      } = action.payload;
      let iceId = exists(iceProps);

      if (iceId === null) {
        return state;
      }

      let iceRecord = getById(iceId);
      let registryEntries, highlight;

      if (iceRecord.recordType === 'component') {
        if (state.highlightMode === HighlightMode.MOVE_TARGETS) {
          // If in move mode, dynamically switch components to their movable item record so users can manipulate.
          const movableRecordId = getMovableParentRecord(iceId);
          iceId = notNullOrUndefined(movableRecordId) ? movableRecordId : iceId;
        }
      } else if (iceRecord.recordType === 'repeat-item' || iceRecord.recordType === 'node-selector-item') {
        if (state.highlightMode === HighlightMode.ALL) {
          // If in edit mode, switching to the component record, so people can edit the component.
          const componentRecord = findChildRecord(iceRecord.modelId, iceRecord.fieldId, iceRecord.index);
          iceId = notNullOrUndefined(componentRecord) ? componentRecord.id : iceId;
        }
      }

      registryEntries = getRecordsFromIceId(iceId);

      if (!registryEntries) {
        return state;
      }

      highlight = getHoverData(registryEntries[0].id);
      return { ...state,
        status: EditingStatus.FIELD_SELECTED,
        draggable: isMovable(iceId) ? {
          [registryEntries[0].id]: iceId
        } : {},
        highlighted: {
          [registryEntries[0].id]: highlight
        },
        fieldSwitcher: registryEntries.length > 1 ? {
          iceId,
          currentElement: 0,
          registryEntryIds: registryEntries.map(entry => entry.id)
        } : null
      };
    },
    // endregion
    // region contentTreeSwitchFieldInstance
    // TODO: Not pure
    [contentTreeSwitchFieldInstance.type]: (state, action) => {
      const {
        type
      } = action.payload;
      let nextElem = type === 'next' ? state.fieldSwitcher.currentElement + 1 : state.fieldSwitcher.currentElement - 1;
      let id = state.fieldSwitcher.registryEntryIds[nextElem];
      const highlight = getHoverData(state.fieldSwitcher.registryEntryIds[nextElem]);
      return { ...state,
        draggable: isMovable(state.fieldSwitcher.iceId) ? {
          [id]: state.fieldSwitcher.iceId
        } : {},
        highlighted: {
          [id]: highlight
        },
        fieldSwitcher: { ...state.fieldSwitcher,
          currentElement: nextElem
        }
      };
    },
    // endregion
    // region clearContentTreeFieldSelected
    [clearContentTreeFieldSelected.type]: state => ({ ...state,
      status: EditingStatus.LISTENING,
      draggable: {},
      highlighted: {},
      fieldSwitcher: null
    }),
    // endregion
    // region hostCheckIn
    [hostCheckIn.type]: (state, action) => ({ ...state,
      hostCheckedIn: true,
      editModePadding: action.payload.editModePadding,
      highlightMode: action.payload.highlightMode,
      editMode: action.payload.editMode,
      rteConfig: action.payload.rteConfig,
      activeSite: action.payload.site
    }),
    // endregion
    // region updateRteConfig
    [updateRteConfig.type]: (state, action) => ({ ...state,
      rteConfig: action.payload.rteConfig
    }),
    // endregion
    // region setEditModePadding
    [setEditModePadding.type]: (state, action) => ({ ...state,
      editModePadding: action.payload.editModePadding
    }) // endregion

  });

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  let store;
  function createGuestStore() {
    if (store) {
      return store;
    }

    const epicMiddleware = createEpicMiddleware();
    store = configureStore({
      reducer,
      middleware: getDefaultMiddleware => getDefaultMiddleware({
        thunk: false,
        // serializable is not good companion while we have
        // non-serializable values on the state (elements).
        serializableCheck: false,
        // immutable is causing max stack issues, probably also due
        // to the non-serializable values on the state.
        immutableCheck: false
      }).concat(epicMiddleware),
      devTools: {
        name: 'Guest Store'
      } // devTools: "production" === 'production' ? false : { name: 'Guest Store' }

    });
    epicMiddleware.run(epic);
    return store;
  }
  const state$ = new Observable(subscriber => {
    const store = createGuestStore();
    return store.subscribe(() => {
      const state = store.getState();
      subscriber.next(state.models);
    });
  }).pipe(share());
  state$.pipe(pluck('content'), distinctUntilChanged());
  state$.pipe(pluck('contentTypes'), distinctUntilChanged());

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

  function SnackBar(props) {
    const {
      open,
      duration,
      message,
      children,
      onClose
    } = props;
    const onCloseRef = react.exports.useRef(onClose);
    const timeoutRef = react.exports.useRef();
    onCloseRef.current = onClose;
    react.exports.useEffect(() => () => clearTimeout(timeoutRef.current), []);
    react.exports.useEffect(() => {
      if (open) {
        timeoutRef.current = setTimeout(onCloseRef.current, duration);
      }
    }, [open, duration]);
    return open ? /*#__PURE__*/React.createElement("craftercms-snackbar", null, message || children) : null;
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function FieldInstanceSwitcher(props) {
    const {
      onNext,
      onPrev,
      registryEntryIds,
      currentElement
    } = props;
    return /*#__PURE__*/React.createElement("craftercms-field-instance-switcher", null, /*#__PURE__*/React.createElement("span", null, currentElement + 1, "/", registryEntryIds.length), /*#__PURE__*/React.createElement("i", {
      onClick: onPrev,
      className: currentElement === 0 ? 'disable' : ''
    }, /*#__PURE__*/React.createElement("svg", {
      focusable: "false",
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, /*#__PURE__*/React.createElement("path", {
      d: "M14.71 6.71a.9959.9959 0 00-1.41 0L8.71 11.3c-.39.39-.39 1.02 0 1.41l4.59 4.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L10.83 12l3.88-3.88c.39-.39.38-1.03 0-1.41z"
    }))), /*#__PURE__*/React.createElement("i", {
      onClick: onNext,
      className: currentElement + 1 === registryEntryIds.length ? 'disable' : ''
    }, /*#__PURE__*/React.createElement("svg", {
      focusable: "false",
      viewBox: "0 0 24 24",
      "aria-hidden": "true"
    }, /*#__PURE__*/React.createElement("path", {
      d: "M9.29 6.71c-.39.39-.39 1.02 0 1.41L13.17 12l-3.88 3.88c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0l4.59-4.59c.39-.39.39-1.02 0-1.41L10.7 6.7c-.38-.38-1.02-.38-1.41.01z"
    }))));
  }

  var DragIndicatorRounded = {};

  var interopRequireDefault = {exports: {}};

  (function (module) {
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }

  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }(interopRequireDefault));

  var createSvgIcon = {};

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(utils);

  (function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function () {
      return _utils.createSvgIcon;
    }
  });

  var _utils = require$$0;
  }(createSvgIcon));

  var _interopRequireDefault$7 = interopRequireDefault.exports;

  Object.defineProperty(DragIndicatorRounded, "__esModule", {
    value: true
  });
  var default_1$7 = DragIndicatorRounded.default = void 0;

  var _createSvgIcon$7 = _interopRequireDefault$7(createSvgIcon);

  var _jsxRuntime$7 = jsxRuntime.exports;

  var _default$7 = (0, _createSvgIcon$7.default)( /*#__PURE__*/(0, _jsxRuntime$7.jsx)("path", {
    d: "M11 18c0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2 2 .9 2 2zm-2-8c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0-6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 4c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"
  }), 'DragIndicatorRounded');

  default_1$7 = DragIndicatorRounded.default = _default$7;

  var EditOutlined = {};

  var _interopRequireDefault$6 = interopRequireDefault.exports;

  Object.defineProperty(EditOutlined, "__esModule", {
    value: true
  });
  var default_1$6 = EditOutlined.default = void 0;

  var _createSvgIcon$6 = _interopRequireDefault$6(createSvgIcon);

  var _jsxRuntime$6 = jsxRuntime.exports;

  var _default$6 = (0, _createSvgIcon$6.default)( /*#__PURE__*/(0, _jsxRuntime$6.jsx)("path", {
    d: "m14.06 9.02.92.92L5.92 19H5v-.92l9.06-9.06M17.66 3c-.25 0-.51.1-.7.29l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29zm-3.6 3.19L3 17.25V21h3.75L17.81 9.94l-3.75-3.75z"
  }), 'EditOutlined');

  default_1$6 = EditOutlined.default = _default$6;

  var ArrowDownwardRounded = {};

  var _interopRequireDefault$5 = interopRequireDefault.exports;

  Object.defineProperty(ArrowDownwardRounded, "__esModule", {
    value: true
  });
  var default_1$5 = ArrowDownwardRounded.default = void 0;

  var _createSvgIcon$5 = _interopRequireDefault$5(createSvgIcon);

  var _jsxRuntime$5 = jsxRuntime.exports;

  var _default$5 = (0, _createSvgIcon$5.default)( /*#__PURE__*/(0, _jsxRuntime$5.jsx)("path", {
    d: "M11 5v11.17l-4.88-4.88c-.39-.39-1.03-.39-1.42 0-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0l6.59-6.59c.39-.39.39-1.02 0-1.41a.9959.9959 0 0 0-1.41 0L13 16.17V5c0-.55-.45-1-1-1s-1 .45-1 1z"
  }), 'ArrowDownwardRounded');

  default_1$5 = ArrowDownwardRounded.default = _default$5;

  var ArrowUpwardRounded = {};

  var _interopRequireDefault$4 = interopRequireDefault.exports;

  Object.defineProperty(ArrowUpwardRounded, "__esModule", {
    value: true
  });
  var default_1$4 = ArrowUpwardRounded.default = void 0;

  var _createSvgIcon$4 = _interopRequireDefault$4(createSvgIcon);

  var _jsxRuntime$4 = jsxRuntime.exports;

  var _default$4 = (0, _createSvgIcon$4.default)( /*#__PURE__*/(0, _jsxRuntime$4.jsx)("path", {
    d: "M13 19V7.83l4.88 4.88c.39.39 1.03.39 1.42 0 .39-.39.39-1.02 0-1.41l-6.59-6.59a.9959.9959 0 0 0-1.41 0l-6.6 6.58c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L11 7.83V19c0 .55.45 1 1 1s1-.45 1-1z"
  }), 'ArrowUpwardRounded');

  default_1$4 = ArrowUpwardRounded.default = _default$4;

  var DeleteOutlineRounded = {};

  var _interopRequireDefault$3 = interopRequireDefault.exports;

  Object.defineProperty(DeleteOutlineRounded, "__esModule", {
    value: true
  });
  var default_1$3 = DeleteOutlineRounded.default = void 0;

  var _createSvgIcon$3 = _interopRequireDefault$3(createSvgIcon);

  var _jsxRuntime$3 = jsxRuntime.exports;

  var _default$3 = (0, _createSvgIcon$3.default)( /*#__PURE__*/(0, _jsxRuntime$3.jsx)("path", {
    d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v10zM9 9h6c.55 0 1 .45 1 1v8c0 .55-.45 1-1 1H9c-.55 0-1-.45-1-1v-8c0-.55.45-1 1-1zm6.5-5-.71-.71c-.18-.18-.44-.29-.7-.29H9.91c-.26 0-.52.11-.7.29L8.5 4H6c-.55 0-1 .45-1 1s.45 1 1 1h12c.55 0 1-.45 1-1s-.45-1-1-1h-2.5z"
  }), 'DeleteOutlineRounded');

  default_1$3 = DeleteOutlineRounded.default = _default$3;

  var GroovyIcon = createSvgIcon$1( /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M4.00098 19.9995V4H20.0004V19.9995H4.00098ZM2.00098 3C2.00098 2.44772 2.44869 2 3.00098 2H21.0004C21.5527 2 22.0004 2.44772 22.0004 3V20.9995C22.0004 21.5518 21.5527 21.9995 21.0004 21.9995H3.00098C2.44869 21.9995 2.00098 21.5518 2.00098 20.9995V3ZM8.54298 17.8695C9.03698 18.0602 9.56998 18.1555 10.142 18.1555C10.7226 18.1555 11.247 18.0602 11.715 17.8695C12.1916 17.6702 12.573 17.4275 12.859 17.1415V13.3975H9.89498V14.6325H11.507V16.4655C11.3683 16.5868 11.1906 16.6822 10.974 16.7515C10.7573 16.8122 10.5276 16.8425 10.285 16.8425C9.42698 16.8425 8.77698 16.5695 8.33498 16.0235C7.90164 15.4688 7.68498 14.7062 7.68498 13.7355C7.68498 13.2588 7.74564 12.8298 7.86698 12.4485C7.98831 12.0672 8.15731 11.7465 8.37398 11.4865C8.59931 11.2178 8.86364 11.0142 9.16698 10.8755C9.47898 10.7282 9.82564 10.6545 10.207 10.6545C10.6056 10.6545 10.935 10.7282 11.195 10.8755C11.4636 11.0142 11.7063 11.1875 11.923 11.3955L12.729 10.4205C12.4603 10.1432 12.1136 9.89618 11.689 9.67951C11.273 9.45418 10.7616 9.34151 10.155 9.34151C9.59164 9.34151 9.06298 9.44118 8.56898 9.64051C8.08364 9.83985 7.65898 10.1302 7.29498 10.5115C6.93964 10.8928 6.65798 11.3608 6.44998 11.9155C6.24198 12.4615 6.13798 13.0812 6.13798 13.7745C6.13798 14.4765 6.23764 15.1005 6.43698 15.6465C6.63631 16.1925 6.91364 16.6518 7.26898 17.0245C7.63298 17.3972 8.05764 17.6788 8.54298 17.8695ZM14.6131 11.6165V17.9995H16.1081V14.0995C16.3074 13.6142 16.5457 13.2762 16.8231 13.0855C17.1004 12.8862 17.3647 12.7865 17.6161 12.7865C17.7547 12.7865 17.8717 12.7952 17.9671 12.8125C18.0624 12.8298 18.1664 12.8558 18.2791 12.8905L18.5391 11.5905C18.3571 11.5038 18.1144 11.4605 17.8111 11.4605C17.4731 11.4605 17.1437 11.5732 16.8231 11.7985C16.5024 12.0152 16.2294 12.3315 16.0041 12.7475H15.9521L15.8481 11.6165H14.6131Z"
  }), 'GroovyIcon');

  var FreemarkerIcon = createSvgIcon$1( /*#__PURE__*/React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M4.00098 19.9995V4H20.0004V19.9995H4.00098ZM2.00098 3C2.00098 2.44772 2.44869 2 3.00098 2H21.0004C21.5527 2 22.0004 2.44772 22.0004 3V20.9995C22.0004 21.5518 21.5527 21.9995 21.0004 21.9995H3.00098C2.44869 21.9995 2.00098 21.5518 2.00098 20.9995V3ZM8.70998 12.7995V17.9995H10.205V12.7995H12.324V15.8415C12.324 16.1882 12.3586 16.5045 12.428 16.7905C12.506 17.0678 12.623 17.3105 12.779 17.5185C12.9436 17.7178 13.1516 17.8738 13.403 17.9865C13.663 18.0992 13.975 18.1555 14.339 18.1555C14.599 18.1555 14.8373 18.1295 15.054 18.0775C15.2793 18.0342 15.4786 17.9822 15.652 17.9215L15.392 16.8165C15.2966 16.8598 15.1883 16.8945 15.067 16.9205C14.9543 16.9465 14.8416 16.9595 14.729 16.9595C14.1223 16.9595 13.819 16.5868 13.819 15.8415V12.7995H15.457V11.6165H13.819V9.87451H12.584L12.402 11.6165H10.205V10.9275C10.205 10.2082 10.4736 9.84851 11.011 9.84851C11.245 9.84851 11.479 9.90051 11.713 10.0045L11.999 8.88651C11.8516 8.82584 11.674 8.77384 11.466 8.73051C11.2666 8.68718 11.0543 8.66551 10.829 8.66551C10.4476 8.66551 10.1226 8.72184 9.85398 8.83451C9.59398 8.94718 9.37731 9.10751 9.20398 9.31551C9.03064 9.51484 8.90498 9.75751 8.82698 10.0435C8.74898 10.3208 8.70998 10.6242 8.70998 10.9535V11.6165L7.85198 11.6815V12.7995H8.70998ZM17.1158 17.6745C17.3325 17.9952 17.7095 18.1555 18.2468 18.1555C18.5761 18.1555 18.8405 18.1122 19.0398 18.0255L18.8448 16.9075C18.7841 16.9248 18.7365 16.9335 18.7018 16.9335H18.6108C18.5328 16.9335 18.4591 16.8988 18.3898 16.8295C18.3205 16.7515 18.2858 16.6215 18.2858 16.4395V8.82151H16.7908V16.3615C16.7908 16.9162 16.8991 17.3538 17.1158 17.6745Z"
  }), 'GroovyIcon');

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  // The idea of this component is to be as specific as possible to avoid guest site styles to break ours.

  const UltraStyledIconButton = styled$1(IconButton$1)({
    boxShadow: 'none !important',
    border: 'none !important',
    color: 'inherit !important',
    height: 'inherit !important',
    width: 'inherit !important'
  });

  var HighlightOffRounded = {};

  var _interopRequireDefault$2 = interopRequireDefault.exports;

  Object.defineProperty(HighlightOffRounded, "__esModule", {
    value: true
  });
  var default_1$2 = HighlightOffRounded.default = void 0;

  var _createSvgIcon$2 = _interopRequireDefault$2(createSvgIcon);

  var _jsxRuntime$2 = jsxRuntime.exports;

  var _default$2 = (0, _createSvgIcon$2.default)( /*#__PURE__*/(0, _jsxRuntime$2.jsx)("path", {
    d: "M13.89 8.7 12 10.59 10.11 8.7a.9959.9959 0 0 0-1.41 0c-.39.39-.39 1.02 0 1.41L10.59 12 8.7 13.89c-.39.39-.39 1.02 0 1.41.39.39 1.02.39 1.41 0L12 13.41l1.89 1.89c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L13.41 12l1.89-1.89c.39-.39.39-1.02 0-1.41-.39-.38-1.03-.38-1.41 0zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"
  }), 'HighlightOffRounded');

  default_1$2 = HighlightOffRounded.default = _default$2;

  var AddCircleOutlineRounded = {};

  var _interopRequireDefault$1 = interopRequireDefault.exports;

  Object.defineProperty(AddCircleOutlineRounded, "__esModule", {
    value: true
  });
  var default_1$1 = AddCircleOutlineRounded.default = void 0;

  var _createSvgIcon$1 = _interopRequireDefault$1(createSvgIcon);

  var _jsxRuntime$1 = jsxRuntime.exports;

  var _default$1 = (0, _createSvgIcon$1.default)( /*#__PURE__*/(0, _jsxRuntime$1.jsx)("path", {
    d: "M12 7c-.55 0-1 .45-1 1v3H8c-.55 0-1 .45-1 1s.45 1 1 1h3v3c0 .55.45 1 1 1s1-.45 1-1v-3h3c.55 0 1-.45 1-1s-.45-1-1-1h-3V8c0-.55-.45-1-1-1zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"
  }), 'AddCircleOutlineRounded');

  default_1$1 = AddCircleOutlineRounded.default = _default$1;

  var ContentCopyRounded = {};

  var _interopRequireDefault = interopRequireDefault.exports;

  Object.defineProperty(ContentCopyRounded, "__esModule", {
    value: true
  });
  var default_1 = ContentCopyRounded.default = void 0;

  var _createSvgIcon = _interopRequireDefault(createSvgIcon);

  var _jsxRuntime = jsxRuntime.exports;

  var _default = (0, _createSvgIcon.default)( /*#__PURE__*/(0, _jsxRuntime.jsx)("path", {
    d: "M15 20H5V7c0-.55-.45-1-1-1s-1 .45-1 1v13c0 1.1.9 2 2 2h10c.55 0 1-.45 1-1s-.45-1-1-1zm5-4V4c0-1.1-.9-2-2-2H9c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2zm-2 0H9V4h9v12z"
  }), 'ContentCopyRounded');

  default_1 = ContentCopyRounded.default = _default;

  function useUpdateRefs(latestValues) {
    const ref = react.exports.useRef({});
    ref.current = latestValues;
    return ref;
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function MoveModeZoneMenu(props) {
    const {
      record,
      dispatch,
      isHeadlessMode
    } = props;
    const {
      modelId,
      fieldId: [fieldId],
      index
    } = record;
    const trashButtonRef = react.exports.useRef();
    const [showTrashConfirmation, setShowTrashConfirmation] = react.exports.useState(false);
    const iceRecord = getById(record.iceIds[0]);
    const recordType = iceRecord.recordType;
    const collection = react.exports.useMemo(() => {
      if (['node-selector-item', 'repeat-item'].includes(recordType)) {
        return extractCollection(getCachedModel(modelId), fieldId, index);
      } else if (recordType === 'component') {
        // ToDo: Find container collection
        const mapEntry = modelHierarchyMap[modelId];

        if (mapEntry && mapEntry.parentId) {
          return extractCollection(getCachedModel(mapEntry.parentId), mapEntry.parentContainerFieldPath, mapEntry.parentContainerFieldIndex);
        } else {
          return null;
        }
      } else {
        return null;
      }
    }, [modelId, fieldId, index, recordType]);
    const elementIndex = react.exports.useMemo(() => {
      // If the record is a component, get the index from searching the
      // model id inside the container collection (previously computed).
      return recordType === 'component' ? collection.indexOf(modelId) : parseInt(isSimple(index) ? String(index) : popPiece(String(index)));
    }, [recordType, collection, modelId, index]);
    const nodeSelectorItemRecord = react.exports.useMemo(() => recordType === 'component' ? getById(exists({
      modelId: modelHierarchyMap[modelId].parentId,
      fieldId: modelHierarchyMap[modelId].parentContainerFieldPath,
      index: modelHierarchyMap[modelId].parentContainerFieldIndex
    })) : null, [modelId, recordType]);
    const componentId = recordType === 'component' ? modelId : recordType === 'node-selector-item' ? collection[elementIndex] : null;
    const {
      field,
      contentType
    } = react.exports.useMemo(() => getReferentialEntries(record.iceIds[0]), [record.iceIds]);
    const isMovable = ['node-selector-item', 'repeat-item'].includes(recordType) || Boolean(recordType === 'component' && nodeSelectorItemRecord);
    const numOfItemsInContainerCollection = collection === null || collection === void 0 ? void 0 : collection.length;
    const isFirstItem = isMovable ? elementIndex === 0 : null;
    const isLastItem = isMovable ? elementIndex === numOfItemsInContainerCollection - 1 : null;
    const isOnlyItem = isMovable ? isFirstItem && isLastItem : null;
    const isEmbedded = react.exports.useMemo(() => {
      var _getCachedModel;

      return !Boolean((_getCachedModel = getCachedModel(modelId)) === null || _getCachedModel === void 0 ? void 0 : _getCachedModel.craftercms.path);
    }, [modelId]);
    const showCodeEditOptions = ['component', 'page', 'node-selector-item'].includes(recordType) && !isHeadlessMode;
    const isTrashable = recordType !== 'field' && recordType !== 'page';
    const showAddItem = recordType === 'field' && field.type === 'repeat';
    const showDuplicate = ['repeat-item', 'component', 'node-selector-item'].includes(recordType); // region callbacks

    const onCancel = () => {
      clearAndListen$.next();
      dispatch(startListening());
    };

    const commonEdit = (e, typeOfEdit) => {
      e.stopPropagation();
      e.preventDefault();
      const parentModelId = getParentModelId(modelId, getCachedModels(), modelHierarchyMap);

      if (recordType === 'node-selector-item') {
        // If it's a node selector item, we transform it into the actual item.
        post(requestEdit({
          typeOfEdit,
          modelId: componentId,
          parentModelId
        }));
      } else {
        post(requestEdit({
          typeOfEdit,
          modelId,
          parentModelId,
          fields: record.fieldId
        }));
      }

      onCancel();
    };

    const onEdit = e => {
      commonEdit(e, 'content');
    };

    const onEditController = e => {
      commonEdit(e, 'controller');
    };

    const onEditTemplate = e => {
      commonEdit(e, 'template');
    };

    const onAddRepeatItem = e => {
      insertItem(modelId, fieldId, index, contentType);
    };

    const onDuplicateItem = e => {
      if (recordType === 'component' && nodeSelectorItemRecord) {
        duplicateItem(nodeSelectorItemRecord.modelId, nodeSelectorItemRecord.fieldId, nodeSelectorItemRecord.index);
      } else {
        duplicateItem(modelId, fieldId, index);
      }
    };

    const onMoveUp = e => {
      e.preventDefault();
      e.stopPropagation();

      if (recordType === 'component' && nodeSelectorItemRecord) {
        sortUpItem(nodeSelectorItemRecord.modelId, nodeSelectorItemRecord.fieldId, nodeSelectorItemRecord.index);
      } else {
        sortUpItem(modelId, fieldId, index);
      }

      onCancel();
    };

    const onMoveDown = e => {
      e.preventDefault();
      e.stopPropagation();

      if (recordType === 'component' && nodeSelectorItemRecord) {
        sortDownItem(nodeSelectorItemRecord.modelId, nodeSelectorItemRecord.fieldId, nodeSelectorItemRecord.index);
      } else {
        sortDownItem(modelId, fieldId, index);
      }

      onCancel();
    };

    const doTrash = () => {
      setShowTrashConfirmation(false);
      const minCount = runValidation(findContainerRecord(modelId, fieldId, index).id, 'minCount', [numOfItemsInContainerCollection - 1]);

      if (minCount) {
        post(validationMessage(minCount));
      } else {
        if (recordType === 'component' && nodeSelectorItemRecord) {
          deleteItem(nodeSelectorItemRecord.modelId, nodeSelectorItemRecord.fieldId, nodeSelectorItemRecord.index);
        } else {
          deleteItem(modelId, fieldId, index);
        }

        onCancel();
      }
    };

    const onTrash = e => {
      e.preventDefault();
      e.stopPropagation();
      setShowTrashConfirmation(true);
    };

    const onDragStart = e => {
      e.stopPropagation();
      e.dataTransfer.setData('text/plain', `${record.id}`);
      e.dataTransfer.setDragImage(document.querySelector('.craftercms-dragged-element'), 20, 20);
      setTimeout(() => {
        dispatch({
          type: 'dragstart',
          payload: {
            event: null,
            record
          }
        });
      });
    }; // endregion


    const refs = useUpdateRefs({
      onMoveUp,
      onMoveDown,
      onTrash,
      doTrash,
      onCancel,
      isFirstItem,
      isLastItem
    }); // Listen for key input to sort/delete and for clicking outside the zone to dismiss selection.

    react.exports.useEffect(() => {
      const onKeyDown = e => {
        switch (e.key) {
          case 'ArrowLeft':
          case 'ArrowUp':
            {
              if (!refs.current.isFirstItem) {
                refs.current.onMoveUp(e);
              }

              break;
            }

          case 'ArrowRight':
          case 'ArrowDown':
            {
              if (!refs.current.isLastItem) {
                refs.current.onMoveDown(e);
              }

              break;
            }

          case 'Backspace':
            {
              e.preventDefault();
              setShowTrashConfirmation(true);
              break;
            }
        }
      };

      const onClickOut = e => {
        e.stopPropagation();
        e.preventDefault();
        refs.current.onCancel();
      };

      document.addEventListener('keydown', onKeyDown, false);
      document.addEventListener('click', onClickOut, false);
      return () => {
        document.removeEventListener('keydown', onKeyDown, false);
        document.removeEventListener('click', onClickOut, false);
      };
    }, []);
    return /*#__PURE__*/react.exports.createElement(react.exports.Fragment, null, /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Cancel (Esc)"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onCancel
    }, /*#__PURE__*/react.exports.createElement(default_1$2, null))), /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Edit"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onEdit
    }, /*#__PURE__*/react.exports.createElement(default_1$6, null))), showCodeEditOptions && /*#__PURE__*/react.exports.createElement(react.exports.Fragment, null, /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Edit template"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onEditTemplate
    }, /*#__PURE__*/react.exports.createElement(FreemarkerIcon, null))), /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Edit controller"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onEditController
    }, /*#__PURE__*/react.exports.createElement(GroovyIcon, null)))), showAddItem && /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Add new item"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onAddRepeatItem
    }, /*#__PURE__*/react.exports.createElement(default_1$1, null))), showDuplicate && /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Duplicate item"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onDuplicateItem
    }, /*#__PURE__*/react.exports.createElement(default_1, null))), isMovable && !isOnlyItem && [!isFirstItem && /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Move up/left (\u2190 or \u2191)"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onMoveUp
    }, /*#__PURE__*/react.exports.createElement(default_1$4, null))), !isLastItem && /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Move down/right (\u2192 or \u2193)"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onMoveDown
    }, /*#__PURE__*/react.exports.createElement(default_1$5, null)))], isTrashable && /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Trash (\u232B)"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      onClick: onTrash,
      ref: trashButtonRef
    }, /*#__PURE__*/react.exports.createElement(default_1$3, null))), isMovable && /*#__PURE__*/react.exports.createElement(Tooltip$1, {
      title: "Move"
    }, /*#__PURE__*/react.exports.createElement(UltraStyledIconButton, {
      size: "small",
      draggable: true,
      sx: {
        cursor: 'grab'
      },
      onDragStart: onDragStart
    }, /*#__PURE__*/react.exports.createElement(default_1$7, null))), /*#__PURE__*/react.exports.createElement(Menu$1, {
      anchorEl: trashButtonRef.current,
      open: showTrashConfirmation,
      onClose: () => setShowTrashConfirmation(false),
      anchorOrigin: {
        vertical: 'bottom',
        horizontal: 'right'
      },
      transformOrigin: {
        vertical: 'top',
        horizontal: 'right'
      },
      sx: {
        zIndex: 1501
      }
    }, /*#__PURE__*/react.exports.createElement(Typography$1, {
      variant: "body1",
      sx: {
        padding: '10px 16px 10px 16px'
      }
    }, isEmbedded ? 'Delete' : 'Disassociate', " this item?"), /*#__PURE__*/react.exports.createElement(MenuItem$1, {
      onClick: e => {
        e.preventDefault();
        setShowTrashConfirmation(false);
      }
    }, "No"), /*#__PURE__*/react.exports.createElement(MenuItem$1, {
      onClick: e => refs.current.doTrash()
    }, "Yes")));
  } // Could use a more generic version...

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function DragGhostElement(props) {
    return /*#__PURE__*/React.createElement(Box$1, {
      className: "craftercms-dragged-element",
      sx: {
        display: 'block',
        maxWidth: 200,
        backgroundColor: 'common.white',
        color: 'text.secondary',
        padding: '5px 10px',
        borderRadius: 1,
        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        position: 'absolute',
        // top: -1000,
        left: -1000,
        ...props.sx
      }
    }, props.label);
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */

  const defaultStyleConfig = {
    styles: undefined,
    assetUploadMaskZIndex: 1010,
    assetUploadMaskBackgroundColor: 'white',
    dropMarkerZIndex: 1010,
    dropMarkerColor: palette.blue.main,
    snackBarZIndex: 1010,
    snackBarBackgroundColor: 'rgb(49, 49, 49)',
    zoneLabelZIndex: 1010,
    zoneLabelTextColor: '#00270b',
    zoneLabelBackground: 'linear-gradient(to bottom, rgba(48,219,91,0.8) 0%, rgba(52,199,89,0.8) 100%)',
    zoneMarkerZIndex: 1010,
    zoneMarkerOutlineColor: palette.green.main,
    inlineTextEditorOutlineColor: palette.blue.tint,
    inlineTextEditorFocusOutlineColor: palette.blue.main,
    validationMandatoryColor: palette.red.main,
    validationSuggestedColor: palette.orange.main
  };

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  const overlayBackgroundColor = 'rgba(0, 0, 0, .4)'; // Hoist global styles to a static constant to avoid re-rendering.

  const styles = /*#__PURE__*/react.exports.createElement(GlobalStyles, {
    styles: {
      // Elements
      'craftercms-asset-uploader-mask-container': {
        zIndex: defaultStyleConfig.assetUploadMaskZIndex,
        position: 'absolute',
        pointerEvents: 'none'
      },
      'craftercms-asset-uploader-mask': {
        background: defaultStyleConfig.assetUploadMaskBackgroundColor,
        opacity: 0.5,
        height: '100%',
        width: '100%',
        display: 'block',
        transition: 'height 0.3s ease-out',
        animation: 'craftercms-uploader-mask-animation 1.5s infinite ease-in-out'
      },
      'craftercms-drop-marker': {
        zIndex: defaultStyleConfig.dropMarkerZIndex,
        position: 'fixed',
        pointerEvents: 'none',
        '&::before, &::after': {
          content: '""',
          width: '8px',
          height: '8px',
          background: defaultStyleConfig.dropMarkerColor,
          borderRadius: '8px',
          marginTop: '-3px',
          marginLeft: '-4.5px',
          position: 'absolute'
        },
        '&.horizontal': {
          height: 2,
          visibility: 'visible',
          background: defaultStyleConfig.dropMarkerColor,
          boxShadow: '0 1px 2px rgba(255, 255, 255, .4),  0 -1px 2px rgba(255, 255, 255, .4)',
          '&::before': {
            left: 0
          },
          '&::after': {
            right: 0
          }
        },
        '&.vertical': {
          width: 2,
          minHeight: '5px',
          marginLeft: '3px',
          border: `1px solid ${defaultStyleConfig.dropMarkerColor}`,
          boxShadow: '1px 0 2px rgba(255, 255, 255, .4),  -1px 0 2px rgba(255, 255, 255, .4)',
          '&::before': {
            top: 0
          },
          '&::after': {
            bottom: -4
          }
        }
      },
      'craftercms-snackbar': {
        top: 10,
        right: 10,
        position: 'fixed',
        color: '#fff',
        display: 'flex',
        padding: '15px 20px',
        flexGrow: 1,
        flexWrap: 'wrap',
        fontSize: '0.875rem',
        alignItems: 'center',
        fontFamily: '"Source Sans Pro", "Open Sans", sans-serif',
        fontWeight: 400,
        lineHeight: 1.43,
        borderRadius: '4px',
        backgroundColor: defaultStyleConfig.snackBarBackgroundColor,
        minWidth: '288px',
        transform: 'none',
        transition: 'transform 225ms cubic-bezier(0, 0, 0.2, 1) 0ms',
        boxShadow: '0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14), 0 1px 18px 0 rgba(0, 0, 0, 0.12)',
        zIndex: defaultStyleConfig.snackBarZIndex
      },
      'craftercms-dragged-element': {
        display: 'block',
        maxWidth: 200,
        backgroundColor: '#fff',
        color: palette.gray.medium4,
        padding: '5px 10px',
        borderRadius: 10,
        whiteSpace: 'nowrap',
        textOverflow: 'ellipsis',
        overflow: 'hidden',
        position: 'absolute',
        top: -100
      },
      'craftercms-field-instance-switcher': {
        position: 'fixed',
        bottom: '10px',
        right: '10px',
        backgroundColor: palette.white,
        boxShadow: '0 2px 1px -1px rgba(0,0,0,0.2), 0 1px 1px 0 rgba(0,0,0,0.14), 0 1px 3px 0 rgba(0,0,0,0.12)',
        padding: '10px 14px',
        color: palette.black,
        display: 'flex',
        alignItems: 'center',
        zIndex: 2,
        '& .disable': {
          pointerEvents: 'none',
          opacity: '0.5'
        },
        '& i': {
          display: 'inherit',
          padding: '2px',
          cursor: 'pointer'
        },
        '& svg': {
          fill: 'currentColor',
          width: '1em',
          height: '1em',
          display: 'inline-block',
          fontSize: '1.5rem',
          transition: 'fill 200ms cubic-bezier(0.4, 0, 0.2, 1) 0ms',
          flexShrink: 0,
          userSelect: 'none'
        }
      },
      // Classes
      '.craftercms-placeholder-spinner': {
        animation: 'craftercms-placeholder-animation 2s linear infinite',
        '& .path': {
          stroke: palette.blue.main,
          animation: 'craftercms-placeholder-inner-animation 1.5s ease-in-out infinite'
        }
      },
      '.craftercms-content-tree-locate': {
        animation: 'craftercms-content-tree-locate-animation 300ms 2 ease-in-out'
      },
      '.craftercms-zone-marker-label__multi-mode': {
        background: defaultStyleConfig.zoneMarkerOutlineColor,
        top: 0,
        left: 'auto',
        right: 0,
        minWidth: 0,
        marginLeft: 0,
        position: 'absolute',
        padding: '2px 10px',
        borderRadius: 0,
        boxShadow: 'none',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
      },
      // region craftercms-ice-on
      [`.${editModeClass}`]: {
        '[data-craftercms-model-id], & [data-craftercms-model-id] a': {
          cursor: 'url("/studio/static-assets/images/cursor-edit@1.5x.png"), pointer !important'
        }
      },
      [`.${moveModeClass}`]: {
        '[draggable="true"]': {
          cursor: 'url("/studio/static-assets/images/cursor-drag@1.5x.png"), move !important'
        }
      },
      [`.${dragAndDropActiveClass}`]: {},
      [`.${editModePaddingClass}`]: {
        '[data-craftercms-type="collection"]': {
          paddingTop: '20px',
          paddingRight: '20px',
          paddingBottom: '20px',
          paddingLeft: '20px'
        }
      },
      [`.${editOnClass}`]: {
        [`&.${moveModeClass} [${eventCaptureOverlayAttribute}]`]: {
          background: overlayBackgroundColor,
          '&::before': {
            content: '"Content hidden to enable dragging."'
          },
          '> *': {
            visibility: 'hidden'
          }
        },
        [`&.${iceBypassKeyClass} [${eventCaptureOverlayAttribute}]:hover::before`]: {
          backgroundColor: overlayBackgroundColor,
          content: '"Turn off edit mode to interact with this element."'
        },
        [`[${eventCaptureOverlayAttribute}]`]: {
          position: 'relative',
          '&::before': {
            top: 0,
            left: 0,
            right: 0,
            color: '#fff',
            bottom: 0,
            content: '""',
            padding: '20px',
            fontWeight: 'bold',
            position: 'absolute'
          }
        },
        [`.${emptyCollectionClass}`]: {
          minHeight: '100px',
          minWidth: '100px',
          backgroundColor: overlayBackgroundColor,
          '&::before': {
            color: '#fff',
            display: 'inline-block',
            padding: '10px',
            content: '"No items on this area."',
            fontWeight: 'bold'
          }
        },
        [`.${emptyFieldClass}`]: {
          minHeight: '40px',
          minWidth: '50px',
          borderRadius: '5px',
          backgroundColor: overlayBackgroundColor,
          '&::before': {
            color: '#fff',
            display: 'inline-block',
            padding: '10px',
            content: '"Click to add content."',
            fontWeight: 'bold'
          }
        }
      },
      // endregion
      '.mce-content-body': {
        outlineOffset: 5,
        outline: `2px solid ${defaultStyleConfig.inlineTextEditorOutlineColor}`,
        '&:focus': {
          outline: `5px solid ${defaultStyleConfig.inlineTextEditorFocusOutlineColor}`
        }
      },
      // Keyframes
      '@keyframes craftercms-uploader-mask-animation': {
        '0%': {
          opacity: 0.4
        },
        '50%': {
          opacity: 0.5
        },
        '100%': {
          opacity: 0.4
        }
      },
      '@keyframes craftercms-placeholder-animation': {
        '100%': {
          transform: 'rotate(360deg)'
        }
      },
      '@keyframes craftercms-placeholder-inner-animation': {
        '0%': {
          strokeDasharray: '1, 150',
          strokeDashoffset: '0'
        },
        '50%': {
          strokeDasharray: '90, 150',
          strokeDashoffset: '-35'
        },
        '100%': {
          strokeDasharray: '90, 150',
          strokeDashoffset: '-124'
        }
      },
      '@keyframes craftercms-content-tree-locate-animation': {
        '0%': {
          transform: 'scaleX(1)'
        },
        '50%': {
          transform: 'scale3d(1.05,1.05,1.05)'
        },
        to: {
          transform: 'scaleX(1)'
        }
      }
    }
  });
  function GuestGlobalStyles(props) {
    return styles;
  }

  /*!
   * hotkeys-js v3.8.7
   * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
   * 
   * Copyright (c) 2021 kenny wong <wowohoo@qq.com>
   * http://jaywcjlove.github.io/hotkeys
   * 
   * Licensed under the MIT license.
   */
  var isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件

  function addEvent(object, event, method) {
    if (object.addEventListener) {
      object.addEventListener(event, method, false);
    } else if (object.attachEvent) {
      object.attachEvent("on".concat(event), function () {
        method(window.event);
      });
    }
  } // 修饰键转换成对应的键码


  function getMods(modifier, key) {
    var mods = key.slice(0, key.length - 1);

    for (var i = 0; i < mods.length; i++) {
      mods[i] = modifier[mods[i].toLowerCase()];
    }

    return mods;
  } // 处理传的key字符串转换成数组


  function getKeys(key) {
    if (typeof key !== 'string') key = '';
    key = key.replace(/\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等

    var keys = key.split(','); // 同时设置多个快捷键，以','分割

    var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理

    for (; index >= 0;) {
      keys[index - 1] += ',';
      keys.splice(index, 1);
      index = keys.lastIndexOf('');
    }

    return keys;
  } // 比较修饰键的数组


  function compareArray(a1, a2) {
    var arr1 = a1.length >= a2.length ? a1 : a2;
    var arr2 = a1.length >= a2.length ? a2 : a1;
    var isIndex = true;

    for (var i = 0; i < arr1.length; i++) {
      if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
    }

    return isIndex;
  }

  var _keyMap = {
    backspace: 8,
    tab: 9,
    clear: 12,
    enter: 13,
    return: 13,
    esc: 27,
    escape: 27,
    space: 32,
    left: 37,
    up: 38,
    right: 39,
    down: 40,
    del: 46,
    delete: 46,
    ins: 45,
    insert: 45,
    home: 36,
    end: 35,
    pageup: 33,
    pagedown: 34,
    capslock: 20,
    num_0: 96,
    num_1: 97,
    num_2: 98,
    num_3: 99,
    num_4: 100,
    num_5: 101,
    num_6: 102,
    num_7: 103,
    num_8: 104,
    num_9: 105,
    num_multiply: 106,
    num_add: 107,
    num_enter: 108,
    num_subtract: 109,
    num_decimal: 110,
    num_divide: 111,
    '⇪': 20,
    ',': 188,
    '.': 190,
    '/': 191,
    '`': 192,
    '-': isff ? 173 : 189,
    '=': isff ? 61 : 187,
    ';': isff ? 59 : 186,
    '\'': 222,
    '[': 219,
    ']': 221,
    '\\': 220
  }; // Modifier Keys

  var _modifier = {
    // shiftKey
    '⇧': 16,
    shift: 16,
    // altKey
    '⌥': 18,
    alt: 18,
    option: 18,
    // ctrlKey
    '⌃': 17,
    ctrl: 17,
    control: 17,
    // metaKey
    '⌘': 91,
    cmd: 91,
    command: 91
  };
  var modifierMap = {
    16: 'shiftKey',
    18: 'altKey',
    17: 'ctrlKey',
    91: 'metaKey',
    shiftKey: 16,
    ctrlKey: 17,
    altKey: 18,
    metaKey: 91
  };
  var _mods = {
    16: false,
    18: false,
    17: false,
    91: false
  };
  var _handlers = {}; // F1~F12 special key

  for (var k = 1; k < 20; k++) {
    _keyMap["f".concat(k)] = 111 + k;
  }

  var _downKeys = []; // 记录摁下的绑定键

  var _scope = 'all'; // 默认热键范围

  var elementHasBindEvent = []; // 已绑定事件的节点记录
  // 返回键码

  var code = function code(x) {
    return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
  }; // 设置获取当前范围（默认为'所有'）


  function setScope(scope) {
    _scope = scope || 'all';
  } // 获取当前范围


  function getScope() {
    return _scope || 'all';
  } // 获取摁下绑定键的键值


  function getPressedKeyCodes() {
    return _downKeys.slice(0);
  } // 表单控件控件判断 返回 Boolean
  // hotkey is effective only when filter return true


  function filter(event) {
    var target = event.target || event.srcElement;
    var tagName = target.tagName;
    var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>

    if (target.isContentEditable || (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {
      flag = false;
    }

    return flag;
  } // 判断摁下的键是否为某个键，返回true或者false


  function isPressed(keyCode) {
    if (typeof keyCode === 'string') {
      keyCode = code(keyCode); // 转换成键码
    }

    return _downKeys.indexOf(keyCode) !== -1;
  } // 循环删除handlers中的所有 scope(范围)


  function deleteScope(scope, newScope) {
    var handlers;
    var i; // 没有指定scope，获取scope

    if (!scope) scope = getScope();

    for (var key in _handlers) {
      if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
        handlers = _handlers[key];

        for (i = 0; i < handlers.length;) {
          if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;
        }
      }
    } // 如果scope被删除，将scope重置为all


    if (getScope() === scope) setScope(newScope || 'all');
  } // 清除修饰键


  function clearModifier(event) {
    var key = event.keyCode || event.which || event.charCode;

    var i = _downKeys.indexOf(key); // 从列表中清除按压过的键


    if (i >= 0) {
      _downKeys.splice(i, 1);
    } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题


    if (event.key && event.key.toLowerCase() === 'meta') {
      _downKeys.splice(0, _downKeys.length);
    } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除


    if (key === 93 || key === 224) key = 91;

    if (key in _mods) {
      _mods[key] = false; // 将修饰键重置为false

      for (var k in _modifier) {
        if (_modifier[k] === key) hotkeys[k] = false;
      }
    }
  }

  function unbind(keysInfo) {
    // unbind(), unbind all keys
    if (!keysInfo) {
      Object.keys(_handlers).forEach(function (key) {
        return delete _handlers[key];
      });
    } else if (Array.isArray(keysInfo)) {
      // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])
      keysInfo.forEach(function (info) {
        if (info.key) eachUnbind(info);
      });
    } else if (typeof keysInfo === 'object') {
      // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})
      if (keysInfo.key) eachUnbind(keysInfo);
    } else if (typeof keysInfo === 'string') {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      } // support old method
      // eslint-disable-line


      var scope = args[0],
          method = args[1];

      if (typeof scope === 'function') {
        method = scope;
        scope = '';
      }

      eachUnbind({
        key: keysInfo,
        scope: scope,
        method: method,
        splitKey: '+'
      });
    }
  } // 解除绑定某个范围的快捷键


  var eachUnbind = function eachUnbind(_ref) {
    var key = _ref.key,
        scope = _ref.scope,
        method = _ref.method,
        _ref$splitKey = _ref.splitKey,
        splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;
    var multipleKeys = getKeys(key);
    multipleKeys.forEach(function (originKey) {
      var unbindKeys = originKey.split(splitKey);
      var len = unbindKeys.length;
      var lastKey = unbindKeys[len - 1];
      var keyCode = lastKey === '*' ? '*' : code(lastKey);
      if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围

      if (!scope) scope = getScope();
      var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
      _handlers[keyCode] = _handlers[keyCode].map(function (record) {
        // 通过函数判断，是否解除绑定，函数相等直接返回
        var isMatchingMethod = method ? record.method === method : true;

        if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
          return {};
        }

        return record;
      });
    });
  }; // 对监听对应快捷键的回调函数进行处理


  function eventHandler(event, handler, scope) {
    var modifiersMatch; // 看它是否在当前范围

    if (handler.scope === scope || handler.scope === 'all') {
      // 检查是否匹配修饰符（如果有返回true）
      modifiersMatch = handler.mods.length > 0;

      for (var y in _mods) {
        if (Object.prototype.hasOwnProperty.call(_mods, y)) {
          if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
            modifiersMatch = false;
          }
        }
      } // 调用处理程序，如果是修饰键不做处理


      if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {
        if (handler.method(event, handler) === false) {
          if (event.preventDefault) event.preventDefault();else event.returnValue = false;
          if (event.stopPropagation) event.stopPropagation();
          if (event.cancelBubble) event.cancelBubble = true;
        }
      }
    }
  } // 处理keydown事件


  function dispatch(event) {
    var asterisk = _handlers['*'];
    var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键

    if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致
    // Webkit左右 command 键值不一样

    if (key === 93 || key === 224) key = 91;
    /**
     * Collect bound keys
     * If an Input Method Editor is processing key input and the event is keydown, return 229.
     * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229
     * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
     */

    if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
    /**
     * Jest test cases are required.
     * ===============================
     */

    ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {
      var keyNum = modifierMap[keyName];

      if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
        _downKeys.push(keyNum);
      } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
        _downKeys.splice(_downKeys.indexOf(keyNum), 1);
      } else if (keyName === 'metaKey' && event[keyName] && _downKeys.length === 3) {
        /**
         * Fix if Command is pressed:
         * ===============================
         */
        if (!(event.ctrlKey || event.shiftKey || event.altKey)) {
          _downKeys = _downKeys.slice(_downKeys.indexOf(keyNum));
        }
      }
    });
    /**
     * -------------------------------
     */

    if (key in _mods) {
      _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上

      for (var k in _modifier) {
        if (_modifier[k] === key) hotkeys[k] = true;
      }

      if (!asterisk) return;
    } // 将 modifierMap 里面的修饰键绑定到 event 中


    for (var e in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, e)) {
        _mods[e] = event[modifierMap[e]];
      }
    }
    /**
     * https://github.com/jaywcjlove/hotkeys/pull/129
     * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.
     * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type μ.
     * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate
     */


    if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {
      if (_downKeys.indexOf(17) === -1) {
        _downKeys.push(17);
      }

      if (_downKeys.indexOf(18) === -1) {
        _downKeys.push(18);
      }

      _mods[17] = true;
      _mods[18] = true;
    } // 获取范围 默认为 `all`


    var scope = getScope(); // 对任何快捷键都需要做的处理

    if (asterisk) {
      for (var i = 0; i < asterisk.length; i++) {
        if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {
          eventHandler(event, asterisk[i], scope);
        }
      }
    } // key 不在 _handlers 中返回


    if (!(key in _handlers)) return;

    for (var _i = 0; _i < _handlers[key].length; _i++) {
      if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {
        if (_handlers[key][_i].key) {
          var record = _handlers[key][_i];
          var splitKey = record.splitKey;
          var keyShortcut = record.key.split(splitKey);
          var _downKeysCurrent = []; // 记录当前按键键值

          for (var a = 0; a < keyShortcut.length; a++) {
            _downKeysCurrent.push(code(keyShortcut[a]));
          }

          if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {
            // 找到处理内容
            eventHandler(event, record, scope);
          }
        }
      }
    }
  } // 判断 element 是否已经绑定事件


  function isElementBind(element) {
    return elementHasBindEvent.indexOf(element) > -1;
  }

  function hotkeys(key, option, method) {
    _downKeys = [];
    var keys = getKeys(key); // 需要处理的快捷键列表

    var mods = [];
    var scope = 'all'; // scope默认为all，所有范围都有效

    var element = document; // 快捷键事件绑定节点

    var i = 0;
    var keyup = false;
    var keydown = true;
    var splitKey = '+'; // 对为设定范围的判断

    if (method === undefined && typeof option === 'function') {
      method = option;
    }

    if (Object.prototype.toString.call(option) === '[object Object]') {
      if (option.scope) scope = option.scope; // eslint-disable-line

      if (option.element) element = option.element; // eslint-disable-line

      if (option.keyup) keyup = option.keyup; // eslint-disable-line

      if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line

      if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line
    }

    if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理

    for (; i < keys.length; i++) {
      key = keys[i].split(splitKey); // 按键列表

      mods = []; // 如果是组合快捷键取得组合快捷键

      if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码

      key = key[key.length - 1];
      key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键
      // 判断key是否在_handlers中，不在就赋一个空数组

      if (!(key in _handlers)) _handlers[key] = [];

      _handlers[key].push({
        keyup: keyup,
        keydown: keydown,
        scope: scope,
        mods: mods,
        shortcut: keys[i],
        method: method,
        key: keys[i],
        splitKey: splitKey
      });
    } // 在全局document上设置快捷键


    if (typeof element !== 'undefined' && !isElementBind(element) && window) {
      elementHasBindEvent.push(element);
      addEvent(element, 'keydown', function (e) {
        dispatch(e);
      });
      addEvent(window, 'focus', function () {
        _downKeys = [];
      });
      addEvent(element, 'keyup', function (e) {
        dispatch(e);
        clearModifier(e);
      });
    }
  }

  var _api = {
    setScope: setScope,
    getScope: getScope,
    deleteScope: deleteScope,
    getPressedKeyCodes: getPressedKeyCodes,
    isPressed: isPressed,
    filter: filter,
    unbind: unbind
  };

  for (var a in _api) {
    if (Object.prototype.hasOwnProperty.call(_api, a)) {
      hotkeys[a] = _api[a];
    }
  }

  if (typeof window !== 'undefined') {
    var _hotkeys = window.hotkeys;

    hotkeys.noConflict = function (deep) {
      if (deep && window.hotkeys === hotkeys) {
        window.hotkeys = _hotkeys;
      }

      return hotkeys;
    };

    window.hotkeys = hotkeys;
  }

  hotkeys.filter = function () {
    return true;
  };

  var tagFilter = function tagFilter(_ref, enableOnTags) {
    var target = _ref.target;
    var targetTagName = target && target.tagName;
    return Boolean(targetTagName && enableOnTags && enableOnTags.includes(targetTagName));
  };

  var isKeyboardEventTriggeredByInput = function isKeyboardEventTriggeredByInput(ev) {
    return tagFilter(ev, ['INPUT', 'TEXTAREA', 'SELECT']);
  };

  function useHotkeys(keys, callback, options, deps) {
    if (options instanceof Array) {
      deps = options;
      options = undefined;
    }

    var _ref2 = options || {},
        enableOnTags = _ref2.enableOnTags,
        filter = _ref2.filter,
        keyup = _ref2.keyup,
        keydown = _ref2.keydown,
        _ref2$filterPreventDe = _ref2.filterPreventDefault,
        filterPreventDefault = _ref2$filterPreventDe === void 0 ? true : _ref2$filterPreventDe,
        _ref2$enabled = _ref2.enabled,
        enabled = _ref2$enabled === void 0 ? true : _ref2$enabled,
        _ref2$enableOnContent = _ref2.enableOnContentEditable,
        enableOnContentEditable = _ref2$enableOnContent === void 0 ? false : _ref2$enableOnContent;

    var ref = react.exports.useRef(null); // The return value of this callback determines if the browsers default behavior is prevented.

    var memoisedCallback = react.exports.useCallback(function (keyboardEvent, hotkeysEvent) {
      var _keyboardEvent$target;

      if (filter && !filter(keyboardEvent)) {
        return !filterPreventDefault;
      } // Check whether the hotkeys was triggered inside an input and that input is enabled or if it was triggered by a content editable tag and it is enabled.


      if (isKeyboardEventTriggeredByInput(keyboardEvent) && !tagFilter(keyboardEvent, enableOnTags) || (_keyboardEvent$target = keyboardEvent.target) != null && _keyboardEvent$target.isContentEditable && !enableOnContentEditable) {
        return true;
      }

      if (ref.current === null || document.activeElement === ref.current) {
        callback(keyboardEvent, hotkeysEvent);
        return true;
      }

      return false;
    }, deps ? [ref, enableOnTags, filter].concat(deps) : [ref, enableOnTags, filter]);
    react.exports.useEffect(function () {
      if (!enabled) {
        hotkeys.unbind(keys, memoisedCallback);
        return;
      } // In this case keydown is likely undefined, so we set it to false, since hotkeys needs the `keydown` key to have a value.


      if (keyup && keydown !== true) {
        options.keydown = false;
      }

      hotkeys(keys, options || {}, memoisedCallback);
      return function () {
        return hotkeys.unbind(keys, memoisedCallback);
      };
    }, [memoisedCallback, keys, enabled]);
    return ref;
  }

  const initialDocumentDomain = typeof document === 'undefined' ? void 0 : document.domain;

  function bypassKeyStroke(e, refs) {
    const isKeyDown = e.type === 'keydown';
    refs.current.keysPressed['z'] = isKeyDown;
    $('html')[isKeyDown ? 'addClass' : 'removeClass'](iceBypassKeyClass);
    document.dispatchEvent(new CustomEvent(editModeIceBypassEvent, {
      detail: isKeyDown
    }));
  }

  function Guest(props) {
    var _state$dragContext, _state$dragContext$dr, _state$dragContext2, _state$dragContext2$d, _Object$entries$find, _elementRegistry$get;

    // TODO: support path driven Guest.
    // TODO: consider supporting developer to provide the data source (promise/observable?)
    const {
      path,
      themeOptions,
      sxOverrides,
      children,
      documentDomain,
      scrollElement = 'html, body',
      isHeadlessMode = false
    } = props;
    const theme = useGuestTheme(themeOptions);
    const [snack, setSnack] = react.exports.useState();
    const dispatch = useDispatch();
    const state = useSelector(state => state);
    const {
      editMode,
      highlightMode,
      editModePadding,
      status,
      hostCheckedIn: hasHost,
      draggable
    } = state;
    const refs = react.exports.useRef({
      contentReady: false,
      firstRender: true,
      keysPressed: {},
      hasChanges: false
    }); // TODO: Avoid double re-render when draggable changes without coupling to redux on useICE

    const context = react.exports.useMemo(() => ({
      hasHost,
      editMode,
      draggable,
      highlightMode,

      onEvent(event, dispatcherElementRecordId) {
        if (hasHost && editMode && refs.current.contentReady) {
          const {
            type
          } = event;
          const record = get(dispatcherElementRecordId);

          if (nullOrUndefined(record)) {
            console.error('[Guest] No record found for dispatcher element');
          } else {
            if (refs.current.keysPressed.z && type === 'click') {
              return false;
            } // Click & dblclick require stopping as early as possible to avoid
            // navigation or other click defaults.


            if (type === 'click' || 'dblclick' === type) {
              event.preventDefault();
              event.stopPropagation();
            }

            dispatch({
              type,
              payload: {
                event,
                record
              }
            });
            return true;
          }
        }

        return false;
      }

    }), [dispatch, hasHost, draggable, editMode, highlightMode]);
    const sxStylesConfig = react.exports.useMemo(() => {
      return deepmerge(styleSxDefaults, sxOverrides);
    }, [sxOverrides]); // region Hotkeys
    // This requires maintenance as key shortcuts evolve/change.

    useHotkeys('m,e,p,shift+/', e => {
      post(hotKey({
        key: e.key,
        type: 'keydown'
      }));
    }); // ICE bypass key

    useHotkeys('z', e => {
      bypassKeyStroke(e, refs);
    }, {
      keyup: true,
      keydown: true
    }); // endregion

    react.exports.useEffect(() => {
      const $html = $('html');
      const cls = highlightMode === HighlightMode.MOVE_TARGETS ? moveModeClass : editModeClass;

      if (editMode) {
        $html.addClass(cls);
        return () => {
          $html.removeClass(cls);
        };
      }
    }, [editMode, highlightMode]);
    react.exports.useEffect(() => {
      const $html = $('html');

      if (editMode && editModePadding) {
        $html.addClass(editModePaddingClass);
        return () => {
          $html.removeClass(editModePaddingClass);
        };
      }
    }, [editMode, editModePadding]); // Sets document domain

    react.exports.useEffect(() => {
      if (documentDomain) {
        try {
          document.domain = documentDomain;
        } catch (e) {
          console.error(e);
        }
      } else if (document.domain !== initialDocumentDomain) {
        document.domain = initialDocumentDomain;
      }
    }, [documentDomain]); // Add/remove edit on class

    react.exports.useEffect(() => {
      if (editMode === false) {
        $('html').removeClass(editOnClass);
        document.dispatchEvent(new CustomEvent(editModeEvent, {
          detail: false
        })); // Refreshing the page for now. Will revisit on a later release.

        if (!refs.current.firstRender && refs.current.hasChanges) {
          window.location.reload();
        }
      } else {
        $('html').addClass(editOnClass);
        document.dispatchEvent(new CustomEvent(editModeEvent, {
          detail: true
        }));
      }

      if (refs.current.firstRender) {
        refs.current.firstRender = false;
      }
    }, [editMode]); // Subscribes to host messages and routes them.

    react.exports.useEffect(() => {
      const sub = message$.subscribe(function (action) {
        const {
          type,
          payload
        } = action;

        switch (type) {
          case highlightModeChanged.type:
          case setPreviewEditMode.type:
            if (status === EditingStatus.FIELD_SELECTED && action.payload.highlightMode !== 'move') {
              clearAndListen$.next();
            }

            dispatch(action);
            break;

          case assetDragStarted.type:
            dispatch(assetDragStarted({
              asset: payload
            }));
            break;

          case assetDragEnded.type:
            dragOk(status) && dispatch(action);
            break;

          case componentDragStarted.type:
            dispatch(componentDragStarted({
              contentType: payload
            }));
            break;

          case componentDragEnded.type:
            dragOk(status) && dispatch(action);
            break;

          case componentInstanceDragEnded.type:
            dragOk(status) && dispatch(action);
            break;

          case trashed.type:
            dispatch(trashed({
              iceId: payload
            }));
            break;

          case clearSelectedZones.type:
            clearAndListen$.next();
            dispatch(startListening());
            break;

          case reloadRequest.type:
            {
              post(guestCheckOut({
                path
              }));
              return window.location.reload();
            }

          case navigationRequest.type:
            {
              post(guestCheckOut({
                path
              }));
              return window.location.href = payload.url;
            }

          case contentTypeDropTargetsRequest.type:
            {
              dispatch(contentTypeDropTargetsRequest({
                contentTypeId: payload
              }));
              break;
            }

          case scrollToDropTarget.type:
            scrollToDropTargets([payload], scrollElement, id => fromICEId(id).element);
            break;

          case contentTreeFieldSelected.type:
            {
              dispatch(contentTreeFieldSelected({
                iceProps: {
                  modelId: payload.parentId || payload.modelId,
                  fieldId: payload.fieldId,
                  index: payload.index
                },
                scrollElement,
                name: payload.name
              }));
              break;
            }

          case clearContentTreeFieldSelected.type:
            clearAndListen$.next();
            dispatch({
              type
            });
            break;

          case componentInstanceDragStarted.type:
          case clearHighlightedDropTargets.type:
          case desktopAssetUploadProgress.type:
          case desktopAssetUploadComplete.type:
          case updateRteConfig.type:
          case setEditModePadding.type:
            dispatch(action);
            break;

          case hotKey.type:
            if (payload.key === 'z') {
              bypassKeyStroke(payload, refs);
            }

            break;
        }
      });
      return () => {
        sub.unsubscribe();
      };
    }, [dispatch, path, scrollElement, status]); // Host detection

    react.exports.useEffect(() => {
      if (!hasHost) {
        // prettier-ignore
        interval(1000).pipe(takeUntil(merge$1(fromTopic(hostCheckIn.type), fromTopic('LEGACY_CHECK_IN')).pipe(tap(dispatch), take(1))), take(1)).subscribe(() => setSnack({
          duration: 8000,
          message: 'In-context editing is disabled: page running out of Crafter CMS frame.'
        }));
      }
    }, [dispatch, hasHost]); // Load dependencies (tinymce, ace)

    react.exports.useEffect(() => {
      if (hasHost && !window.tinymce) {
        const script = document.createElement('script');
        script.src = '/studio/static-assets/modules/editors/tinymce/v5/tinymce/tinymce.min.js'; // script.onload = () => ...;

        document.head.appendChild(script);
      }

      if (hasHost && !window.ace) {
        const script = document.createElement('script');
        script.src = '/studio/static-assets/libs/ace/ace.js';
        document.head.appendChild(script);
        const styleSheet = document.createElement('link');
        styleSheet.rel = 'stylesheet';
        styleSheet.href = '/studio/static-assets/styles/tinymce-ace.css';
        document.head.appendChild(styleSheet);
      }
    }, [hasHost]); // Check out (dismount, beforeunload)

    react.exports.useEffect(() => {
      // Notice this is not executed when the iFrame url is changed abruptly.
      // This only triggers when navigation occurs from within the guest page.
      const handler = () => post(guestCheckOut({
        path
      }));

      window.addEventListener('beforeunload', handler, false);
      return () => {
        post(guestCheckOut({
          path
        }));
        window.removeEventListener('beforeunload', handler);
      };
    }, [path]); // Registers parent zone, check in, checkout (when model is changed), content ready subscription

    react.exports.useEffect(() => {
      let iceId;
      const location = createLocationArgument();
      const site = api.get('crafterSite');
      const operationsSubscription = operationsObs$.pipe(take(1)).subscribe(() => refs.current.hasChanges = true);
      refs.current.hasChanges = false;
      fromTopic('FETCH_GUEST_MODEL_COMPLETE').pipe(filter$1(({
        payload
      }) => payload.path === path), pluck('payload', 'model'), withLatestFrom(contentTypesObs$), take(1)).subscribe(([model]) => {
        iceId = register$1({
          modelId: model.craftercms.id
        });
        refs.current.contentReady = true;
        dispatch(contentReady());
      });
      post(guestCheckIn({
        location,
        path,
        site,
        documentDomain
      }));
      return () => {
        post(guestCheckOut({
          path
        }));
        nnou(iceId) && deregister$1(iceId); // eslint-disable-next-line react-hooks/exhaustive-deps

        refs.current.contentReady = false;
        flushRequestedPaths();
        operationsSubscription.unsubscribe();
      };
    }, [dispatch, documentDomain, path]); // Listen for desktop asset drag & drop

    const shouldNotBypass = hasHost && editMode;
    react.exports.useEffect(() => {
      if (shouldNotBypass) {
        const subscription = fromEvent(document, 'dragenter').pipe(filter$1(e => {
          var _e$dataTransfer;

          return ((_e$dataTransfer = e.dataTransfer) === null || _e$dataTransfer === void 0 ? void 0 : _e$dataTransfer.types.includes('Files')) && refs.current.contentReady;
        })).subscribe(e => {
          e.preventDefault();
          e.stopPropagation();

          if (e.dataTransfer.items[0].type.startsWith('image') && e.dataTransfer.items[0].kind === 'file') {
            dispatch(desktopAssetDragStarted({
              asset: e.dataTransfer.items[0]
            }));
          }
        });
        return () => subscription.unsubscribe();
      }
    }, [dispatch, shouldNotBypass]); // Listen for drag events for desktop asset drag & drop

    react.exports.useEffect(() => {
      if ([EditingStatus.UPLOAD_ASSET_FROM_DESKTOP, EditingStatus.SORTING_COMPONENT, EditingStatus.PLACING_NEW_COMPONENT, EditingStatus.PLACING_DETACHED_COMPONENT, EditingStatus.PLACING_DETACHED_ASSET].includes(status)) {
        const dropSubscription = fromEvent(document, 'drop').subscribe(event => {
          dispatch(documentDrop({
            event
          }));
        });
        const dragendSubscription = fromEvent(document, 'dragend').subscribe(event => {
          dispatch(documentDragEnd({
            event
          }));
        });
        const dragoverSubscription = fromEvent(document, 'dragover').subscribe(event => dispatch(documentDragOver({
          event
        })));
        const dragleaveSubscription = fromEvent(document, 'dragleave').subscribe(event => {
          dispatch(documentDragLeave({
            event
          }));
        });
        return () => {
          dropSubscription.unsubscribe();
          dragendSubscription.unsubscribe();
          dragoverSubscription.unsubscribe();
          dragleaveSubscription.unsubscribe();
        };
      }
    }, [dispatch, status]); // Listen for mouse switching between drop zones

    const dragContextDropZoneIceId = (_state$dragContext = state.dragContext) === null || _state$dragContext === void 0 ? void 0 : (_state$dragContext$dr = _state$dragContext.dropZone) === null || _state$dragContext$dr === void 0 ? void 0 : _state$dragContext$dr.iceId;
    const dragContextDropZoneElementRecordId = (_state$dragContext2 = state.dragContext) === null || _state$dragContext2 === void 0 ? void 0 : (_state$dragContext2$d = _state$dragContext2.dropZone) === null || _state$dragContext2$d === void 0 ? void 0 : _state$dragContext2$d.elementRecordId;
    react.exports.useEffect(() => {
      if (nnou(dragContextDropZoneIceId)) {
        dispatch(dropzoneEnter({
          elementRecordId: dragContextDropZoneElementRecordId
        }));
        return () => {
          dispatch(dropzoneLeave({
            elementRecordId: dragContextDropZoneElementRecordId
          }));
        };
      }
    }, [dispatch, dragContextDropZoneElementRecordId, dragContextDropZoneIceId]);
    const draggableItemElemRecId = state.draggable && ((_Object$entries$find = Object.entries(state.draggable).find(([, ice]) => ice !== false)) === null || _Object$entries$find === void 0 ? void 0 : _Object$entries$find[0]);
    const hasZoneMarker = [EditingStatus.SORTING_COMPONENT, EditingStatus.PLACING_NEW_COMPONENT, EditingStatus.PLACING_DETACHED_COMPONENT].includes(status) && state.dragContext.inZone && !state.dragContext.invalidDrop;
    return /*#__PURE__*/React.createElement(GuestContextProvider, {
      value: context
    }, children, /*#__PURE__*/React.createElement(ThemeProvider, {
      theme: theme
    }, editMode && /*#__PURE__*/React.createElement(CrafterCMSPortal, null, draggableItemElemRecId && /*#__PURE__*/React.createElement(DragGhostElement, {
      label: (_elementRegistry$get = get(parseInt(draggableItemElemRecId))) === null || _elementRegistry$get === void 0 ? void 0 : _elementRegistry$get.label
    }), Object.values(state.uploading).map(highlight => /*#__PURE__*/React.createElement(AssetUploaderMask, _extends$6({
      key: highlight.id
    }, highlight))), state.fieldSwitcher && /*#__PURE__*/React.createElement(FieldInstanceSwitcher, {
      onNext: () => dispatch(contentTreeSwitchFieldInstance({
        type: 'next',
        scrollElement
      })),
      onPrev: () => dispatch(contentTreeSwitchFieldInstance({
        type: 'prev',
        scrollElement
      })),
      registryEntryIds: state.fieldSwitcher.registryEntryIds,
      currentElement: state.fieldSwitcher.currentElement
    }), Object.values(state.highlighted).map(highlight => {
      const isMove = HighlightMode.MOVE_TARGETS === highlightMode;
      const isFieldSelectedMode = status === EditingStatus.FIELD_SELECTED;
      const validations = Object.values(highlight.validations);
      const hasValidations = Boolean(validations.length);
      const hasFailedRequired = validations.some(({
        level
      }) => level === 'required');
      const elementRecord = get(highlight.id);
      return /*#__PURE__*/React.createElement(ZoneMarker, {
        key: highlight.id,
        label: highlight.label,
        rect: highlight.rect,
        inherited: highlight.inherited,
        onPopperClick: isMove && isFieldSelectedMode ? e => {
          e.preventDefault();
          e.stopPropagation();
        } : null,
        menuItems: isFieldSelectedMode ? /*#__PURE__*/React.createElement(MoveModeZoneMenu, {
          record: elementRecord,
          dispatch: dispatch,
          isHeadlessMode: isHeadlessMode
        }) : void 0,
        sx: deepmerge(deepmerge({ ...sxStylesConfig.zoneMarker.base
        }, isMove ? styleSxDefaults.zoneMarker.moveModeHighlight : styleSxDefaults.zoneMarker.selectModeHighlight), hasValidations ? hasFailedRequired ? styleSxDefaults.zoneMarker.errorHighlight : styleSxDefaults.zoneMarker.warnHighlight : null)
      });
    }), hasZoneMarker && /*#__PURE__*/React.createElement(DropMarker, {
      onDropPosition: payload => dispatch(setDropPosition(payload)),
      dropZone: state.dragContext.dropZone,
      over: state.dragContext.over,
      prev: state.dragContext.prev,
      next: state.dragContext.next,
      coordinates: state.dragContext.coordinates
    })), snack && /*#__PURE__*/React.createElement(SnackBar, _extends$6({
      open: true,
      onClose: () => setSnack(null)
    }, snack), snack.message), /*#__PURE__*/React.createElement(GuestGlobalStyles, null)));
  }

  function CrafterCMSGuest(props) {
    let {
      children,
      isAuthoring = false,
      path,
      model
    } = props;
    let store = react.exports.useMemo(() => isAuthoring && createGuestStore(), [isAuthoring]);
    path = path || prop(model, 'path');
    return isAuthoring && path ? /*#__PURE__*/React.createElement(Provider, {
      store: store,
      context: GuestReduxContext
    }, /*#__PURE__*/React.createElement(Guest, _extends$6({}, props, {
      path: path
    }))) : children;
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU General Public License version 3 as published by
   * the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   * GNU General Public License for more details.
   *
   * You should have received a copy of the GNU General Public License
   * along with this program.  If not, see <http://www.gnu.org/licenses/>.
   */
  function GuestProxy() {
    const draggable = useSelector(state => state.draggable);
    const {
      onEvent
    } = useGuestContext();
    const persistenceRef = react.exports.useRef({
      draggableElement: null,
      onEvent
    });
    persistenceRef.current.onEvent = onEvent; // Initial registration of elements.

    react.exports.useEffect(() => {
      // Registers a single element
      const registerElement = element => {
        let path = element.getAttribute('data-craftercms-model-path');
        let modelId = element.getAttribute('data-craftercms-model-id');
        let fieldId = element.getAttribute('data-craftercms-field-id');
        let index = element.getAttribute('data-craftercms-index');
        let label = element.getAttribute('data-craftercms-label');

        if (notNullOrUndefined(index) && !index.includes('.')) {
          // TODO: Need to assess the impact of index being a string with dot notation
          // Unsure if somewhere, the system relies on the index being an integer/number.
          // Affected inventory:
          // - Guest.moveComponent() - string type handled
          index = parseInt(index, 10);
        }

        register({
          element,
          modelId,
          fieldId,
          index,
          label,
          path
        });
      }; // Used to assign new indexes to a given collection when one items get shifted (move up/down, insert, delete).
      // Inspects the supplied index, if it has dot notation it process it accordingly.


      const appendIndex = (index, value) => {
        return typeof index === 'string' ? `${removeLastPiece(index)}.${parseInt(popPiece(index)) + value}` : index + value;
      };

      const generateIndex = (index, value) => {
        return typeof index === 'string' ? `${removeLastPiece(index)}.${value}` : value;
      };

      const updateElementRegistrations = (collection, type, newIndex, oldIndex, fieldId) => {
        let originalNewIndex = newIndex;
        let originalOldIndex = oldIndex;
        newIndex = typeof newIndex === 'string' ? parseInt(popPiece(newIndex)) : newIndex;
        oldIndex = typeof oldIndex === 'string' ? parseInt(popPiece(oldIndex)) : oldIndex; // Note for the loops below:
        // Because more than one item may change their index, we need to deregister all items before
        // proceeding to registering again. Registering immediately after de-registering on the same
        // loop causes misjudging ICE records refCounts due to displaced collection items.

        function updateRepeatGroupsItems(element, fieldId, index, newIndex, elements) {
          element.querySelectorAll(`[data-craftercms-field-id^="${fieldId}."][data-craftercms-index^="${index}"]`).forEach(element => {
            let position = $(element).attr('data-craftercms-field-id').split('.').indexOf(isSimple(fieldId) ? fieldId : popPiece(fieldId));
            let elementIndex = $(element).attr('data-craftercms-index');
            let splitIndex = elementIndex.split('.');
            splitIndex[position] = isSimple(fieldId) ? newIndex.toString() : popPiece(newIndex.toString());
            $(element).attr('data-craftercms-index', splitIndex.join('.'));
            elements.push(element);
            const elementRecord = fromElement(element);
            elementRecord && deregister(elementRecord.id);
          });
        }

        if (type === 'insert' || type === 'delete') {
          const itemsToReRegister = collection.slice(newIndex);
          const childrenToRegister = [];
          itemsToReRegister.forEach((el, i) => {
            const currentElementIndex = $(el).attr('data-craftercms-index');
            const elementNewIndex = appendIndex(originalNewIndex, i);

            if (type === 'insert' && String(originalNewIndex) === String(elementNewIndex)) {
              addAnimation($(el), 'craftercms-content-tree-locate');
            }

            $(el).attr('data-craftercms-index', elementNewIndex);
            updateRepeatGroupsItems(el, fieldId, currentElementIndex, elementNewIndex, childrenToRegister);
            const elementRecord = fromElement(el);
            elementRecord && deregister(elementRecord.id);
          });
          itemsToReRegister.concat(childrenToRegister).forEach(el => registerElement(el));
        } else if (type === 'sort') {
          let from;
          let to;
          let index;

          if (oldIndex < newIndex) {
            from = oldIndex;
            to = newIndex + 1;
            index = originalOldIndex;
          } else {
            from = newIndex;
            to = oldIndex + 1;
            index = originalNewIndex;
          }

          const itemsToReRegister = collection.slice(from, to);
          const childrenToRegister = [];
          itemsToReRegister.forEach((el, i) => {
            const currentElementIndex = $(el).attr('data-craftercms-index');
            const elementNewIndex = appendIndex(index, i);
            $(el).attr('data-craftercms-index', elementNewIndex);
            updateRepeatGroupsItems(el, fieldId, currentElementIndex, elementNewIndex, childrenToRegister);

            if (originalOldIndex === elementNewIndex) {
              addAnimation($(el), 'craftercms-content-tree-locate');
            }

            const elementRecord = fromElement(el);
            elementRecord && deregister(elementRecord.id);
          });
          itemsToReRegister.concat(childrenToRegister).forEach(el => registerElement(el));
        }
      };

      const insertElement = ($element, $daddy, targetIndex) => {
        const index = typeof targetIndex === 'string' ? parseInt(popPiece(targetIndex)) : targetIndex;
        const $siblings = $daddy.find('> *');

        if ($siblings.length === index) {
          $daddy.append($element);
        } else {
          $element.insertBefore($siblings.eq(index));
        }
      };

      zip(modelsObs$, contentTypesObs$, pathsObs$).pipe(take(1)).subscribe(() => {
        document.querySelectorAll('[data-craftercms-model-id]').forEach(registerElement);
      });

      const handler = e => {
        let record = fromElement(e.currentTarget);

        if (notNullOrUndefined(record)) {
          persistenceRef.current.onEvent(e, record.id);
        }
      };

      $(document).on('mouseover', '[data-craftercms-model-id]', handler).on('mouseleave', '[data-craftercms-model-id]', handler).on('dragstart', '[data-craftercms-model-id]', handler).on('dragover', '[data-craftercms-model-id]', handler).on('dragleave', '[data-craftercms-model-id]', handler).on('drop', '[data-craftercms-model-id]', handler).on('dragend', '[data-craftercms-model-id]', handler).on('click', '[data-craftercms-model-id]', handler).on('dblclick', '[data-craftercms-model-id]', handler);
      const sub = operationsObs$.subscribe(op => {
        switch (op.type) {
          case sortItemOperation.type:
            {
              let [modelId, fieldId, index, newIndex] = op.args;
              const currentIndexParsed = typeof index === 'number' ? index : parseInt(popPiece(index));
              const targetIndexParsed = typeof newIndex === 'number' ? newIndex : parseInt(popPiece(newIndex)); // This works only for repeat groups

              let iceId = exists({
                modelId,
                fieldId,
                index
              }); // This would work for both repeat groups and node-selectors. Just use this?

              if (iceId === null) {
                const model = getCachedModel(modelId); // By this point - on the operations subscriber - the operation has already gone through.
                // Hence, need to use the "newIndex" to retrieve the model in question. The registration
                // hasn't been updated yet so still using the old index.

                iceId = exists({
                  modelId: model[fieldId][newIndex],
                  index
                });
              }

              const phyRecord = fromICEId(iceId);
              const $el = $(phyRecord.element);
              const $targetSibling = $el.parent().children().eq(targetIndexParsed); // Move...

              if (currentIndexParsed < targetIndexParsed) {
                $el.insertAfter($targetSibling);
              } else {
                $el.insertBefore($targetSibling);
              }

              updateElementRegistrations(Array.from($el.parent().children()), 'sort', index, newIndex, fieldId);
              break;
            }

          case moveItemOperation.type:
            {
              const [modelId
              /* : string */
              , fieldId
              /* : string */
              , index
              /* : number */
              , targetModelId
              /* : string */
              , targetFieldId
              /* : string */
              , targetIndex] = op.args;
              const targetIndexParsed = typeof targetIndex === 'number' ? targetIndex : parseInt(popPiece(targetIndex));
              const currentDropZoneICEId = exists({
                modelId,
                fieldId,
                index: fieldId.includes('.') ? parseInt(removeLastPiece(index)) : null
              });
              const currentDropZonePhyRecord = fromICEId(currentDropZoneICEId);
              const targetDropZoneICEId = exists({
                modelId: targetModelId,
                fieldId: targetFieldId,
                index: targetFieldId.includes('.') ? parseInt(removeLastPiece(targetIndex)) : null
              });
              const targetDropZonePhyRecord = fromICEId(targetDropZoneICEId);
              const moveTargetICEId = exists({
                modelId,
                fieldId,
                index
              });
              const moveTargetPhyRecord = fromICEId(moveTargetICEId);
              const $sourceDropZone = $(currentDropZonePhyRecord.element);
              const $targetDropZone = $(targetDropZonePhyRecord.element);

              if (targetIndexParsed === 0) {
                $targetDropZone.prepend(moveTargetPhyRecord.element);
              } else if ($targetDropZone.children().length === targetIndexParsed) {
                $targetDropZone.append(moveTargetPhyRecord.element);
              } else {
                const targetIndexOccupantICEId = exists({
                  modelId: targetModelId,
                  fieldId: targetFieldId,
                  index: targetIndex
                });
                const targetIndexOccupantPhyRecord = fromICEId(targetIndexOccupantICEId);
                $(moveTargetPhyRecord.element).insertBefore(targetIndexOccupantPhyRecord.element);
              }

              [currentDropZonePhyRecord, targetDropZonePhyRecord].forEach(record => {
                let newIndex = record === currentDropZonePhyRecord ? index : targetIndex;
                $(record.element).find('> [data-craftercms-index]').each((i, elem) => {
                  deregister(fromElement(elem).id);
                  $(elem).attr('data-craftercms-model-id', record.modelId);
                  $(elem).attr('data-craftercms-field-id', record.fieldId);
                  $(elem).attr('data-craftercms-index', generateIndex(newIndex, i));
                  registerElement(elem);
                });
              });
              $targetDropZone.removeClass(emptyCollectionClass);

              if ($sourceDropZone.children().length === 0) {
                $sourceDropZone.addClass(emptyCollectionClass);
              }

              addAnimation($(moveTargetPhyRecord.element), 'craftercms-content-tree-locate');
              break;
            }

          case deleteItemOperation.type:
            {
              const [modelId, fieldId, index] = op.args;
              const iceId = exists({
                modelId,
                fieldId,
                index
              });
              const phyRecord = fromICEId(iceId);
              deregister(phyRecord.id); // Immediate removal of the element causes the dragend event not
              // to fire leaving the state corrupt - in a state of "SORTING".

              setTimeout(() => {
                const $daddy = $(phyRecord.element).parent();
                $(phyRecord.element).remove();

                if ($daddy.children().length === 0) {
                  $daddy.addClass(emptyCollectionClass);
                }

                updateElementRegistrations(Array.from($daddy.children()), 'delete', index, null, fieldId);
              });
              break;
            }

          case insertItemOperation.type:
            {
              message$.pipe(filter$1(e => e.type === insertItemOperationComplete.type), take(1)).subscribe({
                next() {
                  window.location.reload();
                }

              });
              break;
            }

          case duplicateItemOperation.type:
            {
              message$.pipe(filter$1(e => e.type === duplicateItemOperationComplete.type), take(1)).subscribe({
                next() {
                  window.location.reload();
                }

              });
              break;
            }

          case insertComponentOperation.type:
          case insertInstanceOperation.type:
            {
              const {
                modelId,
                fieldId,
                targetIndex,
                instance
              } = op.args;
              const $spinner = $(`
            <svg class="craftercms-placeholder-spinner" width=50 height=50 viewBox="0 0 50 50" xmlns="http://www.w3.org/2000/svg">
              <circle class="path" fill="none" stroke-width=5 stroke-linecap="round" cx="25" cy="25" r="20"/>
            </svg>
          `);
              const $daddy = getParentElementFromICEProps(modelId, fieldId, targetIndex);
              $daddy.removeClass(emptyCollectionClass);
              insertElement($spinner, $daddy, targetIndex);
              message$.pipe(filter$1(e => e.type === insertOperationComplete.type && e.payload.instance.craftercms.id === instance.craftercms.id), take(1)).subscribe(function ({
                payload
              }) {
                const {
                  modelId,
                  fieldId,
                  targetIndex,
                  currentFullUrl
                } = payload;
                let ifrm = document.createElement('iframe');
                ifrm.setAttribute('src', currentFullUrl);
                ifrm.style.width = '0';
                ifrm.style.height = '0';
                document.body.appendChild(ifrm);

                ifrm.onload = function () {
                  $spinner.remove();
                  const itemElement = ifrm.contentWindow.document.documentElement.querySelector(`[data-craftercms-model-id="${modelId}"][data-craftercms-field-id="${fieldId}"][data-craftercms-index="${targetIndex}"]`);
                  const $component = $(itemElement === null || itemElement === void 0 ? void 0 : itemElement.outerHTML);
                  insertElement($component, $daddy, targetIndex);
                  updateElementRegistrations(Array.from($daddy.children()), 'insert', targetIndex, null, fieldId);
                  $component.find('[data-craftercms-model-id]').each((i, el) => registerElement(el));
                  ifrm.remove();
                };
              });
              break;
            }

          case updateFieldValueOperation.type:
            const {
              modelId,
              fieldId,
              index = 0,
              value
            } = op.args;
            const updatedField = $(`[data-craftercms-model-id="${modelId}"][data-craftercms-field-id="${fieldId}"]`);
            const model = getCachedModel(modelId);
            const contentType = getCachedContentType(model.craftercms.contentTypeId);
            const fieldType = getField(contentType, fieldId).type;

            if (fieldType === 'image') {
              const tagName = updatedField.eq(index).prop('tagName').toLowerCase();

              if (tagName === 'img') {
                updatedField.eq(index).attr('src', value);
              } else {
                updatedField.eq(index).css('background-image', `url(${value})`);
              }
            } else if (fieldType === 'video-picker') {
              updatedField.eq(index).find('source').attr('src', value);
              updatedField.eq(index)[0].load();
            }

            break;
        }
      });
      return () => {
        sub.unsubscribe();
        $(document).off('mouseover', '[data-craftercms-model-id]', handler).off('mouseleave', '[data-craftercms-model-id]', handler).off('dragstart', '[data-craftercms-model-id]', handler).off('dragover', '[data-craftercms-model-id]', handler).off('dragleave', '[data-craftercms-model-id]', handler).off('drop', '[data-craftercms-model-id]', handler).off('dragend', '[data-craftercms-model-id]', handler).off('click', '[data-craftercms-model-id]', handler).off('dblclick', '[data-craftercms-model-id]', handler);
      };
    }, []); // Updates in draggability of elements.

    react.exports.useEffect(() => {
      const persistence = persistenceRef.current;

      if (notNullOrUndefined(persistence.draggableElement)) {
        $(persistence.draggableElement).attr('draggable', 'false').removeAttr('draggable');
      }

      forEach(Object.entries(draggable), ([elemId, iceId]) => {
        if (iceId !== false) {
          // @ts-ignore TODO: Fix type
          const record = get(elemId); // Item deletion incurs in a brief moment where a record has been removed
          // but the context draggable table hasn't been cleaned up.

          if (record != null) {
            persistence.draggableElement = record.element;
            $(record.element).attr('draggable', 'true');
          }
        }
      });
    }, [draggable]);
    return /*#__PURE__*/React.createElement(React.Fragment, null);
  }

  /*
   * Copyright (C) 2007-2022 Crafter Software Corporation. All Rights Reserved.
   *
   * This program is free software: you can redistribute it and/or modify
   * it under the terms of the GNU Lesser General Public License version 3
   * as published by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
   * GNU Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public License
   * along with this program. If not, see http://www.gnu.org/licenses/.
   */
  function fetchIsAuthoring(config) {
    var cfg = crafterConf.mix(config);
    return fetch(cfg.baseUrl + "/api/1/config/preview.json?crafterSite=" + cfg.site, cfg.cors ? {
      mode: 'cors'
    } : {}).then(function (response) {
      return response.json();
    }).then(function (response) {
      return response.preview;
    });
  }

  function getICEAttributes(config) {
    let {
      model,
      fieldId,
      index,
      label,
      isAuthoring = true
    } = config;
    let attributes = {};

    if (!isAuthoring) {
      return attributes;
    }

    if (label === null || label === undefined) {
      label = (model === null || model === void 0 ? void 0 : model.craftercms.label) || '';
    }

    attributes['data-craftercms-model-id'] = model.craftercms.id;
    attributes['data-craftercms-model-path'] = model.craftercms.path;
    nnou(fieldId) && (attributes['data-craftercms-field-id'] = fieldId);
    nnou(index) && (attributes['data-craftercms-index'] = index);
    nnou(label) && (attributes['data-craftercms-label'] = label);
    return attributes;
  }
  function initInContextEditing(props) {
    const guestProxyElement = document.createElement('craftercms-guest-proxy');
    const {
      crafterCMSGuestDisabled
    } = queryString$1.parse(window.location.search);
    ReactDOM.render(
    /*#__PURE__*/
    // @ts-ignore - typing system is not playing nice with the {path} | {model} options of GuestProps
    React.createElement(CrafterCMSGuest, _extends$6({
      isAuthoring: crafterCMSGuestDisabled !== 'true'
    }, props), /*#__PURE__*/React.createElement(GuestProxy, null)), guestProxyElement);
  }

  exports.contentController = contentController;
  exports.elementRegistry = elementRegistry;
  exports.fetchIsAuthoring = fetchIsAuthoring;
  exports.fromTopic = fromTopic;
  exports.getICEAttributes = getICEAttributes;
  exports.iceRegistry = iceRegistry;
  exports.initInContextEditing = initInContextEditing;
  exports.post = post;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
